From 07b0e6fe66d8ac19d7584f52a066d2957d858144 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Tue, 19 Aug 2014 22:10:49 -0600
Subject: ntdll: Implement retrieving DOS attributes in
 NtQueryInformationFile.

---
 configure.ac            |   12 +++++++
 dlls/ntdll/directory.c  |    3 +-
 dlls/ntdll/file.c       |   80 ++++++++++++++++++++++++++++++++++++-----------
 dlls/ntdll/ntdll_misc.h |    2 +-
 include/wine/port.h     |   11 +++++++
 libs/port/Makefile.in   |    3 +-
 libs/port/xattr.c       |   61 ++++++++++++++++++++++++++++++++++++
 7 files changed, 150 insertions(+), 22 deletions(-)
 create mode 100644 libs/port/xattr.c

diff --git a/configure.ac b/configure.ac
index 7de7a87..b77c12f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -75,6 +75,7 @@ AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthrea
 AC_ARG_WITH(sane,      AS_HELP_STRING([--without-sane],[do not use SANE (scanner support)]))
 AC_ARG_WITH(tiff,      AS_HELP_STRING([--without-tiff],[do not use TIFF]))
 AC_ARG_WITH(v4l,       AS_HELP_STRING([--without-v4l],[do not use v4l1 (v4l support)]))
+AC_ARG_WITH(xattr,     AS_HELP_STRING([--without-xattr],[do not use xattr (security attributes support)]))
 AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
 AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
@@ -667,6 +668,17 @@ AC_CHECK_HEADERS([libprocstat.h],,,
 #include <sys/socket.h>
 #endif])
 
+if test "x$with_xattr" != "xno"
+then
+  AC_CHECK_HEADERS(attr/xattr.h sys/xattr.h sys/extattr.h ,HAVE_XATTR=1)
+fi
+if test "x$with_xattr" == "xyes"
+then
+  WINE_ERROR_WITH(xattr,[test "x$HAVE_XATTR" = "x"],[xattr ${notice_platform}development files not \
+found. Wine will be built without extended attribute support, which probably isn't what you want. \
+You will need to install ${notice_platform}development packages of libacl at the very least.])
+fi
+
 dnl **** Check for working dll ****
 
 AC_SUBST(dlldir,"\${libdir}/wine")
diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index a2796b2..678aef5 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -1381,6 +1381,7 @@ static union file_directory_info *append_entry( void *info_ptr, IO_STATUS_BLOCK
     WCHAR *filename;
     UNICODE_STRING str;
     ULONG attributes = 0;
+    ULONG xattr = 0;
 
     io->u.Status = STATUS_SUCCESS;
     long_len = ntdll_umbstowcs( 0, long_name, strlen(long_name), long_nameW, MAX_DIR_ENTRY_LEN );
@@ -1440,7 +1441,7 @@ static union file_directory_info *append_entry( void *info_ptr, IO_STATUS_BLOCK
     info = (union file_directory_info *)((char *)info_ptr + io->Information);
     if (st.st_dev != curdir.dev) st.st_ino = 0;  /* ignore inode if on a different device */
     /* all the structures start with a FileDirectoryInformation layout */
-    fill_stat_info( &st, info, class );
+    fill_file_info( xattr, &st, info, class );
     info->dir.NextEntryOffset = total_len;
     info->dir.FileIndex = 0;  /* NTFS always has 0 here, so let's not bother with it */
     info->dir.FileAttributes |= attributes;
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 78c375a..c8176dd 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -103,6 +103,41 @@ mode_t FILE_umask = 0;
 
 static const WCHAR ntfsW[] = {'N','T','F','S'};
 
+/* Match the conventions as Samba 3 for storing DOS file attributes;
+ * see {get,set}_ea_dos_attribute() in http://gitweb.samba.org/?p=samba.git;a=blob;f=source3/smbd/dosmode.c
+ * In particular, encode FILE_ATTRIBUTE_* as the string 0x followed by one or two hexadecimal digits.
+ * Differences from Samba 3:
+ * Wine currently only stores hidden and system in xattrs;
+ * Samba 3 also seems to store the readonly and directory bits.
+ * Samba 4 additionally supports NT security descriptors with a different xattr
+ */
+#define SAMBA_XATTR_DOS_ATTRIB XATTR_USER_PREFIX "DOSATTRIB"
+/* We are only interested in some attributes, the others have corresponding Unix attributes */
+#define XATTR_ATTRIBS_MASK     (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)
+
+static inline int get_file_xattr( char *hexattr, int attrlen )
+{
+    if (attrlen > 2 && hexattr[0] == '0' && hexattr[1] == 'x')
+    {
+        hexattr[attrlen] = 0;
+        return strtol( hexattr+2, NULL, 16 ) & XATTR_ATTRIBS_MASK;
+    }
+    return 0;
+}
+
+int fd_get_file_info( int fd, struct stat *st, ULONG *xattr )
+{
+    int len, ret = fstat( fd, st );
+    char hexattr[10];
+
+    *xattr = 0;
+    if (ret == -1) return ret;
+    len = xattr_fget( fd, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
+    if (len == -1) return ret;
+    *xattr |= get_file_xattr( hexattr, len );
+    return ret;
+}
+
 /**************************************************************************
  *                 FILE_CreateFile                    (internal)
  * Open a file.
@@ -1775,7 +1810,7 @@ static inline void get_file_times( const struct stat *st, LARGE_INTEGER *mtime,
 }
 
 /* fetch the attributes of a file */
-static inline ULONG get_file_attributes( const struct stat *st )
+static inline ULONG get_file_attributes( const ULONG xattr, const struct stat *st )
 {
     ULONG attr;
 
@@ -1783,6 +1818,10 @@ static inline ULONG get_file_attributes( const struct stat *st )
         attr = FILE_ATTRIBUTE_DIRECTORY;
     else
         attr = FILE_ATTRIBUTE_ARCHIVE;
+
+    /* if any extended attributes exist then add them to the traditional attributes */
+    attr |= xattr;
+
     if (!(st->st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
         attr |= FILE_ATTRIBUTE_READONLY;
     return attr;
@@ -1790,7 +1829,7 @@ static inline ULONG get_file_attributes( const struct stat *st )
 
 
 /* fill in the file information that depends on the stat info */
-NTSTATUS fill_stat_info( const struct stat *st, void *ptr, FILE_INFORMATION_CLASS class )
+NTSTATUS fill_file_info( const ULONG xattr, const struct stat *st, void *ptr, FILE_INFORMATION_CLASS class )
 {
     switch (class)
     {
@@ -1800,7 +1839,7 @@ NTSTATUS fill_stat_info( const struct stat *st, void *ptr, FILE_INFORMATION_CLAS
 
             get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
                             &info->LastAccessTime, &info->CreationTime );
-            info->FileAttributes = get_file_attributes( st );
+            info->FileAttributes = get_file_attributes( xattr, st );
         }
         break;
     case FileStandardInformation:
@@ -1836,9 +1875,9 @@ NTSTATUS fill_stat_info( const struct stat *st, void *ptr, FILE_INFORMATION_CLAS
     case FileAllInformation:
         {
             FILE_ALL_INFORMATION *info = ptr;
-            fill_stat_info( st, &info->BasicInformation, FileBasicInformation );
-            fill_stat_info( st, &info->StandardInformation, FileStandardInformation );
-            fill_stat_info( st, &info->InternalInformation, FileInternalInformation );
+            fill_file_info( xattr, st, &info->BasicInformation, FileBasicInformation );
+            fill_file_info( xattr, st, &info->StandardInformation, FileStandardInformation );
+            fill_file_info( xattr, st, &info->InternalInformation, FileInternalInformation );
         }
         break;
     /* all directory structures start with the FileDirectoryInformation layout */
@@ -1860,21 +1899,21 @@ NTSTATUS fill_stat_info( const struct stat *st, void *ptr, FILE_INFORMATION_CLAS
                 info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
                 info->EndOfFile.QuadPart      = st->st_size;
             }
-            info->FileAttributes = get_file_attributes( st );
+            info->FileAttributes = get_file_attributes( xattr, st );
         }
         break;
     case FileIdFullDirectoryInformation:
         {
             FILE_ID_FULL_DIRECTORY_INFORMATION *info = ptr;
             info->FileId.QuadPart = st->st_ino;
-            fill_stat_info( st, info, FileDirectoryInformation );
+            fill_file_info( xattr, st, info, FileDirectoryInformation );
         }
         break;
     case FileIdBothDirectoryInformation:
         {
             FILE_ID_BOTH_DIRECTORY_INFORMATION *info = ptr;
             info->FileId.QuadPart = st->st_ino;
-            fill_stat_info( st, info, FileDirectoryInformation );
+            fill_file_info( xattr, st, info, FileDirectoryInformation );
         }
         break;
 
@@ -2026,6 +2065,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
 
     struct stat st;
     int fd, needs_close = FALSE;
+    ULONG xattr;
 
     TRACE("(%p,%p,%p,0x%08x,0x%08x)\n", hFile, io, ptr, len, class);
 
@@ -2050,12 +2090,12 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
     switch (class)
     {
     case FileBasicInformation:
-        if (fstat( fd, &st ) == -1)
+        if (fd_get_file_info( fd, &st, &xattr ) == -1)
             io->u.Status = FILE_GetNtStatus();
         else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
             io->u.Status = STATUS_INVALID_INFO_CLASS;
         else
-            fill_stat_info( &st, ptr, class );
+            fill_file_info( xattr, &st, ptr, class );
         break;
     case FileStandardInformation:
         {
@@ -2064,7 +2104,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
             if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
             else
             {
-                fill_stat_info( &st, info, class );
+                fill_file_info( xattr, &st, info, class );
                 info->DeletePending = FALSE; /* FIXME */
             }
         }
@@ -2079,7 +2119,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
         break;
     case FileInternalInformation:
         if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
-        else fill_stat_info( &st, ptr, class );
+        else fill_file_info( xattr, &st, ptr, class );
         break;
     case FileEaInformation:
         {
@@ -2089,21 +2129,21 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
         break;
     case FileEndOfFileInformation:
         if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
-        else fill_stat_info( &st, ptr, class );
+        else fill_file_info( xattr, &st, ptr, class );
         break;
     case FileAllInformation:
         {
             FILE_ALL_INFORMATION *info = ptr;
             ANSI_STRING unix_name;
 
-            if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
+            if (fd_get_file_info( fd, &st, &xattr ) == -1) io->u.Status = FILE_GetNtStatus();
             else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
                 io->u.Status = STATUS_INVALID_INFO_CLASS;
             else if (!(io->u.Status = server_get_unix_name( hFile, &unix_name )))
             {
                 LONG name_len = len - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName);
 
-                fill_stat_info( &st, info, FileAllInformation );
+                fill_file_info( xattr, &st, info, FileAllInformation );
                 info->StandardInformation.DeletePending = FALSE; /* FIXME */
                 info->EaInformation.EaSize = 0;
                 info->AccessInformation.AccessFlags = 0;  /* FIXME */
@@ -2455,6 +2495,7 @@ NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
     if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
     {
         struct stat st;
+        ULONG xattr = 0;
 
         if (stat( unix_name.Buffer, &st ) == -1)
             status = FILE_GetNtStatus();
@@ -2465,8 +2506,8 @@ NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
             FILE_BASIC_INFORMATION basic;
             FILE_STANDARD_INFORMATION std;
 
-            fill_stat_info( &st, &basic, FileBasicInformation );
-            fill_stat_info( &st, &std, FileStandardInformation );
+            fill_file_info( xattr, &st, &basic, FileBasicInformation );
+            fill_file_info( xattr, &st, &std, FileStandardInformation );
 
             info->CreationTime   = basic.CreationTime;
             info->LastAccessTime = basic.LastAccessTime;
@@ -2497,6 +2538,7 @@ NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC
     if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
     {
         struct stat st;
+        ULONG xattr = 0;
 
         if (stat( unix_name.Buffer, &st ) == -1)
             status = FILE_GetNtStatus();
@@ -2504,7 +2546,7 @@ NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC
             status = STATUS_INVALID_INFO_CLASS;
         else
         {
-            status = fill_stat_info( &st, info, FileBasicInformation );
+            status = fill_file_info( xattr, &st, info, FileBasicInformation );
             if (DIR_is_hidden_file( attr->ObjectName ))
                 info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
         }
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 4370084..ec96427 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -148,7 +148,7 @@ extern NTSTATUS COMM_FlushBuffersFile( int fd ) DECLSPEC_HIDDEN;
 /* file I/O */
 struct stat;
 extern NTSTATUS FILE_GetNtStatus(void) DECLSPEC_HIDDEN;
-extern NTSTATUS fill_stat_info( const struct stat *st, void *ptr, FILE_INFORMATION_CLASS class ) DECLSPEC_HIDDEN;
+extern NTSTATUS fill_file_info( ULONG xattr, const struct stat *st, void *ptr, FILE_INFORMATION_CLASS class ) DECLSPEC_HIDDEN;
 extern NTSTATUS server_get_unix_name( HANDLE handle, ANSI_STRING *unix_name ) DECLSPEC_HIDDEN;
 extern void DIR_init_windows_dir( const WCHAR *windir, const WCHAR *sysdir ) DECLSPEC_HIDDEN;
 extern BOOL DIR_is_hidden_file( const UNICODE_STRING *name ) DECLSPEC_HIDDEN;
diff --git a/include/wine/port.h b/include/wine/port.h
index 3548a44..715a9e2 100644
--- a/include/wine/port.h
+++ b/include/wine/port.h
@@ -363,6 +363,17 @@ extern int mkstemps(char *template, int suffix_len);
 extern int _spawnvp(int mode, const char *cmdname, const char * const argv[]);
 #endif
 
+/* Extended attribute functions */
+
+#ifndef XATTR_USER_PREFIX
+#define XATTR_USER_PREFIX     "user."
+#endif
+#ifndef XATTR_USER_PREFIX_LEN
+#define XATTR_USER_PREFIX_LEN (sizeof(XATTR_USER_PREFIX) - 1)
+#endif
+
+extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
+
 /* Interlocked functions */
 
 #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
diff --git a/libs/port/Makefile.in b/libs/port/Makefile.in
index 65f1714..67efbc7 100644
--- a/libs/port/Makefile.in
+++ b/libs/port/Makefile.in
@@ -23,4 +23,5 @@ C_SRCS = \
 	strerror.c \
 	strncasecmp.c \
 	symlink.c \
-	usleep.c
+	usleep.c \
+	xattr.c
diff --git a/libs/port/xattr.c b/libs/port/xattr.c
new file mode 100644
index 0000000..8b64867
--- /dev/null
+++ b/libs/port/xattr.c
@@ -0,0 +1,61 @@
+/*
+ * extended attributes functions
+ *
+ * Copyright 2014 Erich E. Hoover
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#ifdef HAVE_SYS_XATTR_H
+# include <sys/xattr.h>
+#endif
+#ifdef HAVE_ATTR_XATTR_H
+# include <attr/xattr.h>
+#endif
+#ifdef HAVE_SYS_EXTATTR_H
+# include <sys/extattr.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+
+static inline int xattr_valid_namespace( const char *name )
+{
+    if (strncmp( XATTR_USER_PREFIX, name, XATTR_USER_PREFIX_LEN ) != 0)
+    {
+        errno = EPERM;
+        return 0;
+    }
+    return 1;
+}
+
+int xattr_fget( int filedes, const char *name, void *value, size_t size )
+{
+    if (!xattr_valid_namespace( name )) return -1;
+#if defined(HAVE_ATTR_XATTR_H)
+    return fgetxattr( filedes, name, value, size );
+#elif defined(HAVE_SYS_XATTR_H)
+    return fgetxattr( filedes, name, value, size, 0, 0 );
+#elif defined(HAVE_SYS_EXTATTR_H)
+    return extattr_get_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                           value, size );
+#else
+    errno = ENOTSUP;
+    return -1;
+#endif
+}
-- 
1.7.9.5

