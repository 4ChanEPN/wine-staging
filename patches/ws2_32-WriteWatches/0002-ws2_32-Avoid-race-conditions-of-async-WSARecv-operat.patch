From cab68a82435dfc0cd55f65dca6febae250681f14 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Fri, 21 Nov 2014 12:22:46 +0100
Subject: ws2_32: Avoid race-conditions of async WSARecv() operations with
 write watches. (try 2)

Under specific circumstances Silverlight resets the write watch while the async
WSARecv() operation is still pending:

23723.867:003a:Call ws2_32.WSARecv(00000400,018eac80,00000001,0815df24,0815df28,0196132c,00000000) ret=7a3a8197
[...]
23723.868:003a:Call KERNEL32.IsBadWritePtr(028f3368,00015554) ret=205465c4
23723.868:003a:Ret  KERNEL32.IsBadWritePtr() retval=00000000 ret=205465c4
[...]
23723.868:003a:Ret  ws2_32.WSARecv() retval=ffffffff ret=7a3a8197
23723.868:003a:Call KERNEL32.GetLastError() ret=792be2fd
23723.868:003a:Ret  KERNEL32.GetLastError() retval=00000102 ret=79259875
[...]
23723.874:003d:Call KERNEL32.ResetWriteWatch(028d1000,0009ce00) ret=792ca021
23723.875:003d:Ret  KERNEL32.ResetWriteWatch() retval=00000000 ret=792ca021
[...]
23723.966:003a:Call ntdll.wine_server_handle_to_fd(00000400,00000001,0815de9c,00000000) ret=2053ec7c
23723.966:003a:Ret  ntdll.wine_server_handle_to_fd() retval=00000000 ret=2053ec7c
23723.966:003a:Call ntdll.wine_server_release_fd(00000400,00000081) ret=2053eca4
23723.966:003a:Ret  ntdll.wine_server_release_fd() retval=00000000 ret=2053eca4
23723.966:003a:warn:winsock:wsaErrStatus errno 14, (Bad address).

This seems to work fine on Windows, most likely because the kernel handles write
watches directly, without involving usermode. To workaround this issue we repeat
recvmsg(...) when it looks like it might have failed because of write watches.

Based on the Linux kernel code it seems to be save to assume, that on EFAULT
no actually important data was lost:
http://lxr.free-electrons.com/source/net/ipv4/tcp.c#L1940

Based on the code it looks like we could savely remove the write-watch check
at the beginning of WS2_recv_base, which might make the application think
that data is immediately available.
---
 dlls/ntdll/ntdll.spec    |  3 +++
 dlls/ntdll/virtual.c     | 45 +++++++++++++++++++++++++++++++++++++++++++++
 dlls/ws2_32/socket.c     |  4 +++-
 dlls/ws2_32/tests/sock.c | 11 +++--------
 4 files changed, 54 insertions(+), 9 deletions(-)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 68d7f22b192..b4acd5e6feb 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1491,6 +1491,9 @@
 # signal handling
 @ cdecl __wine_set_signal_handler(long ptr)
 
+# Virtal memory management
+@ cdecl wine_virtual_locked_recvmsg(long ptr long)
+
 # Filesystem
 @ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
 @ cdecl wine_unix_to_nt_file_name(ptr ptr)
diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 2cdcca8a599..7e22a8a9bcf 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -41,6 +41,9 @@
 #ifdef HAVE_SYS_SYSINFO_H
 # include <sys/sysinfo.h>
 #endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
 #ifdef HAVE_VALGRIND_VALGRIND_H
 # include <valgrind/valgrind.h>
 #endif
@@ -1913,6 +1916,48 @@ ssize_t virtual_locked_pread( int fd, void *addr, size_t size, off_t offset )
 }
 
 
+/***********************************************************************
+ *           virtual_locked_recvmsg
+ */
+ssize_t CDECL wine_virtual_locked_recvmsg( int sockfd, struct msghdr *msg, int flags )
+{
+    sigset_t sigset;
+    BOOL has_write_watch = FALSE;
+    int err = EFAULT;
+    int i;
+
+    ssize_t size, ret = recvmsg( sockfd, msg, flags );
+    if (ret != -1 || errno != EFAULT) return ret;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    for (i = 0; i < msg->msg_iovlen; i++)
+    {
+        struct iovec *iov = &msg->msg_iov[i];
+        if (check_write_access( iov->iov_base, iov->iov_len, &has_write_watch ))
+        {
+            while (i--) update_write_watches( msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len, 0 );
+            goto done;
+        }
+    }
+
+    size = ret = recvmsg( sockfd, msg, flags );
+    err = errno;
+
+    if (!has_write_watch) goto done;
+    for (i = 0; i < msg->msg_iovlen; i++)
+    {
+        struct iovec *iov = &msg->msg_iov[i];
+        update_write_watches( iov->iov_base, iov->iov_len, min( max( 0, size ), iov->iov_len ));
+        size -= iov->iov_len;
+    }
+
+done:
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    errno = err;
+    return ret;
+}
+
 
 /***********************************************************************
  *           virtual_is_valid_code_address
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 681f340bc6d..e97b8ebfe69 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -263,6 +263,8 @@ static int WS2_recv_base( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                           LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
                           LPWSABUF lpControlBuffer );
 
+extern ssize_t CDECL wine_virtual_locked_recvmsg( int sockfd, struct msghdr *msg, int flags );
+
 /* critical section to protect some non-reentrant net function */
 static CRITICAL_SECTION csWSgetXXXbyYYY;
 static CRITICAL_SECTION_DEBUG critsect_debug =
@@ -2356,7 +2358,7 @@ static int WS2_recv( int fd, struct ws2_async *wsa, int flags )
     hdr.msg_flags = 0;
 #endif
 
-    while ((n = recvmsg(fd, &hdr, flags)) == -1)
+    while ((n = wine_virtual_locked_recvmsg(fd, &hdr, flags)) == -1)
     {
         if (errno != EINTR)
             return -1;
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 7b0cc322dad..12b90e979f9 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -6963,18 +6963,15 @@ static void test_write_watch(void)
     send(src, "test message", sizeof("test message"), 0);
 
     ret = GetOverlappedResult( (HANDLE)dest, &ov, &bytesReturned, TRUE );
-    todo_wine
-    {
     ok( ret, "GetOverlappedResult failed %u\n", GetLastError() );
     ok( bytesReturned == sizeof("test message"), "wrong size %u\n", bytesReturned );
     ok( !memcmp( base, "test ", 5 ), "wrong data %s\n", base );
     ok( !memcmp( base + 0x4000, "message", 8 ), "wrong data %s\n", base + 0x4000 );
-    }
 
     count = 64;
     ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
     ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
-    ok( count == 0, "wrong count %lu\n", count );
+    todo_wine ok( count == 0, "wrong count %lu\n", count );
 
     memset( base, 0, size );
     count = 64;
@@ -6985,7 +6982,6 @@ static void test_write_watch(void)
     bufs[1].len = 0x4000;
     bufs[1].buf = base + 0x2000;
     ret = WSARecvFrom( dest, bufs, 2, NULL, &flags, &addr, &addr_len, &ov, NULL);
-    todo_wine
     ok(ret == SOCKET_ERROR && GetLastError() == ERROR_IO_PENDING,
        "WSARecv failed - %d error %d\n", ret, GetLastError());
 
@@ -6993,7 +6989,6 @@ static void test_write_watch(void)
     ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
     ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
     ok( count == 5, "wrong count %lu\n", count );
-    todo_wine
     ok( !base[0], "data set\n" );
 
     send(src, "test message", sizeof("test message"), 0);
@@ -7007,7 +7002,7 @@ static void test_write_watch(void)
     count = 64;
     ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
     ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
-    ok( count == 0, "wrong count %lu\n", count );
+    todo_wine ok( count == 0, "wrong count %lu\n", count );
 
     memset( base, 0, size );
     count = 64;
@@ -7036,7 +7031,7 @@ static void test_write_watch(void)
         count = 64;
         ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
         ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
-        ok( count == 0, "wrong count %lu\n", count );
+        todo_wine ok( count == 0, "wrong count %lu\n", count );
     }
     WSACloseEvent( event );
     closesocket( dest );
-- 
2.14.1

