From 6a0ddd70ba0d958f5e0191c4ae5b74f3507a7aaf Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 10 Feb 2015 06:36:52 +0100
Subject: ntdll: Avoid race-conditions with write watches in NtReadFile.

Rebased against kernel32-NamedPipe patchset by Sebastian Lackner <sebastian@fds-team.de>.
---
 dlls/kernel32/tests/virtual.c | 16 ++--------------
 dlls/ntdll/file.c             | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/dlls/kernel32/tests/virtual.c b/dlls/kernel32/tests/virtual.c
index 1d611cdacff..2ecd5611924 100644
--- a/dlls/kernel32/tests/virtual.c
+++ b/dlls/kernel32/tests/virtual.c
@@ -1840,13 +1840,10 @@ static DWORD CALLBACK read_pipe( void *arg )
         "%u: ConnectNamedPipe failed %u\n", args->index, GetLastError() );
 
     success = ReadFile( args->pipe, args->base, args->size, &num_bytes, NULL );
-    todo_wine
-    {
     ok( success, "%u: ReadFile failed %u\n", args->index, GetLastError() );
     ok( num_bytes == sizeof(testdata), "%u: wrong number of bytes read %u\n", args->index, num_bytes );
     ok( !memcmp( args->base, testdata, sizeof(testdata)),
         "%u: didn't receive expected data\n", args->index );
-    }
     return 0;
 }
 
@@ -2056,22 +2053,16 @@ static void test_write_watch(void)
 
         num_bytes = 0;
         success = GetOverlappedResult( readpipe, &overlapped, &num_bytes, TRUE );
-        todo_wine
-        {
         ok( success, "%u: GetOverlappedResult failed %u\n", i, GetLastError() );
         ok( num_bytes == sizeof(testdata), "%u: wrong number of bytes read %u\n", i, num_bytes );
         ok( !memcmp( base, testdata, sizeof(testdata)), "%u: didn't receive expected data\n", i );
-        }
 
         count = 64;
         memset( results, 0, sizeof(results) );
         ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
         ok( !ret, "%u: GetWriteWatch failed %u\n", i, GetLastError() );
-        todo_wine
-        {
-        ok( count == 1, "%u: wrong count %lu\n", i, count );
+        todo_wine ok( count == 1, "%u: wrong count %lu\n", i, count );
         ok( results[0] == base, "%u: wrong result %p\n", i, results[0] );
-        }
 
         CloseHandle( readpipe );
         CloseHandle( writepipe );
@@ -2121,11 +2112,8 @@ static void test_write_watch(void)
         memset( results, 0, sizeof(results) );
         ret = pGetWriteWatch( WRITE_WATCH_FLAG_RESET, base, size, results, &count, &pagesize );
         ok( !ret, "%u: GetWriteWatch failed %u\n", i, GetLastError() );
-        todo_wine
-        {
-        ok( count == 1, "%u: wrong count %lu\n", i, count );
+        todo_wine ok( count == 1, "%u: wrong count %lu\n", i, count );
         ok( results[0] == base, "%u: wrong result %p\n", i, results[0] );
-        }
 
         CloseHandle( readpipe );
         CloseHandle( writepipe );
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 0381e558ff6..a4da492573c 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -524,6 +524,10 @@ static NTSTATUS FILE_AsyncReadService( void *user, IO_STATUS_BLOCK *iosb, NTSTAT
         {
             if (errno == EAGAIN || errno == EINTR)
                 status = STATUS_PENDING;
+            else if (errno == EFAULT)
+                status = (wine_uninterrupted_write_memory( &fileio->buffer[fileio->already], NULL,
+                          fileio->count - fileio->already ) == STATUS_SUCCESS) ?
+                         STATUS_PENDING : STATUS_ACCESS_VIOLATION;
             else /* check to see if the transfer is complete */
                 status = FILE_GetNtStatus();
         }
@@ -871,6 +875,13 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             /* async I/O doesn't make sense on regular files */
             while ((result = pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
             {
+                if (errno == EFAULT)
+                {
+                    if (virtual_check_buffer_for_write( buffer, length ) >= length)
+                        continue;
+                    else
+                        errno = EFAULT;
+                }
                 if (errno != EINTR)
                 {
                     status = FILE_GetNtStatus();
@@ -945,6 +956,13 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
         else if (errno != EAGAIN)
         {
             if (errno == EINTR) continue;
+            if (errno == EFAULT)
+            {
+                if (wine_uninterrupted_write_memory( (char *)buffer + total, NULL, length - total ) == STATUS_SUCCESS)
+                    continue;
+                else
+                    errno = EFAULT;
+            }
             if (!total) status = FILE_GetNtStatus();
             goto done;
         }
-- 
2.14.1

