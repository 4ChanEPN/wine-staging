From 1703d568d9756fbf3d6a11889386ff9355f33755 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 24 Dec 2015 13:08:50 +0100
Subject: server: Implement wineserver call for SystemHandleInformation. (v2)

Signed-off-by: Sebastian Lackner <sebastian@fds-team.de>
---
 dlls/ntdll/nt.c         | 49 ++++++++++++++++++++++++++++++++++++-------
 dlls/ntdll/tests/info.c | 10 ++++-----
 server/handle.c         | 56 +++++++++++++++++++++++++++++++++++++++++++++++++
 server/protocol.def     | 16 ++++++++++++++
 server/trace.c          | 17 +++++++++++++++
 5 files changed, 135 insertions(+), 13 deletions(-)

diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
index 8ea1ddd..55255a8 100644
--- a/dlls/ntdll/nt.c
+++ b/dlls/ntdll/nt.c
@@ -2004,18 +2004,51 @@ NTSTATUS WINAPI NtQuerySystemInformation(
         break;
     case SystemHandleInformation:
         {
-            SYSTEM_HANDLE_INFORMATION shi;
+            struct handle_info *info;
+            DWORD i, num_handles;
 
-            memset(&shi, 0, sizeof(shi));
-            len = sizeof(shi);
+            if (Length < sizeof(SYSTEM_HANDLE_INFORMATION))
+            {
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+                break;
+            }
 
-            if ( Length >= len)
+            if (!SystemInformation)
             {
-                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
-                else memcpy( SystemInformation, &shi, len);
+                ret = STATUS_ACCESS_VIOLATION;
+                break;
             }
-            else ret = STATUS_INFO_LENGTH_MISMATCH;
-            FIXME("info_class SYSTEM_HANDLE_INFORMATION\n");
+
+            num_handles = (Length - FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle )) / sizeof(SYSTEM_HANDLE_ENTRY);
+            if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*info) * num_handles )))
+                return STATUS_NO_MEMORY;
+
+            SERVER_START_REQ( get_system_handles )
+            {
+                wine_server_set_reply( req, info, sizeof(*info) * num_handles );
+                if (!(ret = wine_server_call( req )))
+                {
+                    SYSTEM_HANDLE_INFORMATION *shi = SystemInformation;
+                    shi->Count = wine_server_reply_size( req ) / sizeof(*info);
+                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[shi->Count] );
+                    for (i = 0; i < shi->Count; i++)
+                    {
+                        memset( &shi->Handle[i], 0, sizeof(shi->Handle[i]) );
+                        shi->Handle[i].OwnerPid     = info[i].owner;
+                        shi->Handle[i].HandleValue  = info[i].handle;
+                        shi->Handle[i].AccessMask   = info[i].access;
+                        /* FIXME: Fill out ObjectType, HandleFlags, ObjectPointer */
+                    }
+                }
+                else if (ret == STATUS_BUFFER_TOO_SMALL)
+                {
+                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[reply->count] );
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+                }
+            }
+            SERVER_END_REQ;
+
+            RtlFreeHeap( GetProcessHeap(), 0, info );
         }
         break;
     case SystemCacheInformation:
diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
index 3219dbb..da509aa 100644
--- a/dlls/ntdll/tests/info.c
+++ b/dlls/ntdll/tests/info.c
@@ -487,7 +487,7 @@ static void test_query_handle(void)
     /* Request the needed length : a SystemInformationLength greater than one struct sets ReturnLength */
     ReturnLength = 0xdeadbeef;
     status = pNtQuerySystemInformation(SystemHandleInformation, shi, SystemInformationLength, &ReturnLength);
-    todo_wine ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
+    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
     ok( ReturnLength != 0xdeadbeef, "Expected valid ReturnLength\n" );
 
     SystemInformationLength = ReturnLength;
@@ -503,13 +503,13 @@ static void test_query_handle(void)
     }
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status );
     ExpectedLength = FIELD_OFFSET(SYSTEM_HANDLE_INFORMATION, Handle[shi->Count]);
-    todo_wine ok( ReturnLength == ExpectedLength || broken(ReturnLength == ExpectedLength - sizeof(DWORD)), /* Vista / 2008 */
-                  "Expected length %u, got %u\n", ExpectedLength, ReturnLength );
-    todo_wine ok( shi->Count > 1, "Expected more than 1 handle, got %u\n", shi->Count );
+    ok( ReturnLength == ExpectedLength || broken(ReturnLength == ExpectedLength - sizeof(DWORD)), /* Vista / 2008 */
+        "Expected length %u, got %u\n", ExpectedLength, ReturnLength );
+    ok( shi->Count > 1, "Expected more than 1 handle, got %u\n", shi->Count );
     for (i = 0, found = FALSE; i < shi->Count && !found; i++)
         found = (shi->Handle[i].OwnerPid == GetCurrentProcessId()) &&
                 ((HANDLE)(ULONG_PTR)shi->Handle[i].HandleValue == EventHandle);
-    todo_wine ok( found, "Expected to find event handle in handle list\n" );
+    ok( found, "Expected to find event handle in handle list\n" );
 
     CloseHandle(EventHandle);
 
diff --git a/server/handle.c b/server/handle.c
index 5043ff7..05d71ba 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -745,3 +745,59 @@ DECL_HANDLER(get_security_object)
 
     release_object( obj );
 }
+
+struct enum_handle_info
+{
+    unsigned int count;
+    struct handle_info *handle;
+};
+
+static int enum_handles( struct process *process, void *user )
+{
+    struct enum_handle_info *info = user;
+    struct handle_table *table = process->handles;
+    struct handle_entry *entry;
+    struct handle_info *handle;
+    unsigned int i;
+
+    if (!table)
+        return 0;
+
+    for (i = 0, entry = table->entries; i <= table->last; i++, entry++)
+    {
+        if (!entry->ptr) continue;
+        if (!info->handle)
+        {
+            info->count++;
+            continue;
+        }
+        assert( info->count );
+        handle = info->handle++;
+        handle->owner  = process->id;
+        handle->handle = index_to_handle(i);
+        handle->access = entry->access & ~RESERVED_ALL;
+        info->count--;
+    }
+
+    return 0;
+}
+
+DECL_HANDLER(get_system_handles)
+{
+    struct enum_handle_info info;
+    struct handle_info *handle;
+    data_size_t max_handles = get_reply_max_size() / sizeof(*handle);
+
+    info.handle = NULL;
+    info.count  = 0;
+    enum_processes( enum_handles, &info );
+    reply->count = info.count;
+
+    if (max_handles < info.count)
+        set_error( STATUS_BUFFER_TOO_SMALL );
+    else if ((handle = set_reply_data_size( info.count * sizeof(*handle) )))
+    {
+        info.handle = handle;
+        enum_processes( enum_handles, &info );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index bfb9089..ea5bd61 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3266,6 +3266,22 @@ enum coords_relative
     VARARG(sd,security_descriptor); /* retrieved security descriptor */
 @END
 
+
+struct handle_info
+{
+    process_id_t owner;
+    obj_handle_t handle;
+    unsigned int access;
+};
+
+/* Return a list of all opened handles */
+@REQ(get_system_handles)
+@REPLY
+    unsigned int    count;        /* number of handles */
+    VARARG(data,handle_infos);    /* array of handle_infos */
+@END
+
+
 /* Create a mailslot */
 @REQ(create_mailslot)
     unsigned int   access;        /* wanted access rights */
diff --git a/server/trace.c b/server/trace.c
index 405a1c9..8a26fdb 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1142,6 +1142,23 @@ static void dump_varargs_rawinput_devices(const char *prefix, data_size_t size )
     fputc( '}', stderr );
 }
 
+static void dump_varargs_handle_infos( const char *prefix, data_size_t size )
+{
+    const struct handle_info *handle;
+
+    fprintf( stderr, "%s{", prefix );
+    while (size >= sizeof(*handle))
+    {
+        handle = cur_data;
+        fprintf( stderr, "{owner=%04x,handle=%04x,access=%08x}",
+                 handle->owner, handle->handle, handle->access );
+        size -= sizeof(*handle);
+        remove_data( sizeof(*handle) );
+        if (size) fputc( ',', stderr );
+    }
+    fputc( '}', stderr );
+}
+
 typedef void (*dump_func)( const void *req );
 
 /* Everything below this line is generated automatically by tools/make_requests */
-- 
2.6.4

