From e5cdbbf9fdf7c927f66bc4c3f7be4bcca0694791 Mon Sep 17 00:00:00 2001
From: Damjan Jovanovic <damjan.jov@gmail.com>
Date: Fri, 8 Aug 2014 20:05:54 +0200
Subject: winex11.drv: Import X11's "text/html" as "HTML Format". (try 3)

Implements proper importing of "text/html" into Windows's "HTML
Format" which fixes pasting rich text into a large number of apps and
closes #7372.

Changes by Sebastian Lackner <sebastian@fds-team.de>:
* Fix incorrect detection of startOfMarkup
* Some small formatting fixes
---
 dlls/winex11.drv/clipboard.c | 202 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 201 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index 0850448..08dd885 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -134,6 +134,7 @@ static HANDLE import_image_bmp( Atom type, const void *data, size_t size );
 static HANDLE import_string( Atom type, const void *data, size_t size );
 static HANDLE import_utf8_string( Atom type, const void *data, size_t size );
 static HANDLE import_compound_text( Atom type, const void *data, size_t size );
+static HANDLE import_text_html( Atom type, const void *data, size_t size );
 static HANDLE import_text_uri_list( Atom type, const void *data, size_t size );
 static HANDLE import_targets( Atom type, const void *data, size_t size );
 
@@ -206,7 +207,7 @@ static const struct
     { JFIFW, 0,              XATOM_image_jpeg,          import_data,          export_data },
     { PNGW, 0,               XATOM_image_png,           import_data,          export_data },
     { HTMLFormatW, 0,        XATOM_HTML_Format,         import_data,          export_data },
-    { HTMLFormatW, 0,        XATOM_text_html,           import_data,          export_text_html },
+    { HTMLFormatW, 0,        XATOM_text_html,           import_text_html,     export_text_html },
     { 0, 0,                  XATOM_TARGETS,             import_targets,       export_targets },
     { 0, 0,                  XATOM_MULTIPLE,            NULL,                 export_multiple },
 };
@@ -1178,6 +1179,205 @@ static HANDLE import_enhmetafile( Atom type, const void *data, size_t size )
 }
 
 
+static char* read_and_standardize_text_html( const void *data, size_t size )
+{
+    BOOL needHtmlTag = FALSE, needBodyTag = FALSE;
+    char *dst, *fullHtml, *textHtmlUtf8 = NULL;
+    unsigned long textHtmlLen;
+    const char *textHtml;
+    int startOfMarkup = 0;
+
+    textHtml = data;
+    textHtmlLen = size;
+
+    /* Firefox uses UTF-16LE with byte order mark. Convert to UTF-8 without the BOM. */
+    if (textHtmlLen >= 2 && ((BYTE*)textHtml)[0] == 0xff && ((BYTE*)textHtml)[1] == 0xfe)
+    {
+        INT size = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)&textHtml[2], (textHtmlLen-2)/sizeof(WCHAR),
+                                       NULL, 0, NULL, NULL);
+        textHtmlUtf8 = HeapAlloc(GetProcessHeap(), 0, size);
+        if (!textHtmlUtf8)
+        {
+            ERR("out of memory\n");
+            goto end;
+        }
+
+        WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)&textHtml[2], (textHtmlLen-2)/sizeof(WCHAR),
+                            textHtmlUtf8, size, NULL, NULL);
+
+        textHtml = textHtmlUtf8;
+        textHtmlLen = size;
+    }
+
+    /* Strip trailing null characters. */
+    while (textHtmlLen > 0 && textHtml[textHtmlLen-1] == '\0')
+        textHtmlLen--;
+
+    /* While HTML fragments are supposed to be valid in Windows, some apps only want
+     * to paste a complete HTML document. So if we got an HTML fragment, complete it. */
+    if (textHtmlLen >= 7 && strncasecmp(&textHtml[textHtmlLen - 7], "</HTML>", 7))
+    {
+        int i;
+        needHtmlTag = TRUE;
+        needBodyTag = TRUE;
+        for (i = textHtmlLen - 7; i > 0; i--)
+        {
+            if (!strncasecmp(&textHtml[i], "</BODY>", 7))
+            {
+                needBodyTag = FALSE;
+                break;
+            }
+        }
+
+        for (startOfMarkup = 0; startOfMarkup < textHtmlLen; startOfMarkup++)
+        {
+            if (isspace(textHtml[startOfMarkup]))
+                continue;
+            else if (textHtml[startOfMarkup] != '<')
+                break;
+            else if (startOfMarkup + 1 < textHtmlLen && (textHtml[startOfMarkup + 1] == '!' ||
+                                                         textHtml[startOfMarkup + 1] == '/'))
+            {
+                char *pos = memchr(&textHtml[startOfMarkup + 1], '>', textHtmlLen - startOfMarkup - 1);
+                if (!pos) break;
+                startOfMarkup = pos - textHtml;
+                continue;
+            }
+            else
+                break;
+        }
+        if (startOfMarkup >= textHtmlLen) startOfMarkup = 0;
+    }
+
+    fullHtml = HeapAlloc(GetProcessHeap(), 0, textHtmlLen + (needBodyTag ? (6 + 7) : 0) +
+                                                            (needHtmlTag ? (6 + 7) : 0) + 1);
+    if (fullHtml)
+    {
+        dst = fullHtml;
+        memcpy(dst, textHtml, startOfMarkup);
+        dst += startOfMarkup;
+        if (needHtmlTag)
+        {
+            memcpy(dst, "<HTML>", 6);
+            dst += 6;
+        }
+        if (needBodyTag)
+        {
+            memcpy(dst, "<BODY>", 6);
+            dst += 6;
+        }
+        memcpy(dst, &textHtml[startOfMarkup], textHtmlLen - startOfMarkup);
+        dst += textHtmlLen - startOfMarkup;
+        if (needBodyTag)
+        {
+            memcpy(dst, "</BODY>", 7);
+            dst += 7;
+        }
+        if (needHtmlTag)
+        {
+            memcpy(dst, "</HTML>", 7);
+            dst += 7;
+        }
+        *dst = '\0';
+    }
+    else
+        ERR("out of memory\n");
+
+end:
+    HeapFree(GetProcessHeap(), 0, textHtmlUtf8);
+    return fullHtml;
+}
+
+
+/**************************************************************************
+ *      import_text_html
+ *
+ *  Import text/html into "HTML Format".
+ */
+static HANDLE import_text_html( Atom type, const void *data, size_t size )
+{
+    static const char startFragment[] = "<!--StartFragment -->";
+    static const char endFragment[]   = "<!--EndFragment -->";
+    int i, bodyStart = -1, bodyEnd = -1;
+    HGLOBAL hClipData = NULL;
+    char *textHtml = NULL;
+    char description[256];
+
+    textHtml = read_and_standardize_text_html(data, size);
+    if (textHtml == NULL)
+        goto end;
+
+    /* find <BODY> tag */
+    for (i = 0; textHtml[i]; i++)
+    {
+        if (strncasecmp(&textHtml[i], "<BODY>", 6) == 0)
+        {
+            bodyStart = i + 6;
+            break;
+        }
+    }
+    if (bodyStart < 0)
+    {
+        ERR("HTML doesn't have <BODY>\n");
+        goto end;
+    }
+
+    /* find </BODY> tag */
+    for (i = strlen(textHtml) - 7; i >= bodyStart; i--)
+    {
+        if (strncasecmp(&textHtml[i], "</BODY>", 7) == 0)
+        {
+            bodyEnd = i;
+            break;
+        }
+    }
+    if (bodyEnd < 0)
+    {
+        ERR("HTML doesn't have </BODY>\n");
+        goto end;
+    }
+
+    snprintf(description, sizeof(description),
+            "Version:0.9\n"         /* 12 */
+            "StartHTML:%010u\n"     /* 21 */
+            "EndHTML:%010u\n"       /* 19 */
+            "StartFragment:%010u\n" /* 25 */
+            "EndFragment:%010u\n",  /* 23 */
+            100,
+            100 + (UINT)(strlen(textHtml) + strlen(startFragment) + strlen(endFragment)),
+            100 + (UINT)(bodyStart + strlen(startFragment)),
+            100 + (UINT)(strlen(startFragment) + bodyEnd));
+
+    hClipData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, strlen(description) +
+                            strlen(textHtml) + strlen(startFragment) + strlen(endFragment) + 1);
+    if (hClipData)
+    {
+        char *dst, *htmlFormat;
+        dst = htmlFormat = GlobalLock(hClipData);
+        strcpy(dst, description);
+        dst += strlen(description);
+        memcpy(dst, textHtml, bodyStart);
+        dst += bodyStart;
+        memcpy(dst, startFragment, strlen(startFragment));
+        dst += strlen(startFragment);
+        memcpy(dst, &textHtml[bodyStart], bodyEnd - bodyStart);
+        dst += (bodyEnd - bodyStart);
+        memcpy(dst, endFragment, strlen(endFragment));
+        dst += strlen(endFragment);
+        memcpy(dst, &textHtml[bodyEnd], strlen(textHtml) - bodyEnd);
+        dst += (strlen(textHtml) - bodyEnd);
+        *dst = 0;
+        GlobalUnlock(hClipData);
+    }
+    else
+        ERR("out of memory\n");
+
+end:
+    HeapFree(GetProcessHeap(), 0, textHtml);
+    return hClipData;
+}
+
+
 /**************************************************************************
  *      import_text_uri_list
  *
-- 
2.9.0

