From 4def7948832423c68173fea8d3cc755fcbd274cf Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 30 Jul 2014 21:52:38 +0200
Subject: kernel32/tests: Add tests for partially received pipe messages
 (ERROR_MORE_DATA).

---
 dlls/kernel32/tests/pipe.c |  101 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 101 insertions(+)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index c19456e..3357061 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -127,6 +127,21 @@ static void test_CreateNamedPipe(int pipemode)
         /* Make sure we can read and write a few bytes in both directions */
         memset(ibuf, 0, sizeof(ibuf));
         ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf), "read got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, written) == 0, "content check\n");
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf2), "write file len\n");
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf2), "read got %d bytes\n", readden);
+        ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
+
+        /* Now the same again, but with an additional call to PeekNamedPipe */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
         ok(written == sizeof(obuf), "write file len 1\n");
         ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
         ok(readden == sizeof(obuf), "peek 1 got %d bytes\n", readden);
@@ -145,6 +160,65 @@ static void test_CreateNamedPipe(int pipemode)
         ok(readden == sizeof(obuf2), "read 2 got %d bytes\n", readden);
         ok(memcmp(obuf2, ibuf, written) == 0, "content 2 check\n");
 
+        /* Test how ReadFile behaves when the buffer is not big enough for the whole message */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(ReadFile(hFile, ibuf, 4, &readden, NULL), "ReadFile\n");
+        ok(readden == 4, "read got %d bytes\n", readden);
+        ok(ReadFile(hFile, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf)-4, "read got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, written) == 0, "content check\n");
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf2), "write file len\n");
+        if (pipemode == PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
+        }
+        else
+        {
+            SetLastError(0xdeadbeef);
+            todo_wine
+            ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+        }
+        ok(readden == 4, "read got %d bytes\n", readden);
+        ok(ReadFile(hnp, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf2)-4, "read got %d bytes\n", readden);
+        ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
+
+        /* Similar to above, but use a read buffer size small enough to read in three parts */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf2), "write file len\n");
+        if (pipemode == PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
+            ok(readden == 4, "read got %d bytes\n", readden);
+            ok(ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile\n");
+        }
+        else
+        {
+            SetLastError(0xdeadbeef);
+            todo_wine
+            ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+            ok(readden == 4, "read got %d bytes\n", readden);
+            SetLastError(0xdeadbeef);
+            todo_wine
+            ok(!ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+        }
+        ok(readden == 4, "read got %d bytes\n", readden);
+        ok(ReadFile(hnp, ibuf + 8, sizeof(ibuf) - 8, &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf2)-8, "read got %d bytes\n", readden);
+        ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
+
         /* Test reading of multiple writes */
         memset(ibuf, 0, sizeof(ibuf));
         ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile3a\n");
@@ -222,6 +296,33 @@ static void test_CreateNamedPipe(int pipemode)
                 ok(SetNamedPipeHandleState(hFile, &lpmode, NULL, NULL), "Change mode\n");
             }
         
+            /* Test how ReadFile behaves when the buffer is not big enough for the whole message */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf), "write file len\n");
+            SetLastError(0xdeadbeef);
+            todo_wine
+            ok(!ReadFile(hFile, ibuf, 4, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+            ok(readden == 4, "read got %d bytes\n", readden);
+            ok(ReadFile(hFile, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf)-4, "read got %d bytes\n", readden);
+            ok(memcmp(obuf, ibuf, written) == 0, "content check\n");
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf2), "write file len\n");
+            SetLastError(0xdeadbeef);
+            todo_wine
+            ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+            ok(readden == 4, "read got %d bytes\n", readden);
+            ok(ReadFile(hnp, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf2)-4, "read got %d bytes\n", readden);
+            ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
+
             memset(ibuf, 0, sizeof(ibuf));
             ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile5a\n");
             ok(written == sizeof(obuf), "write file len 3a\n");
-- 
1.7.9.5

