From a621406ad321dc6871fbaf7c43d70fa6da9df07a Mon Sep 17 00:00:00 2001
From: Adam Martinson <adam.r.martinson@gmail.com>
Date: Tue, 12 Aug 2014 21:29:47 +0200
Subject: ntdll: Implement FILE_PIPE_INFORMATION for NtQueryInformationFile.

This is a subset of my current work-in-progress named pipe message mode
patches, see: http://bugs.winehq.org/show_bug.cgi?id=17195#c157

Please note that none of the patches in this series focuses on a specific
implementation of message mode pipes yet - whatever finally is used, we
always need the redirection kernel32 -> ntdll -> wineserver.

This first patch (by Adam Martinson) implements FILE_PIPE_INFORMATION
based on the existing get_named_pipe_info wineserver call.
---
 dlls/ntdll/file.c  |   22 ++++++++++++++++++++--
 include/winternl.h |   11 +++++++++++
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index d2efcc1..2ae8bee 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -1981,7 +1981,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
         sizeof(FILE_END_OF_FILE_INFORMATION),          /* FileEndOfFileInformation */
         0,                                             /* FileAlternateNameInformation */
         sizeof(FILE_STREAM_INFORMATION)-sizeof(WCHAR), /* FileStreamInformation */
-        0,                                             /* FilePipeInformation */
+        sizeof(FILE_PIPE_INFORMATION),                 /* FilePipeInformation */
         sizeof(FILE_PIPE_LOCAL_INFORMATION),           /* FilePipeLocalInformation */
         0,                                             /* FilePipeRemoteInformation */
         sizeof(FILE_MAILSLOT_QUERY_INFORMATION),       /* FileMailslotQueryInformation */
@@ -2032,7 +2032,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
     if (len < info_sizes[class])
         return io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
 
-    if (class != FilePipeLocalInformation)
+    if (class != FilePipeInformation && class != FilePipeLocalInformation)
     {
         if ((io->u.Status = server_get_unix_fd( hFile, 0, &fd, &needs_close, NULL, NULL )))
             return io->u.Status;
@@ -2146,6 +2146,24 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
             }
         }
         break;
+    case FilePipeInformation:
+        {
+            FILE_PIPE_INFORMATION* pi = ptr;
+
+            SERVER_START_REQ( get_named_pipe_info )
+            {
+                req->handle = wine_server_obj_handle( hFile );
+                if (!(io->u.Status = wine_server_call( req )))
+                {
+                    pi->ReadMode       = (reply->flags & NAMED_PIPE_MESSAGE_STREAM_READ) ?
+                        FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE;
+                    pi->CompletionMode = (reply->flags & NAMED_PIPE_NONBLOCKING_MODE) ?
+                        FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION;
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
     case FilePipeLocalInformation:
         {
             FILE_PIPE_LOCAL_INFORMATION* pli = ptr;
diff --git a/include/winternl.h b/include/winternl.h
index a95a016..95951e2 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -623,6 +623,11 @@ typedef struct _FILE_MAILSLOT_SET_INFORMATION {
     LARGE_INTEGER ReadTimeout;
 } FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;
 
+typedef struct _FILE_PIPE_INFORMATION {
+    ULONG ReadMode;
+    ULONG CompletionMode;
+} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;
+
 typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
@@ -1602,6 +1607,12 @@ typedef struct _RTL_HANDLE_TABLE
 /* options for pipe's type */
 #define FILE_PIPE_TYPE_MESSAGE          0x00000001
 #define FILE_PIPE_TYPE_BYTE             0x00000000
+/* options for pipe's message mode */
+#define FILE_PIPE_MESSAGE_MODE          0x00000001
+#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
+/* options for pipe's blocking mode */
+#define FILE_PIPE_COMPLETE_OPERATION    0x00000001
+#define FILE_PIPE_QUEUE_OPERATION       0x00000000
 /* and client / server end */
 #define FILE_PIPE_SERVER_END            0x00000001
 #define FILE_PIPE_CLIENT_END            0x00000000
-- 
1.7.9.5

