From 465cfc3f65280c5b71bcec33c53c8374bff02f67 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Mon, 4 Aug 2014 05:23:00 +0200
Subject: server: Store the message read-mode for a pipe in the file
 descriptor and use it for determining read behavior.

Changes in v2:
  * Merged with final version of error code handling.
  * Poll for broken pipe to distinguish between zero-byte messages and errors.
---
 dlls/kernel32/tests/pipe.c |   32 ++++------------------------
 dlls/ntdll/file.c          |   50 ++++++++++++++++++++++++++++++++++++++++++--
 server/named_pipe.c        |    8 +++++++
 3 files changed, 60 insertions(+), 30 deletions(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index b918988..1eef763 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -304,9 +304,7 @@ static void test_CreateNamedPipe(int pipemode)
         else
         {
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
         }
         ok(readden == 4, "read got %d bytes\n", readden);
@@ -327,15 +325,11 @@ static void test_CreateNamedPipe(int pipemode)
         else
         {
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
             ok(readden == 4, "read got %d bytes\n", readden);
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
         }
         ok(readden == 4, "read got %d bytes\n", readden);
@@ -397,9 +391,7 @@ static void test_CreateNamedPipe(int pipemode)
             ok(readden == sizeof(obuf) + sizeof(obuf2), "read 4 got %d bytes\n", readden);
         }
         else {
-            todo_wine {
-                ok(readden == sizeof(obuf), "read 4 got %d bytes\n", readden);
-            }
+            ok(readden == sizeof(obuf), "read 4 got %d bytes\n", readden);
         }
         pbuf = ibuf;
         ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 4a check\n");
@@ -442,10 +434,8 @@ static void test_CreateNamedPipe(int pipemode)
             /* Multiple writes in the reverse direction */
             /* the write of obuf2 from write4 should still be in the buffer */
             ok(PeekNamedPipe(hnp, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek6a\n");
-            todo_wine {
-                ok(readden == sizeof(obuf2), "peek6a got %d bytes\n", readden);
-                ok(avail == sizeof(obuf2), "peek6a got %d bytes available\n", avail);
-            }
+            ok(readden == sizeof(obuf2), "peek6a got %d bytes\n", readden);
+            ok(avail == sizeof(obuf2), "peek6a got %d bytes available\n", avail);
             if (avail > 0) {
                 ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
                 ok(readden == sizeof(obuf2), "read 6a got %d bytes\n", readden);
@@ -463,9 +453,7 @@ static void test_CreateNamedPipe(int pipemode)
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 6a check\n");
             ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
-            todo_wine {
-                ok(readden == sizeof(obuf), "read 6b got %d bytes\n", readden);
-            }
+            ok(readden == sizeof(obuf), "read 6b got %d bytes\n", readden);
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 6a check\n");
             if (readden <= sizeof(obuf))
@@ -489,9 +477,7 @@ static void test_CreateNamedPipe(int pipemode)
             ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile 8\n");
             ok(written == sizeof(obuf), "write file len 8\n");
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile 8\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 8\n");
             ok(readden == 4, "read got %d bytes 8\n", readden);
             ok(ReadFile(hnp, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile 8\n");
@@ -601,16 +587,12 @@ static void test_CreateNamedPipe(int pipemode)
             ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 10\n", readden);
             ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 10\n", leftmsg);
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile 10\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
             ok(readden == 4, "read got %d bytes 10\n", readden);
             SetLastError(0xdeadbeef);
             ret = RpcReadFile(hnp, ibuf + 4, 4, &readden, NULL);
-            todo_wine
             ok(!ret, "RpcReadFile 10\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
             ok(readden == 4, "read got %d bytes 10\n", readden);
             readden = leftmsg = -1;
@@ -623,7 +605,6 @@ static void test_CreateNamedPipe(int pipemode)
             ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 10\n", leftmsg);
             ret = RpcReadFile(hnp, ibuf + 8, sizeof(ibuf), &readden, NULL);
             ok(ret, "RpcReadFile 10\n");
-            todo_wine
             ok(readden == sizeof(obuf2)-8, "read got %d bytes 10\n", readden);
             ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check 10\n");
             if (readden <= sizeof(obuf2)-8) /* blocks forever if second part was already received */
@@ -640,13 +621,10 @@ static void test_CreateNamedPipe(int pipemode)
                 SetLastError(0xdeadbeef);
                 ret = RpcReadFile(hnp, ibuf, 4, &readden, NULL);
                 ok(!ret, "RpcReadFile 10\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
                 ok(readden == 4, "read got %d bytes 10\n", readden);
                 SetLastError(0xdeadbeef);
-                todo_wine
                 ok(!ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile 10\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
                 ok(readden == 4, "read got %d bytes 10\n", readden);
                 readden = leftmsg = -1;
@@ -950,7 +928,6 @@ static void test_CloseNamedPipe(void)
         /* close server end without disconnecting */
         ok(CloseHandle(hnp), "CloseHandle() failed: %08x\n", GetLastError());
 
-        todo_wine
         ok(ReadFile(hFile, ibuf, 0, &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
         ok(readden == 0, "got %d bytes\n", readden);
 
@@ -991,7 +968,6 @@ static void test_CloseNamedPipe(void)
         ok(CloseHandle(hFile), "CloseHandle() failed: %08x\n", GetLastError());
 
         /* you'd think ERROR_MORE_DATA, but no */
-        todo_wine
         ok(ReadFile(hnp, ibuf, 0, &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
         ok(readden == 0, "got %d bytes\n", readden);
 
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 73bc3b6..8bc305c 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -700,7 +700,10 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
         if (result >= 0)
         {
             total += result;
-            if (!result || total == length)
+            /* NOTE: In message mode we stop as soon as we reach a message boundary,
+             * even if the buffer is not full yet. */
+            if (!result || total == length || (message_mode && !(msg.msg_flags & MSG_TRUNC) &&
+                                               (fcntl( unix_handle, F_GETSIG ) & 0x01)))
             {
                 if (total)
                 {
@@ -715,13 +718,52 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
                     goto done;
                 case FD_TYPE_SERIAL:
                     break;
+                case FD_TYPE_PIPE:
+                    {
+                        int avail = 0;
+#ifdef FIONREAD
+                        if (ioctl( unix_handle, FIONREAD, &avail ) != 0)
+                        {
+                            TRACE("FIONREAD failed reason: %s\n",strerror(errno));
+                            status = STATUS_PIPE_BROKEN;
+                            goto done;
+                        }
+#endif
+                        /* NOTE: When more data is available, we don't return STATUS_PIPE_BROKEN yet. */
+                        if (avail)
+                        {
+                            status = STATUS_SUCCESS;
+                            goto done;
+                        }
+
+                        /* NOTE: In message mode we have to differentiate between a message of size zero,
+                         * and a broken pipe - so always call poll() to find out if the pipe is still okay.
+                         * Please note that we cannot find out, if zero-byte messages are still in there. */
+                        if (message_mode)
+                        {
+                            struct pollfd pollfd;
+                            int ret;
+
+                            pollfd.fd = unix_handle;
+                            pollfd.events = POLLIN;
+                            pollfd.revents = 0;
+                            ret = poll( &pollfd, 1, 0 );
+                            if (ret != -1 && (ret != 1 || !(pollfd.revents & (POLLHUP|POLLERR))))
+                            {
+                                status = STATUS_SUCCESS;
+                                goto done;
+                            }
+                        }
+                    }
+                    /* fall-through */
                 default:
                     status = STATUS_PIPE_BROKEN;
                     goto done;
                 }
             }
             else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
-            else if (message_mode) continue;          /* concatenate with next message */
+            /* message mode pipe, but byte read mode -> concatenate with next message. */
+            else if (message_mode && !(fcntl( unix_handle, F_GETSIG ) & 0x01)) continue;
         }
         else if (errno != EAGAIN)
         {
@@ -814,6 +856,10 @@ err:
     if (needs_close) close( unix_handle );
     if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && !async_read))
     {
+        /* NOTE: When total == 0, then Windows doesn't return STATUS_MORE_ENTRIES although it was splitted */
+        if (total && message_mode && (msg.msg_flags & MSG_TRUNC) && (fcntl( unix_handle, F_GETSIG ) & 0x01))
+            status = STATUS_MORE_ENTRIES;
+
         io_status->u.Status = status;
         io_status->Information = total;
         TRACE("= SUCCESS (%u)\n", total);
diff --git a/server/named_pipe.c b/server/named_pipe.c
index b5202cb..aac5565 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -886,6 +886,14 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             if (type != SOCK_SEQPACKET || (setsockopt( fds[0], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1 &&
                                            setsockopt( fds[1], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1))
             {
+
+                if (type == SOCK_SEQPACKET)
+                {
+                    /* server side is by default in message read mode, client in byte read mode. */
+                    fcntl( fds[0], F_SETSIG, (pipe->flags & NAMED_PIPE_MESSAGE_STREAM_READ) ? 0x01 : 0x00 );
+                    fcntl( fds[1], F_SETSIG, 0x00 );
+                }
+
                 client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
                 server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
                 if (client->fd && server->fd)
-- 
1.7.9.5

