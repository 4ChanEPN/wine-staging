From 015674ab420417cab42742af3bc5fef58b6b7174 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Mon, 4 Aug 2014 05:01:11 +0200
Subject: server: Use SOCK_SEQPACKET socket in combination with SO_PEEK_OFF to
 implement message mode on Unix.

Based on ideas by Erich E. Hoover.

Similar to Windows, when a pipe has been created with message mode flags, then all
sending operations always behave in "message mode". Currently the read mode isn't
handled yet, and the default is byte mode, to stay backwards compatible.

Changes in v2:
  * Show FIXME when message is too big and was splitted
  * Simplify logic for FSCTL_PIPE_PEEK

Changes in v3:
  * Avoid changes in later patches, directly store pipe mode in signal attributes.
---
 dlls/kernel32/sync.c       |    2 +-
 dlls/kernel32/tests/pipe.c |    9 ----
 dlls/ntdll/file.c          |  104 +++++++++++++++++++++++++++++++++++++++-----
 server/named_pipe.c        |   77 ++++++++++++++++++++++++++------
 server/sock.c              |    4 +-
 server/sock.h              |   26 +++++++++++
 6 files changed, 185 insertions(+), 37 deletions(-)
 create mode 100644 server/sock.h

diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index 96a36b9..23dc871 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1463,7 +1463,7 @@ BOOL WINAPI PeekNamedPipe( HANDLE hPipe, LPVOID lpvBuffer, DWORD cbBuffer,
         ULONG read_size = io.Information - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
         if (lpcbAvail) *lpcbAvail = buffer->ReadDataAvailable;
         if (lpcbRead) *lpcbRead = read_size;
-        if (lpcbMessage) *lpcbMessage = 0;  /* FIXME */
+        if (lpcbMessage) *lpcbMessage = buffer->MessageLength;
         if (lpvBuffer) memcpy( lpvBuffer, buffer->Data, read_size );
     }
     else SetLastError( RtlNtStatusToDosError(status) );
diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index 69c1586..6e464dc 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -285,7 +285,6 @@ static void test_CreateNamedPipe(int pipemode)
         if (pipemode == PIPE_TYPE_BYTE)
             ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
         else
-            todo_wine
             ok(leftmsg == sizeof(obuf2) - 4, "peek got %d bytes left in message\n", leftmsg);
         ok(ReadFile(hFile, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
         ok(readden == sizeof(obuf2)-4, "read got %d bytes\n", readden);
@@ -509,12 +508,10 @@ static void test_CreateNamedPipe(int pipemode)
             readden = leftmsg = -1;
             ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
             ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 9\n", leftmsg);
             readden = leftmsg = -1;
             ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
             ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 9\n", leftmsg);
             SetLastError(0xdeadbeef);
             todo_wine
@@ -532,12 +529,10 @@ static void test_CreateNamedPipe(int pipemode)
             readden = leftmsg = -1;
             ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
             ok(readden == sizeof(obuf) - 8 + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 9\n", leftmsg);
             readden = leftmsg = -1;
             ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
             ok(readden == sizeof(obuf) - 8 + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 9\n", leftmsg);
             ret = RpcReadFile(hFile, ibuf + 8, sizeof(ibuf), &readden, NULL);
             ok(ret, "RpcReadFile 9\n");
@@ -598,12 +593,10 @@ static void test_CreateNamedPipe(int pipemode)
             readden = leftmsg = -1;
             ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
             ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 10\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 10\n", leftmsg);
             readden = leftmsg = -1;
             ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
             ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 10\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 10\n", leftmsg);
             SetLastError(0xdeadbeef);
             todo_wine
@@ -621,12 +614,10 @@ static void test_CreateNamedPipe(int pipemode)
             readden = leftmsg = -1;
             ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
             ok(readden == sizeof(obuf2) - 8 + sizeof(obuf), "peek got %d bytes total 10\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 10\n", leftmsg);
             readden = leftmsg = -1;
             ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
             ok(readden == sizeof(obuf2) - 8 + sizeof(obuf), "peek got %d bytes total 10\n", readden);
-            todo_wine
             ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 10\n", leftmsg);
             ret = RpcReadFile(hnp, ibuf + 8, sizeof(ibuf), &readden, NULL);
             ok(ret, "RpcReadFile 10\n");
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 6774a5bc..9b16802 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -76,6 +76,10 @@
 # include <valgrind/memcheck.h>
 #endif
 
+#ifndef SO_PEEK_OFF
+#define SO_PEEK_OFF 42
+#endif
+
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
 #include "ntstatus.h"
@@ -594,6 +598,9 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
     enum server_fd_type type;
     ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
     BOOL send_completion = FALSE, async_read, timeout_init_done = FALSE;
+    int message_mode_flags = 0;
+    struct msghdr msg;
+    struct iovec iov;
 
     TRACE("(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
           hFile,hEvent,apc,apc_user,io_status,buffer,length,offset,key);
@@ -648,10 +655,51 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             goto done;
         }
     }
+    else if (type == FD_TYPE_PIPE)
+    {
+        message_mode_flags = fcntl( unix_handle, F_GETSIG );
+        if (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)
+        {
+            msg.msg_name        = NULL;
+            msg.msg_namelen     = 0;
+            msg.msg_iov         = &iov;
+            msg.msg_iovlen      = 1;
+            msg.msg_control     = NULL;
+            msg.msg_controllen  = 0;
+            msg.msg_flags       = 0;
+        }
+    }
 
     for (;;)
     {
-        if ((result = read( unix_handle, (char *)buffer + total, length - total )) >= 0)
+        if (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)
+        {
+            /* for message mode pipes we can't use the regular read command, as this would discard
+             * the rest of the message, which doesn't fit into the buffer. To avoid that use recvmsg()
+             * with MSG_PEEK. */
+            iov.iov_base = (char *)buffer + total;
+            iov.iov_len  = length - total;
+            result = recvmsg( unix_handle, &msg, MSG_PEEK | (total ? MSG_DONTWAIT : 0) );
+
+            /* dequeue one message */
+            if (result >= 0 && !(msg.msg_flags & MSG_TRUNC))
+            {
+                int ret;
+                do
+                {
+                    iov.iov_base = &ret;
+                    iov.iov_len  = sizeof(ret);
+                    ret = recvmsg( unix_handle, &msg, MSG_TRUNC );
+                    if (ret < 0) ERR("failed to dequeue message from message mode pipe\n");
+                    msg.msg_flags = 0;
+                }
+                while (result > 0 && !ret);
+            }
+        }
+        else
+            result = read( unix_handle, (char *)buffer + total, length - total );
+
+        if (result >= 0)
         {
             total += result;
             if (!result || total == length)
@@ -675,6 +723,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
                 }
             }
             else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
+            else if (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE) continue; /* concatenate with next message */
         }
         else if (errno != EAGAIN)
         {
@@ -969,7 +1018,7 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
     unsigned int options;
     struct io_timeouts timeouts;
     NTSTATUS status;
-    ULONG total = 0;
+    ULONG total = 0, msgsize = (ULONG)-1;
     enum server_fd_type type;
     ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
     BOOL send_completion = FALSE, async_write, append_write = FALSE, timeout_init_done = FALSE;
@@ -1070,7 +1119,7 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
         if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_PIPE || type == FD_TYPE_SOCKET))
             result = send( unix_handle, buffer, 0, 0 );
         else
-            result = write( unix_handle, (const char *)buffer + total, length - total );
+            result = write( unix_handle, (const char *)buffer + total, min(length - total, msgsize) );
 
         if (result >= 0)
         {
@@ -1085,6 +1134,18 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
         else if (errno != EAGAIN)
         {
             if (errno == EINTR) continue;
+            if (errno == EMSGSIZE && type == FD_TYPE_PIPE && msgsize > 4096)
+            {
+                if (msgsize == (ULONG)-1)
+                {
+                    FIXME("Message of size %d is too big and will be truncated\n", length);
+                    msgsize = (length + 4095) & ~4095;
+                }
+
+                /* FIXME: inefficient loop - max named pipe message size should be cached! */
+                msgsize -= 4096;
+                continue;
+            }
             if (!total)
             {
                 if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
@@ -1517,13 +1578,16 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
     case FSCTL_PIPE_PEEK:
         {
             FILE_PIPE_PEEK_BUFFER *buffer = out_buffer;
-            int avail = 0, fd, needs_close;
+            int sock_type = 0, avail = 0, fd, needs_close;
+            socklen_t sock_opt_len;
+            ULONG data_size;
 
             if (out_size < FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data ))
             {
                 status = STATUS_INFO_LENGTH_MISMATCH;
                 break;
             }
+            data_size = out_size - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
 
             if ((status = server_get_unix_fd( handle, FILE_READ_DATA, &fd, &needs_close, NULL, NULL )))
                 break;
@@ -1555,18 +1619,36 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
             }
             buffer->NamedPipeState    = 0;  /* FIXME */
             buffer->ReadDataAvailable = avail;
-            buffer->NumberOfMessages  = 0;  /* FIXME */
-            buffer->MessageLength     = 0;  /* FIXME */
+            buffer->NumberOfMessages  = 0;
+            buffer->MessageLength     = 0;
             io->Information = FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
             status = STATUS_SUCCESS;
-            if (avail)
+
+            sock_opt_len = sizeof(sock_type);
+            if (!getsockopt( fd, SOL_SOCKET, SO_TYPE, &sock_type, &sock_opt_len ) &&
+                    sock_type == SOCK_SEQPACKET)
             {
-                ULONG data_size = out_size - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
-                if (data_size)
+                int peek_offset = 0, msg_length = 0;
+                if (avail)
                 {
-                    int res = recv( fd, buffer->Data, data_size, MSG_PEEK );
-                    if (res >= 0) io->Information += res;
+                    sock_opt_len = sizeof(peek_offset);
+                    if (!getsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &peek_offset, &sock_opt_len ) && peek_offset < avail)
+                    {
+                        msg_length = data_size ? recv( fd, buffer->Data, data_size, MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT ) :
+                                                 recv( fd, (char *)&msg_length, sizeof(msg_length), MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT );
+                        if (msg_length >= 0) io->Information += min(msg_length, data_size);
+                        if (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &peek_offset, sizeof(peek_offset) ))
+                            ERR("setsockopt(SO_PEEK_OFF) failed reason: %s\n", strerror(errno));
+                    }
                 }
+                buffer->ReadDataAvailable = avail - peek_offset;
+                buffer->NumberOfMessages  = (peek_offset < avail); /* FIXME */
+                buffer->MessageLength     = max(0, msg_length);
+            }
+            else if (data_size)
+            {
+                int res = recv( fd, buffer->Data, data_size, MSG_PEEK );
+                if (res >= 0) io->Information += res;
             }
             if (needs_close) close( fd );
         }
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 70c028c..85b9f74 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -42,6 +42,10 @@
 #include <poll.h>
 #endif
 
+#ifndef SO_PEEK_OFF
+#define SO_PEEK_OFF 42
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -49,6 +53,7 @@
 #include "winioctl.h"
 
 #include "file.h"
+#include "sock.h"
 #include "handle.h"
 #include "thread.h"
 #include "request.h"
@@ -802,14 +807,32 @@ static struct pipe_server *find_available_server( struct named_pipe *pipe )
     return NULL;
 }
 
+/* check if message mode named pipes are supported */
+static int check_named_pipe_message_mode(void)
+{
+    static const int zero = 0;
+    static int messagemode = -1;
+    int fd;
+
+    if (messagemode < 0)
+    {
+        fd = socket( PF_UNIX, SOCK_SEQPACKET, 0 );
+        messagemode = (fd != -1) && (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1);
+        if (fd != -1) close( fd );
+    }
+
+    return messagemode;
+}
+
 static struct object *named_pipe_open_file( struct object *obj, unsigned int access,
                                             unsigned int sharing, unsigned int options )
 {
+    static const int zero = 0;
     struct named_pipe *pipe = (struct named_pipe *)obj;
     struct pipe_server *server;
     struct pipe_client *client;
     unsigned int pipe_sharing;
-    int fds[2];
+    int fds[2], type;
 
     if (!(server = find_available_server( pipe )))
     {
@@ -828,7 +851,10 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
 
     if ((client = create_pipe_client( options, pipe->flags )))
     {
-        if (!socketpair( PF_UNIX, SOCK_STREAM, 0, fds ))
+        type = ((pipe->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE) && check_named_pipe_message_mode()) ?
+                SOCK_SEQPACKET : SOCK_STREAM;
+
+        if (!socketpair( PF_UNIX, type, 0, fds ))
         {
             assert( !server->fd );
 
@@ -849,21 +875,34 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
                 setsockopt( fds[1], SOL_SOCKET, SO_SNDBUF, &pipe->outsize, sizeof(pipe->outsize) );
             }
 
-            client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
-            server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
-            if (client->fd && server->fd)
+            if (type != SOCK_SEQPACKET || (setsockopt( fds[0], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1 &&
+                                           setsockopt( fds[1], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1))
             {
-                allow_fd_caching( client->fd );
-                allow_fd_caching( server->fd );
-                fd_copy_completion( server->ioctl_fd, server->fd );
-                if (server->state == ps_wait_open)
-                    fd_async_wake_up( server->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
-                set_server_state( server, ps_connected_server );
-                server->client = client;
-                client->server = server;
+                fcntl( fds[0], F_SETSIG, server->pipe_flags );
+                fcntl( fds[1], F_SETSIG, client->pipe_flags );
+
+                client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
+                server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
+                if (client->fd && server->fd)
+                {
+                    allow_fd_caching( client->fd );
+                    allow_fd_caching( server->fd );
+                    fd_copy_completion( server->ioctl_fd, server->fd );
+                    if (server->state == ps_wait_open)
+                        fd_async_wake_up( server->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
+                    set_server_state( server, ps_connected_server );
+                    server->client = client;
+                    client->server = server;
+                }
+                else
+                {
+                    release_object( client );
+                    client = NULL;
+                }
             }
             else
             {
+                sock_set_error();
                 release_object( client );
                 client = NULL;
             }
@@ -961,7 +1000,10 @@ DECL_HANDLER(create_named_pipe)
         return;
     }
 
-    reply->flags = req->flags & ~(NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ);
+    reply->flags = req->flags;
+    if (!check_named_pipe_message_mode())
+        reply->flags &= ~(NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ);
+
     reply->handle = 0;
     get_req_unicode_str( &name );
     if (req->rootdir && !(root = get_directory_obj( current->process, req->rootdir, 0 )))
@@ -1051,6 +1093,7 @@ DECL_HANDLER(set_named_pipe_info)
 {
     struct pipe_server *server;
     struct pipe_client *client = NULL;
+    int unix_fd;
 
     server = get_pipe_server_obj( current->process, req->handle, FILE_WRITE_ATTRIBUTES );
     if (!server)
@@ -1073,10 +1116,16 @@ DECL_HANDLER(set_named_pipe_info)
     else if (client)
     {
         client->pipe_flags = server->pipe->flags | req->flags;
+        if (client->fd && (unix_fd = get_unix_fd( client->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, client->pipe_flags );
+        clear_error();
     }
     else
     {
         server->pipe_flags = server->pipe->flags | req->flags;
+        if (server->fd && (unix_fd = get_unix_fd( server->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, server->pipe_flags );
+        clear_error();
     }
 
     if (client)
diff --git a/server/sock.c b/server/sock.c
index 4adad0f..ece74a8 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -55,6 +55,7 @@
 
 #include "process.h"
 #include "file.h"
+#include "sock.h"
 #include "handle.h"
 #include "thread.h"
 #include "request.h"
@@ -126,7 +127,6 @@ static void sock_cancel_async( struct fd *fd, struct process *process, struct th
 
 static int sock_get_ntstatus( int err );
 static int sock_get_error( int err );
-static void sock_set_error(void);
 
 static const struct object_ops sock_ops =
 {
@@ -904,7 +904,7 @@ static int sock_get_ntstatus( int err )
 }
 
 /* set the last error depending on errno */
-static void sock_set_error(void)
+void sock_set_error(void)
 {
     set_error( sock_get_ntstatus( errno ) );
 }
diff --git a/server/sock.h b/server/sock.h
new file mode 100644
index 0000000..21551b4
--- /dev/null
+++ b/server/sock.h
@@ -0,0 +1,26 @@
+/*
+ * Server-side socket definitions
+ *
+ * Copyright (C) 2014 Sebastian Lackner
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_SERVER_SOCK_H
+#define __WINE_SERVER_SOCK_H
+
+extern void sock_set_error(void);
+
+#endif  /* __WINE_SERVER_SOCK_H */
-- 
1.7.9.5

