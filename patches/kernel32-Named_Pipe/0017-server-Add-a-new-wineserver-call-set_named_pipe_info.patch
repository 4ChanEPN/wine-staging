From 452b57efe296754d833db08082d5a4be89b0776e Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Mon, 11 Aug 2014 09:04:56 +0200
Subject: server: Add a new wineserver call set_named_pipe_info to allow
 setting the pipe mode when no handle is associcated.

This patch is too huge and definitely needs splitting. It also contains parts by Adam Martinson.
---
 dlls/kernel32/sync.c       |  107 +++++++++++++++++++++++++++++---------------
 dlls/kernel32/tests/pipe.c |    6 ---
 dlls/ntdll/file.c          |   65 +++++++++++++++++++++------
 include/winternl.h         |   11 +++++
 server/named_pipe.c        |   98 +++++++++++++++++++++++++++++-----------
 5 files changed, 204 insertions(+), 83 deletions(-)

diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index d849807..5a3797e 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1716,12 +1716,16 @@ BOOL WINAPI GetNamedPipeHandleStateA(
     LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout,
     LPSTR lpUsername, DWORD nUsernameMaxSize)
 {
-    FIXME("%p %p %p %p %p %p %d\n",
-          hNamedPipe, lpState, lpCurInstances,
-          lpMaxCollectionCount, lpCollectDataTimeout,
-          lpUsername, nUsernameMaxSize);
+    WARN("%p %p %p %p %p %p %d: semi-stub\n",
+         hNamedPipe, lpState, lpCurInstances,
+         lpMaxCollectionCount, lpCollectDataTimeout,
+         lpUsername, nUsernameMaxSize);
 
-    return FALSE;
+    if (lpUsername && nUsernameMaxSize)
+        *lpUsername = 0;
+
+    return GetNamedPipeHandleStateW(hNamedPipe, lpState, lpCurInstances,
+                                    lpMaxCollectionCount, lpCollectDataTimeout, NULL, 0);
 }
 
 /***********************************************************************
@@ -1732,12 +1736,53 @@ BOOL WINAPI GetNamedPipeHandleStateW(
     LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout,
     LPWSTR lpUsername, DWORD nUsernameMaxSize)
 {
-    FIXME("%p %p %p %p %p %p %d\n",
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+
+    FIXME("%p %p %p %p %p %p %d: semi-stub\n",
           hNamedPipe, lpState, lpCurInstances,
           lpMaxCollectionCount, lpCollectDataTimeout,
           lpUsername, nUsernameMaxSize);
 
-    return FALSE;
+    if (lpMaxCollectionCount)
+        *lpMaxCollectionCount = 0;
+
+    if (lpCollectDataTimeout)
+        *lpCollectDataTimeout = 0;
+
+    if (lpUsername && nUsernameMaxSize)
+        *lpUsername = 0;
+
+    if (lpState)
+    {
+        FILE_PIPE_INFORMATION fpi;
+        status = NtQueryInformationFile(hNamedPipe, &iosb, &fpi, sizeof(fpi),
+                                        FilePipeInformation);
+        if (status)
+        {
+            SetLastError( RtlNtStatusToDosError(status) );
+            return FALSE;
+        }
+
+        *lpState = (fpi.ReadMode ? PIPE_READMODE_MESSAGE : PIPE_READMODE_BYTE) |
+                   (fpi.CompletionMode ? PIPE_NOWAIT : PIPE_WAIT);
+    }
+
+    if (lpCurInstances)
+    {
+        FILE_PIPE_LOCAL_INFORMATION fpli;
+        status = NtQueryInformationFile(hNamedPipe, &iosb, &fpli, sizeof(fpli),
+                                        FilePipeLocalInformation);
+        if (status)
+        {
+            SetLastError( RtlNtStatusToDosError(status) );
+            return FALSE;
+        }
+
+        *lpCurInstances = fpli.CurrentInstances;
+    }
+
+    return TRUE;
 }
 
 /***********************************************************************
@@ -1747,44 +1792,34 @@ BOOL WINAPI SetNamedPipeHandleState(
     HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount,
     LPDWORD lpCollectDataTimeout)
 {
-    NTSTATUS status;
-    int fd;
-
-    TRACE("%p %p/%d %p %p\n",
+    /* should be a fixme, but this function is called a lot by the RPC
+     * runtime, and it slows down InstallShield a fair bit. */
+    WARN("%p %p/%d %p %p: semi-stub\n",
           hNamedPipe, lpMode, lpMode ? *lpMode : 0, lpMaxCollectionCount, lpCollectDataTimeout);
 
-    status = wine_server_handle_to_fd( hNamedPipe, GENERIC_READ | FILE_WRITE_ATTRIBUTES, &fd, NULL );
-    if (status == STATUS_SUCCESS)
+    if (lpMode)
     {
+        FILE_PIPE_INFORMATION fpi;
+        IO_STATUS_BLOCK iosb;
+        NTSTATUS status;
 
-        if (lpMode)
+        if (*lpMode & ~(PIPE_READMODE_MESSAGE | PIPE_NOWAIT))
+            status = STATUS_INVALID_PARAMETER;
+        else
         {
-            int sock_type = 0;
-            socklen_t sock_opt_len = sizeof(sock_type);
-            if (getsockopt( fd, SOL_SOCKET, SO_TYPE, &sock_type, &sock_opt_len ) ||
-                    sock_type != SOCK_SEQPACKET)
-            {
-                if (*lpMode & PIPE_READMODE_MESSAGE)
-                    status = STATUS_INVALID_PARAMETER;
-            }
-
-            if (status == STATUS_SUCCESS)
-            {
-                int message_mode_flags = 0;
-                if (*lpMode & PIPE_READMODE_MESSAGE)
-                    message_mode_flags |= 0x01;
-                if (*lpMode & PIPE_NOWAIT)
-                    message_mode_flags |= 0x02;
-                if (fcntl( fd, F_SETSIG, message_mode_flags ) == -1)
-                    status = STATUS_ACCESS_VIOLATION;
-            }
+            fpi.CompletionMode = (*lpMode & PIPE_NOWAIT) ? FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION;
+            fpi.ReadMode = (*lpMode & PIPE_READMODE_MESSAGE) ? FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE;
+            status = NtSetInformationFile(hNamedPipe, &iosb, &fpi, sizeof(fpi), FilePipeInformation);
         }
 
-        wine_server_release_fd( hNamedPipe, fd );
+        if (status)
+        {
+            SetLastError( RtlNtStatusToDosError(status) );
+            return FALSE;
+        }
     }
 
-    if (status != STATUS_SUCCESS) SetLastError( RtlNtStatusToDosError(status) );
-    return !status;
+    return TRUE;
 }
 
 /***********************************************************************
diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index 22b1311..e8b0067 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -2550,11 +2550,9 @@ static void test_NamedPipeHandleState(void)
         /* lpSecurityAttrib */ NULL);
     ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
     ret = GetNamedPipeHandleStateA(server, NULL, NULL, NULL, NULL, NULL, 0);
-    todo_wine
     ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
     ret = GetNamedPipeHandleStateA(server, &state, &instances, NULL, NULL, NULL,
         0);
-    todo_wine
     ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
     if (ret)
     {
@@ -2575,7 +2573,6 @@ static void test_NamedPipeHandleState(void)
     state = PIPE_READMODE_MESSAGE;
     SetLastError(0xdeadbeef);
     ret = SetNamedPipeHandleState(server, &state, NULL, NULL);
-    todo_wine
     ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER,
        "expected ERROR_INVALID_PARAMETER, got %d\n", GetLastError());
 
@@ -2605,11 +2602,9 @@ static void test_NamedPipeHandleState(void)
         /* lpSecurityAttrib */ NULL);
     ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
     ret = GetNamedPipeHandleStateA(server, NULL, NULL, NULL, NULL, NULL, 0);
-    todo_wine
     ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
     ret = GetNamedPipeHandleStateA(server, &state, &instances, NULL, NULL, NULL,
         0);
-    todo_wine
     ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
     if (ret)
     {
@@ -2621,7 +2616,6 @@ static void test_NamedPipeHandleState(void)
      */
     state = PIPE_READMODE_BYTE;
     ret = SetNamedPipeHandleState(server, &state, NULL, NULL);
-    todo_wine
     ok(ret, "SetNamedPipeHandleState failed: %d\n", GetLastError());
 
     client = CreateFileA(PIPENAME, GENERIC_READ|GENERIC_WRITE, 0, NULL,
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 5a8e83f..886bb12 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -657,12 +657,9 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
     }
     else if (type == FD_TYPE_PIPE)
     {
-        int sock_type = 0;
-        socklen_t sock_opt_len = sizeof(sock_type);
         message_mode_flags = fcntl( unix_handle, F_GETSIG );
-
-        if (!getsockopt( unix_handle, SOL_SOCKET, SO_TYPE, &sock_type, &sock_opt_len ) &&
-                sock_type == SOCK_SEQPACKET)
+        message_mode = (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE);
+        if (message_mode)
         {
             msg.msg_name        = NULL;
             msg.msg_namelen     = 0;
@@ -671,7 +668,6 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             msg.msg_control     = NULL;
             msg.msg_controllen  = 0;
             msg.msg_flags       = 0;
-            message_mode        = TRUE;
         }
     }
 
@@ -680,7 +676,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
         if (message_mode)
         {
             int recvmsg_flags = MSG_PEEK;
-            if (total || (message_mode_flags & 0x02))
+            if (total || (message_mode_flags & NAMED_PIPE_NONBLOCKING_MODE))
                 recvmsg_flags |= MSG_DONTWAIT;
 
             /* for message mode pipes we can't use the regular read command, as this would discard
@@ -705,7 +701,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
                 while (result > 0 && !ret);
             }
         }
-        else if (message_mode_flags & 2)
+        else if (message_mode_flags & NAMED_PIPE_NONBLOCKING_MODE)
             result = recv( unix_handle, (char *)buffer + total, length - total, MSG_DONTWAIT );
         else
             result = read( unix_handle, (char *)buffer + total, length - total );
@@ -716,7 +712,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             /* NOTE: In message mode we stop as soon as we reach a message boundary,
              * even if the buffer is not full yet. */
             if (!result || total == length || (message_mode && !(msg.msg_flags & MSG_TRUNC) &&
-                                               (message_mode_flags & 0x01)))
+                                               (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_READ)))
             {
                 if (total)
                 {
@@ -776,7 +772,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             }
             else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
             /* message mode pipe, but byte read mode -> concatenate with next message. */
-            else if (message_mode && !(message_mode_flags & 0x01)) continue;
+            else if (message_mode && !(message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_READ)) continue;
         }
         else if (errno != EAGAIN)
         {
@@ -786,7 +782,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
         }
 
         /* don't wait in nowait mode */
-        if (message_mode_flags & 0x02)
+        if (message_mode_flags & NAMED_PIPE_NONBLOCKING_MODE)
         {
             status = total ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;
             goto done;
@@ -877,7 +873,7 @@ err:
     if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && !async_read))
     {
         /* NOTE: When total == 0, then Windows doesn't return STATUS_MORE_ENTRIES although it was splitted */
-        if (total && message_mode && (msg.msg_flags & MSG_TRUNC) && (message_mode_flags & 0x01))
+        if (total && message_mode && (msg.msg_flags & MSG_TRUNC) && (message_mode_flags & NAMED_PIPE_MESSAGE_STREAM_READ))
             status = STATUS_MORE_ENTRIES;
 
         io_status->u.Status = status;
@@ -2127,7 +2123,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
         sizeof(FILE_END_OF_FILE_INFORMATION),          /* FileEndOfFileInformation */
         0,                                             /* FileAlternateNameInformation */
         sizeof(FILE_STREAM_INFORMATION)-sizeof(WCHAR), /* FileStreamInformation */
-        0,                                             /* FilePipeInformation */
+        sizeof(FILE_PIPE_INFORMATION),                 /* FilePipeInformation */
         sizeof(FILE_PIPE_LOCAL_INFORMATION),           /* FilePipeLocalInformation */
         0,                                             /* FilePipeRemoteInformation */
         sizeof(FILE_MAILSLOT_QUERY_INFORMATION),       /* FileMailslotQueryInformation */
@@ -2178,7 +2174,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
     if (len < info_sizes[class])
         return io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
 
-    if (class != FilePipeLocalInformation)
+    if (class != FilePipeInformation && class != FilePipeLocalInformation)
     {
         if ((io->u.Status = server_get_unix_fd( hFile, 0, &fd, &needs_close, NULL, NULL )))
             return io->u.Status;
@@ -2292,6 +2288,24 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
             }
         }
         break;
+    case FilePipeInformation:
+        {
+            FILE_PIPE_INFORMATION* pi = ptr;
+
+            SERVER_START_REQ( get_named_pipe_info )
+            {
+                req->handle = wine_server_obj_handle( hFile );
+                if (!(io->u.Status = wine_server_call( req )))
+                {
+                    pi->ReadMode       = (reply->flags & NAMED_PIPE_MESSAGE_STREAM_READ) ?
+                        FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE;
+                    pi->CompletionMode = (reply->flags & NAMED_PIPE_NONBLOCKING_MODE) ?
+                        FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION;
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
     case FilePipeLocalInformation:
         {
             FILE_PIPE_LOCAL_INFORMATION* pli = ptr;
@@ -2463,6 +2477,29 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
         else io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
 
+    case FilePipeInformation:
+        if (len >= sizeof(FILE_PIPE_INFORMATION))
+        {
+            FILE_PIPE_INFORMATION *info = ptr;
+
+            if ((info->CompletionMode & (~1)) || (info->ReadMode & (~1)))
+            {
+                io->u.Status = STATUS_INVALID_PARAMETER;
+                break;
+            }
+
+            SERVER_START_REQ( set_named_pipe_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags  = (info->CompletionMode ? NAMED_PIPE_NONBLOCKING_MODE : 0) |
+                              (info->ReadMode ? NAMED_PIPE_MESSAGE_STREAM_READ : 0);
+                io->u.Status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
     case FileMailslotSetInformation:
         {
             FILE_MAILSLOT_SET_INFORMATION *info = ptr;
diff --git a/include/winternl.h b/include/winternl.h
index a95a016..95951e2 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -623,6 +623,11 @@ typedef struct _FILE_MAILSLOT_SET_INFORMATION {
     LARGE_INTEGER ReadTimeout;
 } FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;
 
+typedef struct _FILE_PIPE_INFORMATION {
+    ULONG ReadMode;
+    ULONG CompletionMode;
+} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;
+
 typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
@@ -1602,6 +1607,12 @@ typedef struct _RTL_HANDLE_TABLE
 /* options for pipe's type */
 #define FILE_PIPE_TYPE_MESSAGE          0x00000001
 #define FILE_PIPE_TYPE_BYTE             0x00000000
+/* options for pipe's message mode */
+#define FILE_PIPE_MESSAGE_MODE          0x00000001
+#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
+/* options for pipe's blocking mode */
+#define FILE_PIPE_COMPLETE_OPERATION    0x00000001
+#define FILE_PIPE_QUEUE_OPERATION       0x00000000
 /* and client / server end */
 #define FILE_PIPE_SERVER_END            0x00000001
 #define FILE_PIPE_CLIENT_END            0x00000000
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 5a318c0..40f7735 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -82,6 +82,7 @@ struct pipe_server
     struct timeout_user *flush_poll;
     struct event        *event;
     unsigned int         options;    /* pipe options */
+    unsigned int         pipe_flags;
 };
 
 struct pipe_client
@@ -90,6 +91,7 @@ struct pipe_client
     struct fd           *fd;         /* pipe file descriptor */
     struct pipe_server  *server;     /* server that this client is connected to */
     unsigned int         flags;      /* file flags */
+    unsigned int         pipe_flags;
 };
 
 struct named_pipe
@@ -742,7 +744,7 @@ static struct pipe_server *get_pipe_server_obj( struct process *process,
     return (struct pipe_server *) obj;
 }
 
-static struct pipe_server *create_pipe_server( struct named_pipe *pipe, unsigned int options )
+static struct pipe_server *create_pipe_server( struct named_pipe *pipe, unsigned int options, int pipe_flags )
 {
     struct pipe_server *server;
 
@@ -755,6 +757,7 @@ static struct pipe_server *create_pipe_server( struct named_pipe *pipe, unsigned
     server->client = NULL;
     server->flush_poll = NULL;
     server->options = options;
+    server->pipe_flags = pipe_flags;
 
     list_add_head( &pipe->servers, &server->entry );
     grab_object( pipe );
@@ -767,7 +770,7 @@ static struct pipe_server *create_pipe_server( struct named_pipe *pipe, unsigned
     return server;
 }
 
-static struct pipe_client *create_pipe_client( unsigned int flags )
+static struct pipe_client *create_pipe_client( unsigned int flags, int pipe_flags )
 {
     struct pipe_client *client;
 
@@ -778,6 +781,7 @@ static struct pipe_client *create_pipe_client( unsigned int flags )
     client->fd = NULL;
     client->server = NULL;
     client->flags = flags;
+    client->pipe_flags = pipe_flags;
 
     return client;
 }
@@ -804,24 +808,20 @@ static struct pipe_server *find_available_server( struct named_pipe *pipe )
 }
 
 /* check if message mode named pipes are supported */
-static int check_named_pipe_flags(int flags)
+static int check_named_pipe_message_mode(void)
 {
     static const int zero = 0;
     static int messagemode = -1;
     int fd;
 
-    if (flags & (NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ))
+    if (messagemode < 0)
     {
-        if (messagemode < 0)
-        {
-            fd = socket( PF_UNIX, SOCK_SEQPACKET, 0 );
-            messagemode = (fd != -1) && (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1);
-            if (fd != -1) close( fd );
-        }
-        if (!messagemode) flags &= ~(NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ);
+        fd = socket( PF_UNIX, SOCK_SEQPACKET, 0 );
+        messagemode = (fd != -1) && (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1);
+        if (fd != -1) close( fd );
     }
 
-    return flags;
+    return messagemode;
 }
 
 static struct object *named_pipe_open_file( struct object *obj, unsigned int access,
@@ -849,10 +849,10 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
         return NULL;
     }
 
-    if ((client = create_pipe_client( options )))
+    if ((client = create_pipe_client( options, pipe->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE )))
     {
-        type = (check_named_pipe_flags( pipe->flags ) & (NAMED_PIPE_MESSAGE_STREAM_WRITE |
-                NAMED_PIPE_MESSAGE_STREAM_READ)) ? SOCK_SEQPACKET : SOCK_STREAM;
+        type = ((pipe->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE) && check_named_pipe_message_mode()) ?
+                SOCK_SEQPACKET : SOCK_STREAM;
 
         if (!socketpair( PF_UNIX, type, 0, fds ))
         {
@@ -886,13 +886,8 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             if (type != SOCK_SEQPACKET || (setsockopt( fds[0], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1 &&
                                            setsockopt( fds[1], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1))
             {
-                int message_mode_flags = 0;
-                if (pipe->flags & NAMED_PIPE_MESSAGE_STREAM_READ)
-                    message_mode_flags |= 0x01;
-                if (pipe->flags & NAMED_PIPE_NONBLOCKING_MODE)
-                    message_mode_flags |= 0x02;
-                fcntl( fds[0], F_SETSIG, message_mode_flags );
-                fcntl( fds[1], F_SETSIG, 0x00 );
+                fcntl( fds[0], F_SETSIG, server->pipe_flags );
+                fcntl( fds[1], F_SETSIG, client->pipe_flags );
 
                 client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
                 server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
@@ -1013,7 +1008,10 @@ DECL_HANDLER(create_named_pipe)
         return;
     }
 
-    reply->flags = check_named_pipe_flags( req->flags );
+    reply->flags = req->flags;
+    if (!check_named_pipe_message_mode())
+        reply->flags &= ~(NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ);
+
     reply->handle = 0;
     get_req_unicode_str( &name );
     if (req->rootdir && !(root = get_directory_obj( current->process, req->rootdir, 0 )))
@@ -1034,7 +1032,7 @@ DECL_HANDLER(create_named_pipe)
         pipe->outsize = req->outsize;
         pipe->maxinstances = req->maxinstances;
         pipe->timeout = req->timeout;
-        pipe->flags = req->flags;
+        pipe->flags = req->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE;
         pipe->sharing = req->sharing;
     }
     else
@@ -1054,7 +1052,7 @@ DECL_HANDLER(create_named_pipe)
         clear_error(); /* clear the name collision */
     }
 
-    server = create_pipe_server( pipe, req->options );
+    server = create_pipe_server( pipe, req->options, req->flags );
     if (server)
     {
         reply->handle = alloc_handle( current->process, server, req->access, req->attributes );
@@ -1079,11 +1077,12 @@ DECL_HANDLER(get_named_pipe_info)
         clear_error();
         client = (struct pipe_client *)get_handle_obj( current->process, req->handle,
                                                        0, &pipe_client_ops );
-        if (!client) return;
+        if (!client)
+            return;
         server = client->server;
     }
 
-    reply->flags        = server->pipe->flags;
+    reply->flags        = client ? client->pipe_flags : server->pipe_flags;
     reply->sharing      = server->pipe->sharing;
     reply->maxinstances = server->pipe->maxinstances;
     reply->instances    = server->pipe->instances;
@@ -1098,3 +1097,48 @@ DECL_HANDLER(get_named_pipe_info)
         release_object(server);
     }
 }
+
+DECL_HANDLER(set_named_pipe_info)
+{
+    struct pipe_server *server;
+    struct pipe_client *client = NULL;
+    int unix_fd;
+
+    server = get_pipe_server_obj( current->process, req->handle, FILE_WRITE_ATTRIBUTES );
+    if (!server)
+    {
+        if (get_error() != STATUS_OBJECT_TYPE_MISMATCH)
+            return;
+
+        clear_error();
+        client = (struct pipe_client *)get_handle_obj( current->process, req->handle,
+                                                       0, &pipe_client_ops );
+        if (!client) return;
+        server = client->server;
+    }
+
+    if ((req->flags & ~(NAMED_PIPE_MESSAGE_STREAM_READ | NAMED_PIPE_NONBLOCKING_MODE)) ||
+            ((req->flags & NAMED_PIPE_MESSAGE_STREAM_READ) && !(server->pipe->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)))
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+    }
+    else if (client)
+    {
+        client->pipe_flags = server->pipe->flags | req->flags;
+        if (client->fd && (unix_fd = get_unix_fd( client->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, client->pipe_flags );
+        clear_error();
+    }
+    else
+    {
+        server->pipe_flags = server->pipe->flags | req->flags;
+        if (server->fd && (unix_fd = get_unix_fd( server->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, server->pipe_flags );
+        clear_error();
+    }
+
+    if (client)
+        release_object(client);
+    else
+        release_object(server);
+}
-- 
1.7.9.5

