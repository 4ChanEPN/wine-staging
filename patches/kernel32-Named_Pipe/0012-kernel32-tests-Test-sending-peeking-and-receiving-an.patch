From 622dcae19dbd6ddf8e808a61074e60d86351d61f Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Mon, 11 Aug 2014 00:56:46 +0200
Subject: kernel32/tests: Test sending, peeking and receiving an empty
 message.

The changes in dlls/ntdll/file.c are required to work around an ugly
Linux specific problem. Its not possible to seek back zero-byte packages
with SO_PEEK_OFF...
---
 dlls/kernel32/tests/pipe.c |  226 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/file.c          |   14 ++-
 2 files changed, 235 insertions(+), 5 deletions(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index 1eef763..c30bd71 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -337,6 +337,94 @@ static void test_CreateNamedPipe(int pipemode)
         ok(readden == sizeof(obuf2)-8, "read got %d bytes\n", readden);
         ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
 
+        /* Tests for sending empty messages */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        /* similar to above, but with an additional call to PeekNamedPipe inbetween */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == 0, "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == 0, "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        /* similar to above, but now with PeekNamedPipe and multiple messages */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+        ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        else
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf), "read got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf2, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf2), "write file len\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+        ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        else
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        }
+        ok(readden == sizeof(obuf2), "read got %d bytes\n", readden);
+        ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check\n");
+
         /* Test reading of multiple writes */
         memset(ibuf, 0, sizeof(ibuf));
         ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile3a\n");
@@ -459,6 +547,77 @@ static void test_CreateNamedPipe(int pipemode)
             if (readden <= sizeof(obuf))
                 ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
 
+            /* Tests for sending empty messages */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            /* similar to above, but with an additional call to PeekNamedPipe inbetween */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+            ok(readden == 0, "peek got %d bytes\n", readden);
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+            ok(readden == 0, "peek got %d bytes\n", readden);
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            /* similar to above, but now with PeekNamedPipe and multiple messages */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf), "write file len\n");
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf), "read got %d bytes\n", readden);
+            ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf2, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf2), "write file len\n");
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf2), "read got %d bytes\n", readden);
+            ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check\n");
+
             /* Test how ReadFile behaves when the buffer is not big enough for the whole message */
             memset(ibuf, 0, sizeof(ibuf));
             ok(WriteFile(hnp, obuf2, sizeof(obuf2), &written, NULL), "WriteFile 7\n");
@@ -955,6 +1114,40 @@ static void test_CloseNamedPipe(void)
     hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
     ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
 
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len 1\n");
+
+        /* close server end without disconnecting */
+        ok(CloseHandle(hnp), "CloseHandle() failed: %08x\n", GetLastError());
+
+        todo_wine
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        ok(!ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        todo_wine
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hFile);
+    }
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
     if (hFile != INVALID_HANDLE_VALUE)
     {
         /* Make sure we can read and write a few bytes in both directions */
@@ -982,6 +1175,39 @@ static void test_CloseNamedPipe(void)
 
         CloseHandle(hnp);
     }
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len 1\n");
+
+        /* close server end without disconnecting */
+        ok(CloseHandle(hFile), "CloseHandle() failed: %08x\n", GetLastError());
+
+        todo_wine
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        ok(!ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hnp);
+    }
 }
 
 /** implementation of alarm() */
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 8bc305c..bd89e5d 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -687,11 +687,15 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             if (result >= 0 && !(msg.msg_flags & MSG_TRUNC))
             {
                 int ret;
-                iov.iov_base = &ret;
-                iov.iov_len  = sizeof(ret);
-                ret = recvmsg( unix_handle, &msg, MSG_TRUNC );
-                if (ret < 0) ERR("failed to dequeue message from message mode pipe\n");
-                msg.msg_flags = 0;
+                do
+                {
+                    iov.iov_base = &ret;
+                    iov.iov_len  = sizeof(ret);
+                    ret = recvmsg( unix_handle, &msg, MSG_TRUNC );
+                    if (ret < 0) ERR("failed to dequeue message from message mode pipe\n");
+                    msg.msg_flags = 0;
+                }
+                while (result > 0 && !ret);
             }
         }
         else
-- 
1.7.9.5

