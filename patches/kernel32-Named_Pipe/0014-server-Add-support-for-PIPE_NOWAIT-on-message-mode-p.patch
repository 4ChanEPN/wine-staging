From 666940a1c7347f7a9c968197761432e7d034183f Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Mon, 11 Aug 2014 04:17:49 +0200
Subject: server: Add support for PIPE_NOWAIT on message mode pipes.

---
 dlls/kernel32/sync.c |   19 +++++++++++++------
 dlls/ntdll/file.c    |   21 +++++++++++++++++----
 server/named_pipe.c  |    8 ++++++--
 3 files changed, 36 insertions(+), 12 deletions(-)

diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index c4669af..a12f233 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1764,14 +1764,21 @@ BOOL WINAPI SetNamedPipeHandleState(
             if (!getsockopt( fd, SOL_SOCKET, SO_TYPE, &sock_type, &sock_opt_len ) &&
                     sock_type == SOCK_SEQPACKET)
             {
-                if (fcntl( fd, F_SETSIG, (*lpMode & PIPE_READMODE_MESSAGE) ? 0x01 : 0x00 ) == -1)
+                int message_mode_flags = 0;
+                if (*lpMode & PIPE_READMODE_MESSAGE)
+                    message_mode_flags |= 0x01;
+                if (*lpMode & PIPE_NOWAIT)
+                    message_mode_flags |= 0x02;
+                if (fcntl( fd, F_SETSIG, message_mode_flags ) == -1)
                     status = STATUS_ACCESS_VIOLATION;
             }
-            else if (*lpMode & PIPE_READMODE_MESSAGE)
-                status = STATUS_INVALID_PARAMETER;
-
-            if (*lpMode & PIPE_NOWAIT)
-                FIXME("PIPE_NOWAIT is not currently supported.\n");
+            else
+            {
+                if (*lpMode & PIPE_READMODE_MESSAGE)
+                    status = STATUS_INVALID_PARAMETER;
+                if (*lpMode & PIPE_NOWAIT)
+                    FIXME("PIPE_NOWAIT is not currently supported.\n");
+            }
         }
 
         wine_server_release_fd( hNamedPipe, fd );
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index bd89e5d..569840e 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -598,6 +598,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
     enum server_fd_type type;
     ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
     BOOL send_completion = FALSE, async_read, timeout_init_done = FALSE, message_mode = FALSE;
+    int message_mode_flags;
     struct msghdr msg;
     struct iovec iov;
 
@@ -668,6 +669,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             msg.msg_control     = NULL;
             msg.msg_controllen  = 0;
             msg.msg_flags       = 0;
+            message_mode_flags  = fcntl( unix_handle, F_GETSIG );
             message_mode        = TRUE;
         }
     }
@@ -676,12 +678,16 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
     {
         if (message_mode)
         {
+            int recvmsg_flags = MSG_PEEK;
+            if (total || (message_mode_flags & 0x02))
+                recvmsg_flags |= MSG_DONTWAIT;
+
             /* for message mode pipes we can't use the regular read command, as this would discard
              * the rest of the message, which doesn't fit into the buffer. To avoid that use recvmsg()
              * with MSG_PEEK. */
             iov.iov_base = (char *)buffer + total;
             iov.iov_len  = length - total;
-            result = recvmsg( unix_handle, &msg, MSG_PEEK | (total ? MSG_DONTWAIT : 0) );
+            result = recvmsg( unix_handle, &msg, recvmsg_flags );
 
             /* dequeue one message */
             if (result >= 0 && !(msg.msg_flags & MSG_TRUNC))
@@ -707,7 +713,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             /* NOTE: In message mode we stop as soon as we reach a message boundary,
              * even if the buffer is not full yet. */
             if (!result || total == length || (message_mode && !(msg.msg_flags & MSG_TRUNC) &&
-                                               (fcntl( unix_handle, F_GETSIG ) & 0x01)))
+                                               (message_mode_flags & 0x01)))
             {
                 if (total)
                 {
@@ -767,7 +773,7 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             }
             else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
             /* message mode pipe, but byte read mode -> concatenate with next message. */
-            else if (message_mode && !(fcntl( unix_handle, F_GETSIG ) & 0x01)) continue;
+            else if (message_mode && !(message_mode_flags & 0x01)) continue;
         }
         else if (errno != EAGAIN)
         {
@@ -776,6 +782,13 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             goto done;
         }
 
+        /* don't wait in nowait mode */
+        if (message_mode && (message_mode_flags & 0x02))
+        {
+            status = total ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;
+            goto done;
+        }
+
         if (async_read)
         {
             async_fileio_read *fileio;
@@ -861,7 +874,7 @@ err:
     if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && !async_read))
     {
         /* NOTE: When total == 0, then Windows doesn't return STATUS_MORE_ENTRIES although it was splitted */
-        if (total && message_mode && (msg.msg_flags & MSG_TRUNC) && (fcntl( unix_handle, F_GETSIG ) & 0x01))
+        if (total && message_mode && (msg.msg_flags & MSG_TRUNC) && (message_mode_flags & 0x01))
             status = STATUS_MORE_ENTRIES;
 
         io_status->u.Status = status;
diff --git a/server/named_pipe.c b/server/named_pipe.c
index aac5565..0cf365c 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -889,8 +889,12 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
 
                 if (type == SOCK_SEQPACKET)
                 {
-                    /* server side is by default in message read mode, client in byte read mode. */
-                    fcntl( fds[0], F_SETSIG, (pipe->flags & NAMED_PIPE_MESSAGE_STREAM_READ) ? 0x01 : 0x00 );
+                    int message_mode_flags = 0;
+                    if (pipe->flags & NAMED_PIPE_MESSAGE_STREAM_READ)
+                        message_mode_flags |= 0x01;
+                    if (pipe->flags & NAMED_PIPE_NONBLOCKING_MODE)
+                        message_mode_flags |= 0x02;
+                    fcntl( fds[0], F_SETSIG, message_mode_flags );
                     fcntl( fds[1], F_SETSIG, 0x00 );
                 }
 
-- 
1.7.9.5

