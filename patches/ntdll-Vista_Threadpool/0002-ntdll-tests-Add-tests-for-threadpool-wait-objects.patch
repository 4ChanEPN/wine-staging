From c8a3a30a9d4f4a3609d59298d486b691f682390e Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Fri, 6 Feb 2015 20:09:41 +0100
Subject: ntdll/tests: Add tests for threadpool wait objects.

---
 dlls/ntdll/tests/threadpool.c | 295 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 295 insertions(+)

diff --git a/dlls/ntdll/tests/threadpool.c b/dlls/ntdll/tests/threadpool.c
index 0671202..9904d46 100644
--- a/dlls/ntdll/tests/threadpool.c
+++ b/dlls/ntdll/tests/threadpool.c
@@ -24,11 +24,13 @@ static HMODULE hntdll = 0;
 static NTSTATUS (WINAPI *pTpAllocCleanupGroup)(TP_CLEANUP_GROUP **);
 static NTSTATUS (WINAPI *pTpAllocPool)(TP_POOL **,PVOID);
 static NTSTATUS (WINAPI *pTpAllocTimer)(TP_TIMER **,PTP_TIMER_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+static NTSTATUS (WINAPI *pTpAllocWait)(TP_WAIT **,PTP_WAIT_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
 static NTSTATUS (WINAPI *pTpAllocWork)(TP_WORK **,PTP_WORK_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
 static NTSTATUS (WINAPI *pTpCallbackMayRunLong)(TP_CALLBACK_INSTANCE *);
 static VOID     (WINAPI *pTpCallbackReleaseSemaphoreOnCompletion)(TP_CALLBACK_INSTANCE *,HANDLE,DWORD);
 static VOID     (WINAPI *pTpDisassociateCallback)(TP_CALLBACK_INSTANCE *);
 static BOOL     (WINAPI *pTpIsTimerSet)(TP_TIMER *);
+static VOID     (WINAPI *pTpReleaseWait)(TP_WAIT *);
 static VOID     (WINAPI *pTpPostWork)(TP_WORK *);
 static VOID     (WINAPI *pTpReleaseCleanupGroup)(TP_CLEANUP_GROUP *);
 static VOID     (WINAPI *pTpReleaseCleanupGroupMembers)(TP_CLEANUP_GROUP *,BOOL,PVOID);
@@ -37,8 +39,10 @@ static VOID     (WINAPI *pTpReleaseTimer)(TP_TIMER *);
 static VOID     (WINAPI *pTpReleaseWork)(TP_WORK *);
 static VOID     (WINAPI *pTpSetPoolMaxThreads)(TP_POOL *,DWORD);
 static VOID     (WINAPI *pTpSetTimer)(TP_TIMER *,LARGE_INTEGER *,LONG,LONG);
+static VOID     (WINAPI *pTpSetWait)(TP_WAIT *,HANDLE,LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pTpSimpleTryPost)(PTP_SIMPLE_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
 static VOID     (WINAPI *pTpWaitForTimer)(TP_TIMER *,BOOL);
+static VOID     (WINAPI *pTpWaitForWait)(TP_WAIT *,BOOL);
 static VOID     (WINAPI *pTpWaitForWork)(TP_WORK *,BOOL);
 
 #define NTDLL_GET_PROC(func) \
@@ -61,6 +65,7 @@ static BOOL init_threadpool(void)
     NTDLL_GET_PROC(TpAllocCleanupGroup);
     NTDLL_GET_PROC(TpAllocPool);
     NTDLL_GET_PROC(TpAllocTimer);
+    NTDLL_GET_PROC(TpAllocWait);
     NTDLL_GET_PROC(TpAllocWork);
     NTDLL_GET_PROC(TpCallbackMayRunLong);
     NTDLL_GET_PROC(TpCallbackReleaseSemaphoreOnCompletion);
@@ -71,11 +76,14 @@ static BOOL init_threadpool(void)
     NTDLL_GET_PROC(TpReleaseCleanupGroupMembers);
     NTDLL_GET_PROC(TpReleasePool);
     NTDLL_GET_PROC(TpReleaseTimer);
+    NTDLL_GET_PROC(TpReleaseWait);
     NTDLL_GET_PROC(TpReleaseWork);
     NTDLL_GET_PROC(TpSetPoolMaxThreads);
     NTDLL_GET_PROC(TpSetTimer);
+    NTDLL_GET_PROC(TpSetWait);
     NTDLL_GET_PROC(TpSimpleTryPost);
     NTDLL_GET_PROC(TpWaitForTimer);
+    NTDLL_GET_PROC(TpWaitForWait);
     NTDLL_GET_PROC(TpWaitForWork);
 
     if (!pTpAllocPool)
@@ -906,6 +914,291 @@ static void test_tp_window_length(void)
     CloseHandle(semaphore);
 }
 
+static void CALLBACK wait_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WAIT *wait, TP_WAIT_RESULT result)
+{
+    trace("Running wait callback\n");
+
+    if (result == WAIT_OBJECT_0)
+        InterlockedIncrement((LONG *)userdata);
+    else if (result == WAIT_TIMEOUT)
+        InterlockedExchangeAdd((LONG *)userdata, 0x10000);
+    else
+        ok(0, "unexpected result %u\n", result);
+}
+
+static void test_tp_wait(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    HANDLE semaphore;
+    TP_WAIT *wait, *wait2;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    LARGE_INTEGER when;
+    DWORD ret;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* Allocate new wait items */
+    wait = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocWait(&wait, wait_cb, &userdata, &environment);
+    ok(!status, "TpAllocWait failed with status %x\n", status);
+    ok(wait != NULL, "expected wait != NULL\n");
+
+    wait2 = NULL;
+    status = pTpAllocWait(&wait2, wait_cb, &userdata, &environment);
+    ok(!status, "TpAllocWait failed with status %x\n", status);
+    ok(wait != NULL, "expected wait != NULL\n");
+
+    semaphore = CreateSemaphoreW(NULL, 0, 1, NULL);
+    ok(semaphore != NULL, "failed to create semaphore\n");
+
+    /* Infinite timeout, signal the semaphore immediately */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+
+    /* Relative timeout, no event */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)50 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    Sleep(100);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Relative timeout, with event */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Absolute timeout, no event */
+    userdata = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)50 * 10000;
+    pTpSetWait(wait, semaphore, &when);
+    Sleep(100);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Absolute timeout, with event */
+    userdata = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)500 * 10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Trigger event immediately */
+    userdata = 0;
+    when.QuadPart = 0;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Cancel a pending wait */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    pTpSetWait(wait, NULL, (void *)0xdeadbeef);
+    Sleep(50);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 1000);
+    ok(ret == WAIT_OBJECT_0, "expected ret = WAIT_OBJECT_0, got %u\n", ret);
+
+    /* Test with INVALID_HANDLE_VALUE */
+    userdata = 0;
+    when.QuadPart = 0;
+    pTpSetWait(wait, INVALID_HANDLE_VALUE, &when);
+    Sleep(50);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+
+    /* Cancel a pending wait with INVALID_HANDLE_VALUE */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    when.QuadPart = (ULONGLONG)100 * -10000;
+    pTpSetWait(wait, INVALID_HANDLE_VALUE, &when);
+    Sleep(250);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+
+    /* Add two objects with the same semaphore */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    pTpSetWait(wait2, semaphore, NULL);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(10);
+    pTpWaitForWait(wait, FALSE);
+    pTpWaitForWait(wait2, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    CloseHandle(semaphore);
+    semaphore = CreateSemaphoreW(NULL, 0, 2, NULL);
+    ok(semaphore != NULL, "failed to create semaphore\n");
+
+    /* Repeat test above, but with a semaphore of count 2 */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    pTpSetWait(wait2, semaphore, NULL);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ReleaseSemaphore(semaphore, 2, NULL);
+    Sleep(10);
+    pTpWaitForWait(wait, FALSE);
+    pTpWaitForWait(wait2, FALSE);
+    ok(userdata == 2, "expected userdata = 2, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    CloseHandle(semaphore);
+
+    /* Cleanup */
+    pTpReleaseWait(wait2);
+    pTpReleaseWait(wait);
+    pTpReleasePool(pool);
+}
+
+static LONG multi_wait_callbacks;
+static DWORD multi_wait_result;
+
+static void CALLBACK multi_wait_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WAIT *wait, TP_WAIT_RESULT result)
+{
+    DWORD index = (DWORD)(DWORD_PTR)userdata;
+    InterlockedIncrement(&multi_wait_callbacks);
+
+    if (result == WAIT_OBJECT_0)
+        multi_wait_result = index;
+    else if (result == WAIT_TIMEOUT)
+        multi_wait_result = 0x10000 | index;
+    else
+        ok(0, "unexpected result %u\n", result);
+}
+
+static void test_tp_multi_wait(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    HANDLE semaphores[512];
+    TP_WAIT *waits[512];
+    TP_POOL *pool;
+    NTSTATUS status;
+    LARGE_INTEGER when;
+    int i;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+
+    /* Create semaphores, wait objects and enable them */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        semaphores[i] = CreateSemaphoreW(NULL, 0, 1, NULL);
+        ok(semaphores[i] != NULL, "failed to create semaphores[%d]\n", i);
+
+        waits[i] = NULL;
+        status = pTpAllocWait(&waits[i], multi_wait_cb, (void *)(DWORD_PTR)i, &environment);
+        ok(!status, "TpAllocWait failed with status %x\n", status);
+        ok(waits[i] != NULL, "expected waits[%d] != NULL\n", i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now test releasing the semaphores */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        multi_wait_callbacks = 0;
+        multi_wait_result = 0;
+
+        ReleaseSemaphore(semaphores[i], 1, NULL);
+        while (multi_wait_callbacks == 0) Sleep(10);
+        ok(multi_wait_callbacks == 1, "expected multi_wait_callbacks = 1, got %u\n", multi_wait_callbacks);
+        ok(multi_wait_result == i, "expected multi_wait_result = %u, got %u\n", multi_wait_result, i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now again in the reversed order */
+    for (i = sizeof(semaphores)/sizeof(semaphores[0]) - 1; i >= 0; i--)
+    {
+        multi_wait_callbacks = 0;
+        multi_wait_result = 0;
+
+        ReleaseSemaphore(semaphores[i], 1, NULL);
+        while (multi_wait_callbacks == 0) Sleep(10);
+        ok(multi_wait_callbacks == 1, "expected multi_wait_callbacks = 1, got %u\n", multi_wait_callbacks);
+        ok(multi_wait_result == i, "expected multi_wait_result = %u, got %u\n", multi_wait_result, i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now test with a timeout */
+    multi_wait_callbacks = 0;
+    multi_wait_result = 0;
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        when.QuadPart = 0;
+        pTpSetWait(waits[i], semaphores[i], &when);
+    }
+    Sleep(50);
+    ok(multi_wait_callbacks == sizeof(semaphores)/sizeof(semaphores[0]),
+       "got wrong multi_wait_callbacks %u\n", multi_wait_callbacks);
+    ok(multi_wait_result >> 16, "expected multi_wait_result >> 16 != 0\n");
+
+    /* Add them all again, we want that the wait is pending while destroying it */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+        pTpSetWait(waits[i], semaphores[i], NULL);
+
+    /* Destroy the objects and semaphores */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        pTpReleaseWait(waits[i]);
+        NtClose(semaphores[i]);
+    }
+
+    pTpReleasePool(pool);
+}
+
 START_TEST(threadpool)
 {
     if (!init_threadpool())
@@ -919,4 +1212,6 @@ START_TEST(threadpool)
     test_tp_disassociate();
     test_tp_timer();
     test_tp_window_length();
+    test_tp_wait();
+    test_tp_multi_wait();
 }
-- 
2.4.4

