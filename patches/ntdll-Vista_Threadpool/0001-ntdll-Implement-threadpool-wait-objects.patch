From 102fb5ddc55779ac9c95937faef0cc063774612f Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 4 Mar 2015 13:33:25 +0100
Subject: ntdll: Implement threadpool wait objects.

---
 dlls/ntdll/ntdll.spec   |   4 +
 dlls/ntdll/threadpool.c | 474 +++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 471 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index ce9d1bb..75dc647 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -973,6 +973,7 @@
 @ stdcall TpAllocCleanupGroup(ptr)
 @ stdcall TpAllocPool(ptr ptr)
 @ stdcall TpAllocTimer(ptr ptr ptr ptr)
+@ stdcall TpAllocWait(ptr ptr ptr ptr)
 @ stdcall TpAllocWork(ptr ptr ptr ptr)
 @ stdcall TpCallbackLeaveCriticalSectionOnCompletion(ptr ptr)
 @ stdcall TpCallbackMayRunLong(ptr)
@@ -987,12 +988,15 @@
 @ stdcall TpReleaseCleanupGroupMembers(ptr long ptr)
 @ stdcall TpReleasePool(ptr)
 @ stdcall TpReleaseTimer(ptr)
+@ stdcall TpReleaseWait(ptr)
 @ stdcall TpReleaseWork(ptr)
 @ stdcall TpSetPoolMaxThreads(ptr long)
 @ stdcall TpSetPoolMinThreads(ptr long)
 @ stdcall TpSetTimer(ptr ptr long long)
+@ stdcall TpSetWait(ptr long ptr)
 @ stdcall TpSimpleTryPost(ptr ptr ptr)
 @ stdcall TpWaitForTimer(ptr long)
+@ stdcall TpWaitForWait(ptr long)
 @ stdcall TpWaitForWork(ptr long)
 @ stdcall -ret64 VerSetConditionMask(int64 long long)
 @ stdcall WinSqmIsOptedIn()
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index ef502ba..773c3d6 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -137,6 +137,7 @@ struct timer_queue
  */
 
 #define THREADPOOL_WORKER_TIMEOUT 5000
+#define MAXIMUM_WAITQUEUE_OBJECTS (MAXIMUM_WAIT_OBJECTS - 1)
 
 /* internal threadpool representation */
 struct threadpool
@@ -159,7 +160,8 @@ enum threadpool_objtype
 {
     TP_OBJECT_TYPE_SIMPLE,
     TP_OBJECT_TYPE_WORK,
-    TP_OBJECT_TYPE_TIMER
+    TP_OBJECT_TYPE_TIMER,
+    TP_OBJECT_TYPE_WAIT
 };
 
 /* internal threadpool object representation */
@@ -209,6 +211,17 @@ struct threadpool_object
             LONG            period;
             LONG            window_length;
         } timer;
+        struct
+        {
+            PTP_WAIT_CALLBACK callback;
+            LONG            signaled;
+            /* information about the wait, locked via waitqueue.cs */
+            struct waitqueue_bucket *bucket;
+            BOOL            wait_pending;
+            struct list     wait_entry;
+            ULONGLONG       timeout;
+            HANDLE          handle;
+        } wait;
     } u;
 };
 
@@ -267,6 +280,38 @@ static RTL_CRITICAL_SECTION_DEBUG timerqueue_debug =
       0, 0, { (DWORD_PTR)(__FILE__ ": timerqueue.cs") }
 };
 
+/* global waitqueue object */
+static RTL_CRITICAL_SECTION_DEBUG waitqueue_debug;
+
+static struct
+{
+    CRITICAL_SECTION        cs;
+    LONG                    num_buckets;
+    struct list             buckets;
+}
+waitqueue =
+{
+    { &waitqueue_debug, -1, 0, 0, 0, 0 },       /* cs */
+    0,                                          /* num_buckets */
+    LIST_INIT( waitqueue.buckets )              /* buckets */
+};
+
+static RTL_CRITICAL_SECTION_DEBUG waitqueue_debug =
+{
+    0, 0, &waitqueue.cs,
+    { &waitqueue_debug.ProcessLocksList, &waitqueue_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": waitqueue.cs") }
+};
+
+struct waitqueue_bucket
+{
+    struct list             bucket_entry;
+    LONG                    objcount;
+    struct list             reserved;
+    struct list             waits;
+    HANDLE                  update_event;
+};
+
 static inline struct threadpool *impl_from_TP_POOL( TP_POOL *pool )
 {
     return (struct threadpool *)pool;
@@ -286,6 +331,13 @@ static inline struct threadpool_object *impl_from_TP_TIMER( TP_TIMER *timer )
     return object;
 }
 
+static inline struct threadpool_object *impl_from_TP_WAIT( TP_WAIT *wait )
+{
+    struct threadpool_object *object = (struct threadpool_object *)wait;
+    assert( object->type == TP_OBJECT_TYPE_WAIT );
+    return object;
+}
+
 static inline struct threadpool_group *impl_from_TP_CLEANUP_GROUP( TP_CLEANUP_GROUP *group )
 {
     return (struct threadpool_group *)group;
@@ -297,7 +349,7 @@ static inline struct threadpool_instance *impl_from_TP_CALLBACK_INSTANCE( TP_CAL
 }
 
 static void CALLBACK threadpool_worker_proc( void *param );
-static void tp_object_submit( struct threadpool_object *object );
+static void tp_object_submit( struct threadpool_object *object, BOOL success );
 static void tp_object_shutdown( struct threadpool_object *object );
 static BOOL tp_object_release( struct threadpool_object *object );
 static struct threadpool *default_threadpool = NULL;
@@ -1249,7 +1301,7 @@ static void CALLBACK timerqueue_thread_proc( void *param )
             /* Queue a new callback in one of the worker threads. */
             list_remove( &timer->u.timer.timer_entry );
             timer->u.timer.timer_pending = FALSE;
-            tp_object_submit( timer );
+            tp_object_submit( timer, FALSE );
 
             /* Insert the timer back into the queue, except its marked for shutdown. */
             if (timer->u.timer.period && !timer->shutdown)
@@ -1386,6 +1438,255 @@ static void tp_timerqueue_unlock( struct threadpool_object *timer )
 }
 
 /***********************************************************************
+ *           waitqueue_thread_proc    (internal)
+ */
+static void CALLBACK waitqueue_thread_proc( void *param )
+{
+    struct threadpool_object *objects[MAXIMUM_WAITQUEUE_OBJECTS];
+    HANDLE handles[MAXIMUM_WAITQUEUE_OBJECTS + 1];
+    struct waitqueue_bucket *bucket = param;
+    struct threadpool_object *wait, *next;
+    LARGE_INTEGER now, timeout;
+    DWORD num_handles;
+    NTSTATUS status;
+
+    TRACE( "starting wait queue thread\n" );
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+
+    for (;;)
+    {
+        NtQuerySystemTime( &now );
+        timeout.QuadPart = TIMEOUT_INFINITE;
+        num_handles = 0;
+
+        /* Check for expired waits. */
+        LIST_FOR_EACH_ENTRY_SAFE( wait, next, &bucket->waits, struct threadpool_object, u.wait.wait_entry )
+        {
+            assert( wait->type == TP_OBJECT_TYPE_WAIT );
+            if (wait->u.wait.timeout <= now.QuadPart)
+            {
+                /* Wait expired. */
+                list_remove( &wait->u.wait.wait_entry );
+                list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                tp_object_submit( wait, FALSE );
+            }
+            else
+            {
+                if (wait->u.wait.timeout < timeout.QuadPart)
+                    timeout.QuadPart = wait->u.wait.timeout;
+
+                /* Prepare wait, keep a reference to make sure the object doesn't get destroyed. */
+                assert( num_handles < MAXIMUM_WAITQUEUE_OBJECTS );
+                interlocked_inc( &wait->refcount );
+                objects[num_handles] = wait;
+                handles[num_handles] = wait->u.wait.handle;
+                num_handles++;
+            }
+        }
+
+        if (!bucket->objcount)
+        {
+            /* All wait objects have been destroyed, if no new wait objects are created
+             * within some amount of time, then we can shutdown this thread. */
+            assert( num_handles == 0 );
+            RtlLeaveCriticalSection( &waitqueue.cs );
+            timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
+            status = NtWaitForMultipleObjects( 1, &bucket->update_event, TRUE, FALSE, &timeout );
+            RtlEnterCriticalSection( &waitqueue.cs );
+            if (status == STATUS_TIMEOUT && !bucket->objcount)
+                break;
+        }
+        else
+        {
+            /* Wait for a wait queue update event or until an event is triggered */
+            handles[num_handles] = bucket->update_event;
+            RtlLeaveCriticalSection( &waitqueue.cs );
+            status = NtWaitForMultipleObjects( num_handles + 1, handles, TRUE, FALSE, &timeout );
+            RtlEnterCriticalSection( &waitqueue.cs );
+
+            if (status >= STATUS_WAIT_0 && status < STATUS_WAIT_0 + num_handles)
+            {
+                wait = objects[status - STATUS_WAIT_0];
+                assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                if (wait->u.wait.bucket)
+                {
+                    /* Wait fulfilled. */
+                    assert( wait->u.wait.bucket == bucket );
+                    list_remove( &wait->u.wait.wait_entry );
+                    list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                    tp_object_submit( wait, TRUE );
+                }
+                else
+                    ERR("wait object %p triggered while object was destroyed\n", wait);
+            }
+        }
+
+        /* Release locked wait objects (if any). */
+        while (num_handles)
+        {
+            wait = objects[--num_handles];
+            assert( wait->type == TP_OBJECT_TYPE_WAIT );
+            tp_object_release( wait );
+        }
+
+        /* Try to merge with other threads. */
+        if (waitqueue.num_buckets > 1 && bucket->objcount &&
+            bucket->objcount < MAXIMUM_WAITQUEUE_OBJECTS / 2)
+        {
+            struct waitqueue_bucket *other_bucket;
+            LIST_FOR_EACH_ENTRY( other_bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
+            {
+                if (other_bucket != bucket && other_bucket->objcount &&
+                    other_bucket->objcount + bucket->objcount <= MAXIMUM_WAITQUEUE_OBJECTS)
+                {
+                    other_bucket->objcount += bucket->objcount;
+                    bucket->objcount = 0;
+
+                    /* Update reserved list. */
+                    LIST_FOR_EACH_ENTRY( wait, &bucket->reserved, struct threadpool_object, u.wait.wait_entry )
+                    {
+                        assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                        wait->u.wait.bucket = other_bucket;
+                    }
+                    list_move_tail( &other_bucket->reserved, &bucket->reserved );
+
+                    /* Update wait list. */
+                    LIST_FOR_EACH_ENTRY( wait, &bucket->waits, struct threadpool_object, u.wait.wait_entry )
+                    {
+                        assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                        wait->u.wait.bucket = other_bucket;
+                    }
+                    list_move_tail( &other_bucket->waits, &bucket->waits );
+
+                    /* Move bucket to the end to keep probability of
+                     * newly added wait objects as small as possible. */
+                    list_remove( &bucket->bucket_entry );
+                    list_add_tail( &waitqueue.buckets, &bucket->bucket_entry );
+
+                    NtSetEvent( other_bucket->update_event, NULL );
+                    break;
+                }
+            }
+        }
+    }
+
+    /* Remove this bucket from the list. */
+    list_remove( &bucket->bucket_entry );
+    if (!--waitqueue.num_buckets)
+        assert( list_empty( &waitqueue.buckets ) );
+
+    RtlLeaveCriticalSection( &waitqueue.cs );
+
+    TRACE( "terminating wait queue thread\n" );
+
+    assert( bucket->objcount == 0 );
+    assert( list_empty( &bucket->reserved ) );
+    assert( list_empty( &bucket->waits ) );
+
+    NtClose( bucket->update_event );
+    RtlFreeHeap( GetProcessHeap(), 0, bucket );
+}
+
+/***********************************************************************
+ *           tp_waitqueue_lock    (internal)
+ */
+static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
+{
+    struct waitqueue_bucket *bucket;
+    NTSTATUS status;
+    HANDLE thread;
+    assert( wait->type = TP_OBJECT_TYPE_WAIT );
+
+    wait->u.wait.signaled       = 0;
+    wait->u.wait.bucket         = NULL;
+    wait->u.wait.wait_pending   = FALSE;
+    wait->u.wait.timeout        = 0;
+    wait->u.wait.handle         = INVALID_HANDLE_VALUE;
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+
+    /* Try to assign to existing bucket if possible. */
+    LIST_FOR_EACH_ENTRY( bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
+    {
+        if (bucket->objcount < MAXIMUM_WAITQUEUE_OBJECTS)
+        {
+            list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+            wait->u.wait.bucket = bucket;
+            bucket->objcount++;
+
+            status = STATUS_SUCCESS;
+            goto out;
+        }
+    }
+
+    /* Create a new bucket and corresponding worker thread. */
+    bucket = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*bucket) );
+    if (!bucket)
+    {
+        status = STATUS_NO_MEMORY;
+        goto out;
+    }
+
+    bucket->objcount = 0;
+    list_init( &bucket->reserved );
+    list_init( &bucket->waits );
+
+    status = NtCreateEvent( &bucket->update_event, EVENT_ALL_ACCESS,
+                            NULL, SynchronizationEvent, FALSE );
+    if (status)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, bucket );
+        goto out;
+    }
+
+    status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                  waitqueue_thread_proc, bucket, &thread, NULL );
+    if (status == STATUS_SUCCESS)
+    {
+        list_add_tail( &waitqueue.buckets, &bucket->bucket_entry );
+        waitqueue.num_buckets++;
+
+        list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+        wait->u.wait.bucket = bucket;
+        bucket->objcount++;
+
+        NtClose( thread );
+    }
+    else
+    {
+        NtClose( bucket->update_event );
+        RtlFreeHeap( GetProcessHeap(), 0, bucket );
+    }
+
+out:
+    RtlLeaveCriticalSection( &waitqueue.cs );
+    return status;
+}
+
+/***********************************************************************
+ *           tp_waitqueue_unlock    (internal)
+ */
+static void tp_waitqueue_unlock( struct threadpool_object *wait )
+{
+    assert( wait->type == TP_OBJECT_TYPE_WAIT );
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+    if (wait->u.wait.bucket)
+    {
+        struct waitqueue_bucket *bucket = wait->u.wait.bucket;
+        assert( bucket->objcount > 0 );
+
+        list_remove( &wait->u.wait.wait_entry );
+        wait->u.wait.bucket = NULL;
+        bucket->objcount--;
+
+        NtSetEvent( bucket->update_event, NULL );
+    }
+    RtlLeaveCriticalSection( &waitqueue.cs );
+}
+
+/***********************************************************************
  *           tp_threadpool_alloc    (internal)
  *
  * Allocates a new threadpool object.
@@ -1654,7 +1955,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
      * will be set, and tp_object_submit would fail with an assertion. */
 
     if (is_simple_callback)
-        tp_object_submit( object );
+        tp_object_submit( object, FALSE );
 
     if (object->group)
     {
@@ -1680,7 +1981,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
  * Submits a threadpool object to the associcated threadpool. This
  * function has to be VOID because TpPostWork can never fail on Windows.
  */
-static void tp_object_submit( struct threadpool_object *object )
+static void tp_object_submit( struct threadpool_object *object, BOOL success )
 {
     struct threadpool *pool = object->pool;
     NTSTATUS status = STATUS_UNSUCCESSFUL;
@@ -1710,6 +2011,10 @@ static void tp_object_submit( struct threadpool_object *object )
     if (!object->num_pending_callbacks++)
         list_add_tail( &pool->pool, &object->pool_entry );
 
+    /* Remember how often the wait was fulfilled. */
+    if (object->type == TP_OBJECT_TYPE_WAIT && success)
+        object->u.wait.signaled++;
+
     /* No new thread started - wake up one existing thread. */
     if (status != STATUS_SUCCESS)
     {
@@ -1736,6 +2041,9 @@ static void tp_object_cancel( struct threadpool_object *object, BOOL group_cance
         pending_callbacks = object->num_pending_callbacks;
         object->num_pending_callbacks = 0;
         list_remove( &object->pool_entry );
+
+        if (object->type == TP_OBJECT_TYPE_WAIT)
+            object->u.wait.signaled = 0;
     }
     RtlLeaveCriticalSection( &pool->cs );
 
@@ -1785,6 +2093,8 @@ static void tp_object_shutdown( struct threadpool_object *object )
 {
     if (object->type == TP_OBJECT_TYPE_TIMER)
         tp_timerqueue_unlock( object );
+    else if (object->type == TP_OBJECT_TYPE_WAIT)
+        tp_waitqueue_unlock( object );
 
     object->shutdown = TRUE;
 }
@@ -1839,6 +2149,7 @@ static void CALLBACK threadpool_worker_proc( void *param )
     TP_CALLBACK_INSTANCE *callback_instance;
     struct threadpool_instance instance;
     struct threadpool *pool = param;
+    TP_WAIT_RESULT wait_result;
     LARGE_INTEGER timeout;
     struct list *ptr;
     NTSTATUS status;
@@ -1859,6 +2170,13 @@ static void CALLBACK threadpool_worker_proc( void *param )
             if (--object->num_pending_callbacks)
                 list_add_tail( &pool->pool, &object->pool_entry );
 
+            /* For wait objects determine if the operation was successful. */
+            if (object->type == TP_OBJECT_TYPE_WAIT)
+            {
+                wait_result = object->u.wait.signaled ? WAIT_OBJECT_0 : WAIT_TIMEOUT;
+                if (wait_result == WAIT_OBJECT_0) object->u.wait.signaled--;
+            }
+
             /* Leave critical section and do the actual callback. */
             object->num_associated_callbacks++;
             object->num_running_callbacks++;
@@ -1907,6 +2225,15 @@ static void CALLBACK threadpool_worker_proc( void *param )
                     break;
                 }
 
+                case TP_OBJECT_TYPE_WAIT:
+                {
+                    TRACE( "executing wait callback %p(%p, %p, %p, %u)\n",
+                           object->u.wait.callback, callback_instance, object->userdata, object, wait_result );
+                    object->u.wait.callback( callback_instance, object->userdata, (TP_WAIT *)object, wait_result );
+                    TRACE( "callback %p returned\n", object->u.wait.callback );
+                    break;
+                }
+
                 default:
                     assert(0);
                     break;
@@ -2052,6 +2379,46 @@ NTSTATUS WINAPI TpAllocTimer( TP_TIMER **out, PTP_TIMER_CALLBACK callback, PVOID
 }
 
 /***********************************************************************
+ *           TpAllocWait     (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID userdata,
+                             TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+    NTSTATUS status;
+
+    TRACE( "%p %p %p %p\n", out, callback, userdata, environment );
+
+    object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
+    if (!object)
+        return STATUS_NO_MEMORY;
+
+    status = tp_threadpool_lock( &pool, environment );
+    if (status)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, object );
+        return status;
+    }
+
+    object->type = TP_OBJECT_TYPE_WAIT;
+    object->u.wait.callback = callback;
+
+    status = tp_waitqueue_lock( object );
+    if (status)
+    {
+        tp_threadpool_unlock( pool );
+        RtlFreeHeap( GetProcessHeap(), 0, object );
+        return status;
+    }
+
+    tp_object_initialize( object, pool, userdata, environment );
+
+    *out = (TP_WAIT *)object;
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
  *           TpAllocWork    (NTDLL.@)
  */
 NTSTATUS WINAPI TpAllocWork( TP_WORK **out, PTP_WORK_CALLBACK callback, PVOID userdata,
@@ -2252,7 +2619,7 @@ VOID WINAPI TpPostWork( TP_WORK *work )
 
     TRACE( "%p\n", work );
 
-    tp_object_submit( this );
+    tp_object_submit( this, FALSE );
 }
 
 /***********************************************************************
@@ -2356,6 +2723,19 @@ VOID WINAPI TpReleaseTimer( TP_TIMER *timer )
 }
 
 /***********************************************************************
+ *           TpReleaseWait    (NTDLL.@)
+ */
+VOID WINAPI TpReleaseWait( TP_WAIT *wait )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+
+    TRACE( "%p\n", wait );
+
+    tp_object_shutdown( this );
+    tp_object_release( this );
+}
+
+/***********************************************************************
  *           TpReleaseWork    (NTDLL.@)
  */
 VOID WINAPI TpReleaseWork( TP_WORK *work )
@@ -2493,7 +2873,73 @@ VOID WINAPI TpSetTimer( TP_TIMER *timer, LARGE_INTEGER *timeout, LONG period, LO
     RtlLeaveCriticalSection( &timerqueue.cs );
 
     if (submit_timer)
-       tp_object_submit( this );
+       tp_object_submit( this, FALSE );
+}
+
+/***********************************************************************
+ *           TpSetWait    (KERNEL32.@)
+ */
+VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+    BOOL submit_wait = FALSE;
+
+    TRACE( "%p %p %p\n", wait, handle, timeout );
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+    assert( this->u.wait.bucket );
+
+    /* update wait handle */
+    this->u.wait.handle = handle;
+
+    /* for performance reasons we only wake up when something has changed */
+    if (handle || this->u.wait.wait_pending)
+    {
+        struct waitqueue_bucket *bucket = this->u.wait.bucket;
+        list_remove( &this->u.wait.wait_entry );
+
+        if (handle)
+        {
+            ULONGLONG when = TIMEOUT_INFINITE;
+
+            if (timeout)
+            {
+                when = timeout->QuadPart;
+
+                /* A timeout of zero means that the wait should be submitted immediately */
+                if (when == 0)
+                {
+                    submit_wait = TRUE;
+                    goto remove_wait;
+                }
+
+                /* Convert relative timeout to absolute */
+                if ((LONGLONG)when < 0)
+                {
+                    LARGE_INTEGER now;
+                    NtQuerySystemTime( &now );
+                    when = now.QuadPart - when;
+                }
+            }
+
+            list_add_tail( &bucket->waits, &this->u.wait.wait_entry );
+            this->u.wait.wait_pending = TRUE;
+            this->u.wait.timeout = when;
+        }
+        else
+        {
+remove_wait:
+            list_add_tail( &bucket->reserved, &this->u.wait.wait_entry );
+            this->u.wait.wait_pending = FALSE;
+        }
+
+        NtSetEvent( bucket->update_event, NULL );
+    }
+
+    RtlLeaveCriticalSection( &waitqueue.cs );
+
+    if (submit_wait)
+        tp_object_submit( this, FALSE );
 }
 
 /***********************************************************************
@@ -2541,6 +2987,20 @@ VOID WINAPI TpWaitForTimer( TP_TIMER *timer, BOOL cancel_pending )
 }
 
 /***********************************************************************
+ *           TpWaitForWait    (KERNEL32.@)
+ */
+VOID WINAPI TpWaitForWait( TP_WAIT *wait, BOOL cancel_pending )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+
+    TRACE( "%p %d\n", wait, cancel_pending );
+
+    if (cancel_pending)
+        tp_object_cancel( this, FALSE, NULL );
+    tp_object_wait( this, FALSE );
+}
+
+/***********************************************************************
  *           TpWaitForWork    (NTDLL.@)
  */
 VOID WINAPI TpWaitForWork( TP_WORK *work, BOOL cancel_pending )
-- 
2.4.4

