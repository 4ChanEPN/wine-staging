From c38bf17c8f87444feca7e4ce3508e55c581671e9 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 4 Mar 2015 07:40:02 +0100
Subject: ntdll: Implement various TpCallback*OnCompletion functions.

---
 dlls/ntdll/ntdll.spec   |   5 +++
 dlls/ntdll/threadpool.c | 110 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 115 insertions(+)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index f61728f..ee90705 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -973,7 +973,12 @@
 @ stdcall TpAllocCleanupGroup(ptr)
 @ stdcall TpAllocPool(ptr ptr)
 @ stdcall TpAllocWork(ptr ptr ptr ptr)
+@ stdcall TpCallbackLeaveCriticalSectionOnCompletion(ptr ptr)
 @ stdcall TpCallbackMayRunLong(ptr)
+@ stdcall TpCallbackReleaseMutexOnCompletion(ptr long)
+@ stdcall TpCallbackReleaseSemaphoreOnCompletion(ptr long long)
+@ stdcall TpCallbackSetEventOnCompletion(ptr long)
+@ stdcall TpCallbackUnloadDllOnCompletion(ptr ptr)
 @ stdcall TpDisassociateCallback(ptr)
 @ stdcall TpPostWork(ptr)
 @ stdcall TpReleaseCleanupGroup(ptr)
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 6bd3206..9874315 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -204,6 +204,15 @@ struct threadpool_instance
     DWORD                   threadid;
     BOOL                    disassociated;
     BOOL                    may_run_long;
+    struct
+    {
+        CRITICAL_SECTION    *critical_section;
+        HANDLE              mutex;
+        HANDLE              semaphore;
+        LONG                semaphore_count;
+        HANDLE              event;
+        HMODULE             library;
+    } cleanup;
 };
 
 /* internal threadpool group representation */
@@ -1604,6 +1613,7 @@ static void CALLBACK threadpool_worker_proc( void *param )
     struct threadpool *pool = param;
     LARGE_INTEGER timeout;
     struct list *ptr;
+    NTSTATUS status;
 
     TRACE( "starting worker thread for pool %p\n", pool );
 
@@ -1631,6 +1641,12 @@ static void CALLBACK threadpool_worker_proc( void *param )
             instance.threadid                   = GetCurrentThreadId();
             instance.disassociated              = FALSE;
             instance.may_run_long               = object->may_run_long;
+            instance.cleanup.critical_section   = NULL;
+            instance.cleanup.mutex              = NULL;
+            instance.cleanup.semaphore          = NULL;
+            instance.cleanup.semaphore_count    = 0;
+            instance.cleanup.event              = NULL;
+            instance.cleanup.library            = NULL;
 
             switch (object->type)
             {
@@ -1666,6 +1682,32 @@ static void CALLBACK threadpool_worker_proc( void *param )
                 TRACE( "callback %p returned\n", object->finalization_callback );
             }
 
+            /* Execute cleanup tasks. */
+            if (instance.cleanup.critical_section)
+            {
+                RtlLeaveCriticalSection( instance.cleanup.critical_section );
+            }
+            if (instance.cleanup.mutex)
+            {
+                status = NtReleaseMutant( instance.cleanup.mutex, NULL );
+                if (status != STATUS_SUCCESS) goto skip_cleanup;
+            }
+            if (instance.cleanup.semaphore)
+            {
+                status = NtReleaseSemaphore( instance.cleanup.semaphore, instance.cleanup.semaphore_count, NULL );
+                if (status != STATUS_SUCCESS) goto skip_cleanup;
+            }
+            if (instance.cleanup.event)
+            {
+                status = NtSetEvent( instance.cleanup.event, NULL );
+                if (status != STATUS_SUCCESS) goto skip_cleanup;
+            }
+            if (instance.cleanup.library)
+            {
+                LdrUnloadDll( instance.cleanup.library );
+            }
+
+        skip_cleanup:
             RtlEnterCriticalSection( &pool->cs );
             pool->num_busy_workers--;
             if (!instance.disassociated)
@@ -1757,6 +1799,19 @@ NTSTATUS WINAPI TpAllocWork( TP_WORK **out, PTP_WORK_CALLBACK callback, PVOID us
 }
 
 /***********************************************************************
+ *           TpCallbackLeaveCriticalSectionOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackLeaveCriticalSectionOnCompletion( TP_CALLBACK_INSTANCE *instance, CRITICAL_SECTION *crit )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+
+    TRACE( "%p %p\n", instance, crit );
+
+    if (!this->cleanup.critical_section)
+        this->cleanup.critical_section = crit;
+}
+
+/***********************************************************************
  *           TpCallbackMayRunLong    (NTDLL.@)
  */
 NTSTATUS WINAPI TpCallbackMayRunLong( TP_CALLBACK_INSTANCE *instance )
@@ -1801,6 +1856,61 @@ NTSTATUS WINAPI TpCallbackMayRunLong( TP_CALLBACK_INSTANCE *instance )
 }
 
 /***********************************************************************
+ *           TpCallbackReleaseMutexOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackReleaseMutexOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE mutex )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+
+    TRACE( "%p %p\n", instance, mutex );
+
+    if (!this->cleanup.mutex)
+        this->cleanup.mutex = mutex;
+}
+
+/***********************************************************************
+ *           TpCallbackReleaseSemaphoreOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackReleaseSemaphoreOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE semaphore, DWORD count )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+
+    TRACE( "%p %p %u\n", instance, semaphore, count );
+
+    if (!this->cleanup.semaphore)
+    {
+        this->cleanup.semaphore = semaphore;
+        this->cleanup.semaphore_count = count;
+    }
+}
+
+/***********************************************************************
+ *           TpCallbackSetEventOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackSetEventOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE event )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+
+    TRACE( "%p %p\n", instance, event );
+
+    if (!this->cleanup.event)
+        this->cleanup.event = event;
+}
+
+/***********************************************************************
+ *           TpCallbackUnloadDllOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackUnloadDllOnCompletion( TP_CALLBACK_INSTANCE *instance, HMODULE module )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+
+    TRACE( "%p %p\n", instance, module );
+
+    if (!this->cleanup.library)
+        this->cleanup.library = module;
+}
+
+/***********************************************************************
  *           TpDisassociateCallback    (NTDLL.@)
  */
 VOID WINAPI TpDisassociateCallback( TP_CALLBACK_INSTANCE *instance )
-- 
2.4.4

