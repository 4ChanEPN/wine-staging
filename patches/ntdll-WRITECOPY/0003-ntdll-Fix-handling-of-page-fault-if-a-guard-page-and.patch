From 9adae8afba3818e91532cc84cdfe350d27aa0434 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 4 Oct 2014 02:48:16 +0200
Subject: ntdll: Fix handling of page fault if a guard page and write watch is
 triggered at the same time.

---
 dlls/ntdll/virtual.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 4819d2d..f8a5dd3 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -1522,11 +1522,6 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err )
     {
         void *page = ROUND_ADDR( addr, page_mask );
         BYTE *vprot = &view->prot[((const char *)page - (const char *)view->base) >> page_shift];
-        if (*vprot & VPROT_GUARD)
-        {
-            VIRTUAL_SetProt( view, page, page_size, *vprot & ~VPROT_GUARD );
-            ret = STATUS_GUARD_PAGE_VIOLATION;
-        }
         if ((err & EXCEPTION_WRITE_FAULT) && (view->protect & VPROT_WRITEWATCH))
         {
             if (*vprot & VPROT_WRITEWATCH)
@@ -1537,6 +1532,11 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err )
             /* ignore fault if page is writable now */
             if (VIRTUAL_GetUnixProt( *vprot ) & PROT_WRITE) ret = STATUS_SUCCESS;
         }
+        if (*vprot & VPROT_GUARD)
+        {
+            VIRTUAL_SetProt( view, page, page_size, *vprot & ~VPROT_GUARD );
+            ret = STATUS_GUARD_PAGE_VIOLATION;
+        }
     }
     server_leave_uninterrupted_section( &csVirtual, &sigset );
     return ret;
-- 
2.1.1

