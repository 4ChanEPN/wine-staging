From 6bb4f8bfe058eef317a85875d9fc6bc8f7eb3252 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Tue, 25 Feb 2014 10:44:36 -0700
Subject: shell32: Set the default security attributes for user shell folders.

---
 dlls/shell32/shellpath.c |  106 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 105 insertions(+), 1 deletion(-)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index f92d56e..2aa010d 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -2200,6 +2200,82 @@ cleanup:
     return hr;
 }
 
+static BOOL alloc_sid( PSID src, PSID *dst )
+{
+    return AllocateAndInitializeSid(GetSidIdentifierAuthority(src), *GetSidSubAuthorityCount(src),
+                                    *GetSidSubAuthority(src, 0), *GetSidSubAuthority(src, 1),
+                                    *GetSidSubAuthority(src, 2), *GetSidSubAuthority(src, 3),
+                                    *GetSidSubAuthority(src, 4), *GetSidSubAuthority(src, 5),
+                                    *GetSidSubAuthority(src, 6), *GetSidSubAuthority(src, 7), dst);
+}
+
+static PSID get_user_sid( void )
+{
+    PSID ret = NULL, user_sid;
+    TOKEN_USER *user = NULL;
+    DWORD user_size = 0;
+    HANDLE token;
+
+    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &token))
+    {
+        if (GetLastError() != ERROR_NO_TOKEN) goto cleanup;
+        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &token)) goto cleanup;
+    }
+    GetTokenInformation(token, TokenUser, NULL, 0, &user_size);
+    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) goto cleanup;
+    if ((user = HeapAlloc(GetProcessHeap(), 0, user_size)) == NULL) goto cleanup;
+    if (!GetTokenInformation(token, TokenUser, user, user_size, &user_size)) goto cleanup;
+    user_sid = user->User.Sid;
+    alloc_sid(user_sid, &ret);
+
+cleanup:
+    HeapFree(GetProcessHeap(), 0, user);
+    CloseHandle(token);
+    return ret;
+}
+
+PSECURITY_DESCRIPTOR _SHGetUserSecurityDescriptor( void )
+{
+    PSECURITY_DESCRIPTOR sd = HeapAlloc(GetProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH);
+    PACL dacl = HeapAlloc(GetProcessHeap(), 0, 100);
+    PSID admin_sid = NULL, user_sid = NULL;
+    BOOL ret = FALSE;
+    DWORD sid_size;
+
+    if (!sd || !dacl) goto cleanup;
+
+    if ((user_sid = get_user_sid()) == NULL) goto cleanup;
+
+    /* find the administrator group SID */
+    sid_size = 0;
+    CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, NULL, &sid_size);
+    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) goto cleanup;
+    admin_sid = HeapAlloc(GetProcessHeap(), 0, sid_size);
+    if(!admin_sid) goto cleanup;
+    if(!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, admin_sid, &sid_size)) goto cleanup;
+
+    /* build the DACL */
+    if(!InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION)) goto cleanup;
+    if(!InitializeAcl(dacl, 100, ACL_REVISION)) goto cleanup;
+    if(!AddAccessAllowedAceEx(dacl, ACL_REVISION, OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE,
+                              GENERIC_ALL, user_sid)) goto cleanup;
+    if(!AddAccessAllowedAceEx(dacl, ACL_REVISION, OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE,
+                              GENERIC_ALL, admin_sid)) goto cleanup;
+    if(!SetSecurityDescriptorDacl(sd, TRUE, dacl, FALSE)) goto cleanup;
+    ret = TRUE;
+
+cleanup:
+    FreeSid(user_sid);
+    HeapFree(GetProcessHeap(), 0, admin_sid);
+    if(!ret)
+    {
+        HeapFree(GetProcessHeap(), 0, dacl);
+        HeapFree(GetProcessHeap(), 0, sd);
+        sd = NULL;
+    }
+    return sd;
+}
+
 /*************************************************************************
  * SHGetFolderPathAndSubDirW		[SHELL32.@]
  */
@@ -2211,6 +2287,8 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
 	LPCWSTR pszSubPath,/* [I] sub directory of the specified folder */
 	LPWSTR pszPath)    /* [O] converted path */
 {
+    SECURITY_ATTRIBUTES sa, *sec = NULL;
+    PSECURITY_DESCRIPTOR sd = NULL;
     HRESULT    hr;
     WCHAR      szBuildPath[MAX_PATH], szTemp[MAX_PATH];
     DWORD      folder = nFolder & CSIDL_FOLDER_MASK;
@@ -2323,8 +2401,25 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
         goto end;
     }
 
+    /* build the appropriate security attributes for the directory */
+    switch (type)
+    {
+        case CSIDL_Type_User:
+            sd = _SHGetUserSecurityDescriptor();
+            break;
+        default:
+            break;
+    }
+    if (sd)
+    {
+        sa.nLength = sizeof(sa);
+        sa.lpSecurityDescriptor = sd;
+        sa.bInheritHandle = TRUE;
+        sec = &sa;
+    }
+
     /* create directory/directories */
-    ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, NULL);
+    ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, sec);
     if (ret && ret != ERROR_ALREADY_EXISTS)
     {
         ERR("Failed to create directory %s.\n", debugstr_w(szBuildPath));
@@ -2334,6 +2429,15 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
 
     TRACE("Created missing system directory %s\n", debugstr_w(szBuildPath));
 end:
+    if (sd)
+    {
+        BOOL present, defaulted;
+        PACL dacl = NULL;
+
+        GetSecurityDescriptorDacl(sd, &present, &dacl, &defaulted);
+        HeapFree(GetProcessHeap(), 0, dacl);
+        HeapFree(GetProcessHeap(), 0, sd);
+    }
     TRACE("returning 0x%08x (final path is %s)\n", hr, debugstr_w(szBuildPath));
     return hr;
 }
-- 
1.7.9.5

