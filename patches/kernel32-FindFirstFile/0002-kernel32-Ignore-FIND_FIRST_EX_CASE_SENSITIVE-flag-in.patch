From 071f61cb5e78d5565e9bb0d28f61000423b46cd4 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 25 Sep 2014 03:08:19 +0200
Subject: kernel32: Ignore FIND_FIRST_EX_CASE_SENSITIVE flag in
 FindFirstFileExW.

---
 dlls/kernel32/file.c       |  9 ++++++++-
 dlls/kernel32/tests/file.c | 36 ++++++++++++++++++++++++------------
 2 files changed, 32 insertions(+), 13 deletions(-)

diff --git a/dlls/kernel32/file.c b/dlls/kernel32/file.c
index 2bd7a4e..dc4c9d5 100644
--- a/dlls/kernel32/file.c
+++ b/dlls/kernel32/file.c
@@ -1866,7 +1866,14 @@ HANDLE WINAPI FindFirstFileExW( LPCWSTR filename, FINDEX_INFO_LEVELS level,
     TRACE("%s %d %p %d %p %x\n", debugstr_w(filename), level, data, search_op, filter, flags);
 
     /* ignore FIND_FIRST_EX_LARGE_FETCH, only a hint for performance optimization */
-    flags &= ~FIND_FIRST_EX_LARGE_FETCH;
+
+    /* ignore FIND_FIRST_EX_CASE_SENSITIVE. Note: This is not completely correct.
+     * The correct solution would be to pass attr.Attributes = 0 to NtOpenFile. Nevertheless
+     * this doesn't match Windows behaviour. It seems to depend on the file system and special
+     * registry settings, if it has any effect or not. So just ignore it for now, since
+     * this is the way Windows behaves by default. */
+
+    flags &= ~(FIND_FIRST_EX_LARGE_FETCH | FIND_FIRST_EX_CASE_SENSITIVE);
 
     if ((search_op != FindExSearchNameMatch && search_op != FindExSearchLimitToDirectories)
 	|| flags != 0)
diff --git a/dlls/kernel32/tests/file.c b/dlls/kernel32/tests/file.c
index ddfa019..e6f96d4 100644
--- a/dlls/kernel32/tests/file.c
+++ b/dlls/kernel32/tests/file.c
@@ -2562,7 +2562,7 @@ static void test_FindNextFileA(void)
     ok ( err == ERROR_NO_MORE_FILES, "GetLastError should return ERROR_NO_MORE_FILES\n");
 }
 
-static void test_FindFirstFileExA(FINDEX_SEARCH_OPS search_ops)
+static void test_FindFirstFileExA(FINDEX_SEARCH_OPS search_ops, DWORD flags)
 {
     WIN32_FIND_DATAA search_results;
     HANDLE handle;
@@ -2578,8 +2578,9 @@ static void test_FindFirstFileExA(FINDEX_SEARCH_OPS search_ops)
     _lclose(_lcreat("test-dir\\file1", 0));
     _lclose(_lcreat("test-dir\\file2", 0));
     CreateDirectoryA("test-dir\\dir1", NULL);
+
     SetLastError(0xdeadbeef);
-    handle = pFindFirstFileExA("test-dir\\*", FindExInfoStandard, &search_results, search_ops, NULL, 0);
+    handle = pFindFirstFileExA("test-dir\\*", FindExInfoStandard, &search_results, search_ops, NULL, flags);
     if (handle == INVALID_HANDLE_VALUE && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
     {
         win_skip("FindFirstFileExA is not implemented\n");
@@ -2603,22 +2604,31 @@ static void test_FindFirstFileExA(FINDEX_SEARCH_OPS search_ops)
         skip("File system supports directory filtering\n");
         /* Results from the previous call are not cleared */
         ok(strcmp(search_results.cFileName, "dir1") == 0, "Third entry should be 'dir1' is %s\n", search_results.cFileName);
-        FindClose( handle );
-        goto cleanup;
     }
+    else
+    {
+        ok(ret, "Fetching fourth file failed\n");
+        ok(CHECK_NAME(search_results.cFileName), "Invalid fourth entry - %s\n", search_results.cFileName);
 
-    ok(ret, "Fetching fourth file failed\n");
-    ok(CHECK_NAME(search_results.cFileName), "Invalid fourth entry - %s\n", search_results.cFileName);
+        ok(FindNextFileA(handle, &search_results), "Fetching fifth file failed\n");
+        ok(CHECK_NAME(search_results.cFileName), "Invalid fifth entry - %s\n", search_results.cFileName);
 
-    ok(FindNextFileA(handle, &search_results), "Fetching fifth file failed\n");
-    ok(CHECK_NAME(search_results.cFileName), "Invalid fifth entry - %s\n", search_results.cFileName);
+        ok(FindNextFileA(handle, &search_results) == FALSE, "Fetching sixth file should fail\n");
+    }
 
 #undef CHECK_NAME
 
-    ok(FindNextFileA(handle, &search_results) == FALSE, "Fetching sixth file should fail\n");
-
     FindClose( handle );
 
+    /* The result of this tests depends on the Windows registry and the file system. On Wine we always simulate a system
+     * where case-insensitivity is enforced, so the following call will succeed. */
+    SetLastError(0xdeadbeef);
+    handle = pFindFirstFileExA("TEST-DIR\\*", FindExInfoStandard, &search_results, search_ops, NULL, flags);
+    ok(handle != INVALID_HANDLE_VALUE || (handle == INVALID_HANDLE_VALUE && GetLastError() == ERROR_PATH_NOT_FOUND),
+       "Unexpected error %x, expected valid handle or ERROR_PATH_NOT_FOUND\n", GetLastError());
+    if (handle != INVALID_HANDLE_VALUE)
+        FindClose( handle );
+
 cleanup:
     DeleteFileA("test-dir\\file1");
     DeleteFileA("test-dir\\file2");
@@ -4171,9 +4181,11 @@ START_TEST(file)
     test_MoveFileW();
     test_FindFirstFileA();
     test_FindNextFileA();
-    test_FindFirstFileExA(0);
+    test_FindFirstFileExA(0, 0);
+    test_FindFirstFileExA(0, FIND_FIRST_EX_CASE_SENSITIVE);
     /* FindExLimitToDirectories is ignored if the file system doesn't support directory filtering */
-    test_FindFirstFileExA(FindExSearchLimitToDirectories);
+    test_FindFirstFileExA(FindExSearchLimitToDirectories, 0);
+    test_FindFirstFileExA(FindExSearchLimitToDirectories, FIND_FIRST_EX_CASE_SENSITIVE);
     test_LockFile();
     test_file_sharing();
     test_offset_in_overlapped_structure();
-- 
2.1.0

