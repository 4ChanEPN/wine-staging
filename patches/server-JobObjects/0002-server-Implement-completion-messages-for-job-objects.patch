From 3babb8a2681bd530008b0d268cde0b5788177097 Mon Sep 17 00:00:00 2001
From: Andrew Cook <ariscop@gmail.com>
Date: Thu, 26 Feb 2015 13:02:36 +1100
Subject: server: Implement completion messages for job objects.

Fixes Wine bug #33723.

Various cleanups to fit with the rest of the wineserver
coding style by Sebastian Lackner <sebastian@fds-team.de>.
---
 dlls/kernel32/tests/process.c |  4 ----
 dlls/ntdll/sync.c             | 15 +++++++++++++++
 server/process.c              | 45 +++++++++++++++++++++++++++++++++++++++++++
 server/protocol.def           |  8 ++++++++
 4 files changed, 68 insertions(+), 4 deletions(-)

diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index 8c9a6ef..a86e331 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2399,7 +2399,6 @@ static void test_CompletionPort(void)
     port_info.CompletionKey = job;
     port_info.CompletionPort = port;
     ret = pSetInformationJobObject(job, JobObjectAssociateCompletionPortInformation, &port_info, sizeof(port_info));
-    todo_wine
     ok(ret, "SetInformationJobObject error %u\n", GetLastError());
 
     create_process("wait", &pi);
@@ -2407,16 +2406,13 @@ static void test_CompletionPort(void)
     ret = pAssignProcessToJobObject(job, pi.hProcess);
     ok(ret, "AssignProcessToJobObject error %u\n", GetLastError());
 
-    todo_wine
     test_completion(port, JOB_OBJECT_MSG_NEW_PROCESS, (DWORD_PTR)job, pi.dwProcessId, 0);
 
     TerminateProcess(pi.hProcess, 0);
     dwret = WaitForSingleObject(pi.hProcess, 1000);
     ok(dwret == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", dwret);
 
-    todo_wine
     test_completion(port, JOB_OBJECT_MSG_EXIT_PROCESS, (DWORD_PTR)job, pi.dwProcessId, 0);
-    todo_wine
     test_completion(port, JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO, (DWORD_PTR)job, 0, 100);
 
     CloseHandle(pi.hProcess);
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index e001e28..87ff3e0 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -694,6 +694,21 @@ NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS cla
         SERVER_END_REQ;
         break;
 
+    case JobObjectAssociateCompletionPortInformation:
+        if (len != sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT))
+            return STATUS_INVALID_PARAMETER;
+
+        SERVER_START_REQ( set_job_completion )
+        {
+            JOBOBJECT_ASSOCIATE_COMPLETION_PORT *port_info = info;
+            req->handle = wine_server_obj_handle( handle );
+            req->port   = wine_server_obj_handle( port_info->CompletionPort );
+            req->key    = wine_server_client_ptr( port_info->CompletionKey );
+            status = wine_server_call(req);
+        }
+        SERVER_END_REQ;
+        break;
+
     default:
         FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
         return STATUS_NOT_IMPLEMENTED;
diff --git a/server/process.c b/server/process.c
index a1ab8c7..10193ef 100644
--- a/server/process.c
+++ b/server/process.c
@@ -149,6 +149,9 @@ struct job
     struct list process_list;      /* list of all processes */
     int num_processes;             /* count of running processes */
     int limit_flags;               /* limit flags */
+    int terminating;               /* job is terminating */
+    struct completion *completion_port;
+    apc_param_t completion_key;
 };
 
 static const struct object_ops job_ops =
@@ -188,6 +191,9 @@ static struct job *create_job_object( struct directory *root, const struct unico
             list_init( &job->process_list );
             job->num_processes = 0;
             job->limit_flags = 0;
+            job->terminating = 0;
+            job->completion_port = NULL;
+            job->completion_key = 0;
         }
     }
     return job;
@@ -214,6 +220,12 @@ static unsigned int job_map_access( struct object *obj, unsigned int access )
     return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
 }
 
+static void add_job_completion( struct job *job, apc_param_t msg, apc_param_t pid )
+{
+    if (job->completion_port)
+        add_completion(job->completion_port, job->completion_key, pid, STATUS_SUCCESS, msg);
+}
+
 static void add_job_process( struct job *job, struct process *process )
 {
     if (!process->running_threads)
@@ -230,6 +242,8 @@ static void add_job_process( struct job *job, struct process *process )
     process->job = (struct job *)grab_object( job );
     list_add_tail( &job->process_list, &process->job_entry );
     job->num_processes++;
+
+    add_job_completion( job, JOB_OBJECT_MSG_NEW_PROCESS, get_process_id(process) );
 }
 
 /* called when a process has terminated, allow one additional process */
@@ -241,10 +255,20 @@ static void release_job_process( struct process *process )
 
     assert( job->num_processes );
     job->num_processes--;
+
+    if (!job->terminating)
+        add_job_completion( job, JOB_OBJECT_MSG_EXIT_PROCESS, get_process_id(process) );
+
+    if (!job->num_processes)
+        add_job_completion( job, JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO, 0 );
 }
 
 static void terminate_job( struct job *job, int exit_code )
 {
+    /* Windows doesn't report completion events for processes
+     * terminated by TerminateProcess, we do the same */
+    job->terminating = 1;
+
     for (;;)  /* restart from the beginning of the list every time */
     {
         struct process *process;
@@ -258,6 +282,8 @@ static void terminate_job( struct job *job, int exit_code )
         assert( process->job == job );
         terminate_process( process, NULL, exit_code );
     }
+
+    job->terminating = 0;
 }
 
 static void job_destroy( struct object *obj )
@@ -267,6 +293,9 @@ static void job_destroy( struct object *obj )
 
     assert( !job->num_processes );
     assert( list_empty(&job->process_list) );
+
+    if (job->completion_port)
+        release_object(job->completion_port);
 }
 
 static void job_dump( struct object *obj, int verbose )
@@ -1618,3 +1647,19 @@ DECL_HANDLER(set_job_limits)
         release_object( job );
     }
 }
+
+DECL_HANDLER(set_job_completion)
+{
+    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_SET_ATTRIBUTES );
+
+    if (job)
+    {
+        if (!job->completion_port)
+        {
+            job->completion_port = get_completion_obj( current->process, req->port, IO_COMPLETION_MODIFY_STATE );
+            job->completion_key = req->key;
+        }
+        else set_error( STATUS_INVALID_PARAMETER );
+        release_object( job );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index 0077aa4..c88c970 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3542,3 +3542,11 @@ enum coords_relative
     obj_handle_t handle;          /* handle to the job */
     unsigned int limit_flags;     /* limit flags */
 @END
+
+
+/* Set a job completion port/key */
+@REQ(set_job_completion)
+    obj_handle_t handle;          /* handle to the job */
+    obj_handle_t port;            /* completion port */
+    client_ptr_t key;             /* completion key */
+@END
-- 
2.3.3

