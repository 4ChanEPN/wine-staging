From f116e9e73f00bd6c65ebd087a1f7b23ceb9064a9 Mon Sep 17 00:00:00 2001
From: Andrew Cook <ariscop@gmail.com>
Date: Thu, 26 Feb 2015 12:25:23 +1100
Subject: server: Implement remaining wineserver calls for job objects.

---
 dlls/kernel32/tests/process.c |  6 +---
 dlls/ntdll/sync.c             | 76 +++++++++++++++++++++++++++++++++++++++----
 include/winnt.h               |  4 +++
 server/process.c              | 59 +++++++++++++++++++++++++++++++++
 server/process.h              |  1 +
 server/protocol.def           | 14 ++++++++
 6 files changed, 149 insertions(+), 11 deletions(-)

diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index 1add23d..8c9a6ef 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2269,13 +2269,11 @@ static void test_TerminateJobObject(void)
     ok(ret, "TerminateJobObject error %u\n", GetLastError());
 
     dwret = WaitForSingleObject(pi.hProcess, 1000);
-    todo_wine
     ok(dwret == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", dwret);
     if (dwret == WAIT_TIMEOUT) TerminateProcess(pi.hProcess, 0);
 
     ret = GetExitCodeProcess(pi.hProcess, &dwret);
     ok(ret, "GetExitCodeProcess error %u\n", GetLastError());
-    todo_wine
     ok(dwret == 123 || broken(dwret == 0) /* randomly fails on Win 2000 / XP */,
        "wrong exitcode %u\n", dwret);
 
@@ -2401,6 +2399,7 @@ static void test_CompletionPort(void)
     port_info.CompletionKey = job;
     port_info.CompletionPort = port;
     ret = pSetInformationJobObject(job, JobObjectAssociateCompletionPortInformation, &port_info, sizeof(port_info));
+    todo_wine
     ok(ret, "SetInformationJobObject error %u\n", GetLastError());
 
     create_process("wait", &pi);
@@ -2498,7 +2497,6 @@ static void test_jobInheritance(HANDLE job)
     out = FALSE;
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %u\n", GetLastError());
-    todo_wine
     ok(out, "IsProcessInJob returned out=%u\n", out);
 
     dwret = WaitForSingleObject(pi.hProcess, 1000);
@@ -2526,9 +2524,7 @@ static void test_BreakawayOk(HANDLE job)
     snprintf(buffer, MAX_PATH, "\"%s\" tests/process.c %s", selfname, "exit");
 
     ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, &si, &pi);
-    todo_wine
     ok(!ret, "CreateProcessA expected failure\n");
-    todo_wine
     expect_eq_d(ERROR_ACCESS_DENIED, GetLastError());
 
     if (ret)
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index ce1a635..e001e28 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -56,6 +56,7 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "winnt.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -613,8 +614,19 @@ NTSTATUS WINAPI NtOpenJobObject( PHANDLE handle, ACCESS_MASK access, const OBJEC
  */
 NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 {
-    FIXME( "stub: %p %x\n", handle, status );
-    return STATUS_SUCCESS;
+    NTSTATUS ret;
+
+    TRACE( "(%p, %d)\n", handle, status );
+
+    SERVER_START_REQ( terminate_job )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->status = status;
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
 }
 
 /******************************************************************************
@@ -624,8 +636,17 @@ NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info,
                                              ULONG len, PULONG ret_len )
 {
-    FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
-    return STATUS_NOT_IMPLEMENTED;
+    TRACE( "%p %u %p %u %p\n", handle, class, info, len, ret_len );
+
+    if (class >= MaxJobObjectInfoClass)
+        return STATUS_INVALID_PARAMETER;
+
+    switch (class)
+    {
+    default:
+        FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
+        return STATUS_NOT_IMPLEMENTED;
+    }
 }
 
 /******************************************************************************
@@ -634,8 +655,51 @@ NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS c
  */
 NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info, ULONG len )
 {
-    FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
-    return STATUS_SUCCESS;
+    JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    TRACE( "(%p, %u, %p, %u)\n", handle, class, info, len );
+
+    if (class >= MaxJobObjectInfoClass)
+        return STATUS_INVALID_PARAMETER;
+
+    switch (class)
+    {
+
+    case JobObjectExtendedLimitInformation:
+        if (len != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION))
+            return STATUS_INVALID_PARAMETER;
+
+        basic_limit = &(((JOBOBJECT_EXTENDED_LIMIT_INFORMATION *)info)->BasicLimitInformation);
+        if (basic_limit->LimitFlags & ~JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS)
+            return STATUS_INVALID_PARAMETER;
+
+        goto set_basic_limits;
+
+    case JobObjectBasicLimitInformation:
+        if (len != sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION))
+            return STATUS_INVALID_PARAMETER;
+
+        basic_limit = info;
+        if (basic_limit->LimitFlags & ~JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS)
+            return STATUS_INVALID_PARAMETER;
+
+    set_basic_limits:
+        SERVER_START_REQ( set_job_limits )
+        {
+            req->handle      = wine_server_obj_handle( handle );
+            req->limit_flags = basic_limit->LimitFlags;
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        break;
+
+    default:
+        FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    return status;
 }
 
 /******************************************************************************
diff --git a/include/winnt.h b/include/winnt.h
index 4b06b2c..c2aa50e 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -5610,6 +5610,10 @@ typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
 #define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          0x00002000
 #define JOB_OBJECT_LIMIT_SUBSET_AFFINITY            0x00004000
 
+#define JOB_OBJECT_LIMIT_VALID_FLAGS                0x0007ffff
+#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS          0x000000ff
+#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS       0x00007fff
+
 typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
 {
     RelationProcessorCore    = 0,
diff --git a/server/process.c b/server/process.c
index f9738c0..a1ab8c7 100644
--- a/server/process.c
+++ b/server/process.c
@@ -65,6 +65,7 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static void process_destroy( struct object *obj );
+static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
 {
@@ -147,6 +148,7 @@ struct job
     struct object obj;             /* object header */
     struct list process_list;      /* list of all processes */
     int num_processes;             /* count of running processes */
+    int limit_flags;               /* limit flags */
 };
 
 static const struct object_ops job_ops =
@@ -185,6 +187,7 @@ static struct job *create_job_object( struct directory *root, const struct unico
                                                    SACL_SECURITY_INFORMATION );
             list_init( &job->process_list );
             job->num_processes = 0;
+            job->limit_flags = 0;
         }
     }
     return job;
@@ -223,6 +226,7 @@ static void add_job_process( struct job *job, struct process *process )
         set_error( STATUS_ACCESS_DENIED );
         return;
     }
+
     process->job = (struct job *)grab_object( job );
     list_add_tail( &job->process_list, &process->job_entry );
     job->num_processes++;
@@ -239,6 +243,23 @@ static void release_job_process( struct process *process )
     job->num_processes--;
 }
 
+static void terminate_job( struct job *job, int exit_code )
+{
+    for (;;)  /* restart from the beginning of the list every time */
+    {
+        struct process *process;
+
+        /* find the first process associcated with this job and still running */
+        LIST_FOR_EACH_ENTRY( process, &job->process_list, struct process, job_entry )
+        {
+            if (process->running_threads) break;
+        }
+        if (&process->job_entry == &job->process_list) break;  /* no process found */
+        assert( process->job == job );
+        terminate_process( process, NULL, exit_code );
+    }
+}
+
 static void job_destroy( struct object *obj )
 {
     struct job *job = (struct job *)obj;
@@ -1087,6 +1108,14 @@ DECL_HANDLER(new_process)
         return;
     }
 
+    if (parent->job && (req->create_flags & CREATE_BREAKAWAY_FROM_JOB) &&
+        !(parent->job->limit_flags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK | JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        close( socket_fd );
+        return;
+    }
+
     if (!req->info_size)  /* create an orphaned process */
     {
         create_process( socket_fd, NULL, 0 );
@@ -1157,6 +1186,12 @@ DECL_HANDLER(new_process)
         && !(req->create_flags & DEBUG_ONLY_THIS_PROCESS);
     process->startup_info = (struct startup_info *)grab_object( info );
 
+    if (parent->job && !((req->create_flags & CREATE_BREAKAWAY_FROM_JOB) ||
+        (parent->job->limit_flags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
+    {
+        add_job_process( parent->job, process );
+    }
+
     /* connect to the window station */
     connect_process_winstation( process, current );
 
@@ -1559,3 +1594,27 @@ DECL_HANDLER(process_in_job)
     }
     release_object( process );
 }
+
+/* terminate all processes associated with the job */
+DECL_HANDLER(terminate_job)
+{
+    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_TERMINATE );
+
+    if (job)
+    {
+        terminate_job( job, req->status );
+        release_object( job );
+    }
+}
+
+/* update limits of the job object */
+DECL_HANDLER(set_job_limits)
+{
+    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_SET_ATTRIBUTES );
+
+    if (job)
+    {
+        job->limit_flags = req->limit_flags;
+        release_object( job );
+    }
+}
diff --git a/server/process.h b/server/process.h
index 0cf9514..ae83b0e 100644
--- a/server/process.h
+++ b/server/process.h
@@ -26,6 +26,7 @@
 struct atom_table;
 struct handle_table;
 struct startup_info;
+struct job;
 
 /* process startup state */
 enum startup_state { STARTUP_IN_PROGRESS, STARTUP_DONE, STARTUP_ABORTED };
diff --git a/server/protocol.def b/server/protocol.def
index b85adca..0077aa4 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3528,3 +3528,17 @@ enum coords_relative
     obj_handle_t job;             /* handle to the job */
     obj_handle_t process;         /* handle to the process */
 @END
+
+
+/* Terminate all processes associated with the job  */
+@REQ(terminate_job)
+    obj_handle_t handle;          /* handle to the job */
+    int          status;          /* exitcode of the process */
+@END
+
+
+/* Update limits of the job object */
+@REQ(set_job_limits)
+    obj_handle_t handle;          /* handle to the job */
+    unsigned int limit_flags;     /* limit flags */
+@END
-- 
2.3.3

