From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

diff --git a/dlls/d3d8/tests/visual.c b/dlls/d3d8/tests/visual.c
--- a/dlls/d3d8/tests/visual.c
+++ b/dlls/d3d8/tests/visual.c
@@ -5480,7 +5480,11 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
     todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
+    ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1336,7 +1336,11 @@ static void color_fill_test(void)
          * result on Wine.
          * {D3DFMT_YUY2,     "D3DFMT_YUY2",     BLOCKS,                              0},
          * {D3DFMT_UYVY,     "D3DFMT_UYVY",     BLOCKS,                              0}, */
+#if defined(STAGING_CSMT)
         {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS,                              0},
+#else  /* STAGING_CSMT */
+        {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS | TODO_FILL_RETURN,           0},
+#endif /* STAGING_CSMT */
         /* Vendor-specific formats like ATI2N are a non-issue here since they're not
          * supported as offscreen plain surfaces and do not support D3DUSAGE_RENDERTARGET
          * when created as texture. */
@@ -17615,7 +17619,11 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
     todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
+    ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -704,7 +704,11 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
+#if defined(STAGING_CSMT)
         UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
+        UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constants_f(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -729,12 +733,14 @@ static void shader_arb_update_float_vertex_constants(struct wined3d_device *devi
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
     unsigned int i;
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
     }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -748,12 +754,14 @@ static void shader_arb_update_float_pixel_constants(struct wined3d_device *devic
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
     unsigned int i;
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
     }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -4732,7 +4740,11 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
+#if defined(STAGING_CSMT)
             UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
+            UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -8024,11 +8036,16 @@ static void arbfp_blit_surface(struct wined3d_device *device, enum wined3d_blit_
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         context->gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain
             && (dst_texture->swapchain->front_buffer == dst_texture)))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain && (dst_texture->swapchain->front_buffer == dst_texture)))
+#endif /* STAGING_CSMT */
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,7 +32,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_USE_BO       0x02    /* Use a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
+#if defined(STAGING_CSMT)
 #define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#else  /* STAGING_CSMT */
+#define WINED3D_BUFFER_DISCARD      0x08    /* A DISCARD lock has occurred since the last preload. */
+#endif /* STAGING_CSMT */
 #define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
 #define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
 
@@ -41,7 +45,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
+#if defined(STAGING_CSMT)
 void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#else  /* STAGING_CSMT */
+static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#endif /* STAGING_CSMT */
 {
     if (!offset && (!size || size == buffer->resource.size))
         goto invalidate_all;
@@ -122,7 +130,11 @@ static void delete_gl_buffer(struct wined3d_buffer *This, const struct wined3d_g
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -194,10 +206,14 @@ void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_con
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+#if defined(STAGING_CSMT)
     {
         wined3d_resource_free_sysmem(&This->resource);
         This->resource.map_heap_memory = NULL;
     }
+#else  /* STAGING_CSMT */
+        wined3d_resource_free_sysmem(&This->resource);
+#endif /* STAGING_CSMT */
 
     return;
 
@@ -461,8 +477,12 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
+#if defined(STAGING_CSMT)
         if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
                 && buffer->flags & WINED3D_BUFFER_USE_BO)
+#else  /* STAGING_CSMT */
+        if ((buffer->flags & WINED3D_BUFFER_USE_BO) && !buffer->resource.map_count)
+#endif /* STAGING_CSMT */
         {
             buffer_create_buffer_object(buffer, context);
             if (buffer->buffer_object)
@@ -500,7 +520,9 @@ BYTE *buffer_get_sysmem(struct wined3d_buffer *buffer, struct wined3d_context *c
 
     if (!wined3d_resource_allocate_sysmem(&buffer->resource))
         ERR("Failed to allocate system memory.\n");
+#if defined(STAGING_CSMT)
     buffer->resource.heap_memory = buffer->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
 
     buffer_bind(buffer, context);
     GL_EXTCALL(glGetBufferSubData(buffer->buffer_type_hint, 0, buffer->resource.size, buffer->resource.heap_memory));
@@ -561,6 +583,7 @@ static void wined3d_buffer_drop_bo(struct wined3d_buffer *buffer)
         device_invalidate_state(device, STATE_STREAMSRC);
 }
 
+#if defined(STAGING_CSMT)
 static void wined3d_buffer_destroy_object(void *object)
 {
     struct wined3d_buffer *buffer = object;
@@ -594,6 +617,30 @@ ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
 
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
         wined3d_cs_emit_destroy_object(device->cs, wined3d_buffer_destroy_object, buffer);
+#else  /* STAGING_CSMT */
+ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
+{
+    ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
+    struct wined3d_context *context;
+
+    TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
+
+    if (!refcount)
+    {
+        if (buffer->buffer_object)
+        {
+            context = context_acquire(buffer->resource.device, NULL);
+            delete_gl_buffer(buffer, context->gl_info);
+            context_release(context);
+
+            HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+        }
+
+        resource_cleanup(&buffer->resource);
+        buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
+        HeapFree(GetProcessHeap(), 0, buffer->maps);
+        HeapFree(GetProcessHeap(), 0, buffer);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -678,6 +725,7 @@ drop_query:
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
+#if defined(STAGING_CSMT)
     UINT start = 0, len = 0;
 
     /* This potentially invalidates the element array buffer binding, but the
@@ -701,6 +749,45 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
         checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
         This->flags &= ~WINED3D_BUFFER_APPLESYNC;
+#else  /* STAGING_CSMT */
+    BYTE *map;
+    UINT start, len;
+
+    /* This potentially invalidates the element array buffer binding, but the
+     * caller always takes care of this. */
+    GL_EXTCALL(glBindBuffer(This->buffer_type_hint, This->buffer_object));
+    checkGLcall("glBindBuffer");
+    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+    {
+        GLbitfield mapflags;
+        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
+        if (flags & WINED3D_BUFFER_DISCARD)
+            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
+        else if (!(flags & WINED3D_BUFFER_SYNC))
+            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
+        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
+                    This->resource.size, mapflags));
+        checkGLcall("glMapBufferRange");
+    }
+    else
+    {
+        if (This->flags & WINED3D_BUFFER_APPLESYNC)
+        {
+            DWORD syncflags = 0;
+            if (flags & WINED3D_BUFFER_DISCARD)
+                syncflags |= WINED3D_MAP_DISCARD;
+            else if (!(flags & WINED3D_BUFFER_SYNC))
+                syncflags |= WINED3D_MAP_NOOVERWRITE;
+            buffer_sync_apple(This, syncflags, gl_info);
+        }
+        map = GL_EXTCALL(glMapBuffer(This->buffer_type_hint, GL_WRITE_ONLY));
+        checkGLcall("glMapBuffer");
+    }
+    if (!map)
+    {
+        ERR("Failed to map opengl buffer\n");
+        return;
+#endif /* STAGING_CSMT */
     }
 
     while (This->modified_areas)
@@ -709,12 +796,33 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glBufferSubData(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
         checkGLcall("glBufferSubData");
     }
 }
 
 static void buffer_mark_used(struct wined3d_buffer *buffer)
+#else  /* STAGING_CSMT */
+        memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
+
+        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+        {
+            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
+            checkGLcall("glFlushMappedBufferRange");
+        }
+        else if (This->flags & WINED3D_BUFFER_APPLESYNC)
+        {
+            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
+            checkGLcall("glFlushMappedBufferRangeAPPLE");
+        }
+    }
+    GL_EXTCALL(glUnmapBuffer(This->buffer_type_hint));
+    checkGLcall("glUnmapBuffer");
+}
+
+void buffer_mark_used(struct wined3d_buffer *buffer)
+#endif /* STAGING_CSMT */
 {
     buffer->flags &= ~(WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -733,6 +841,14 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
     TRACE("buffer %p.\n", buffer);
 
+#if !defined(STAGING_CSMT)
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+#endif /* STAGING_CSMT */
     buffer_mark_used(buffer);
 
     if (!buffer->buffer_object)
@@ -908,6 +1024,7 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = buffer->resource.device;
 
     if (buffer->resource.map_count)
@@ -917,6 +1034,12 @@ void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
     }
 
     wined3d_cs_emit_buffer_preload(device->cs, buffer);
+#else  /* STAGING_CSMT */
+    struct wined3d_context *context;
+    context = context_acquire(buffer->resource.device, NULL);
+    buffer_internal_preload(buffer, context, NULL);
+    context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -930,6 +1053,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
 {
     LONG count;
     BYTE *base;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = buffer->resource.device;
     struct wined3d_context *context;
 
@@ -953,6 +1077,10 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
     {
         wined3d_cs_emit_create_vbo(device->cs, buffer);
     }
+#else  /* STAGING_CSMT */
+
+    TRACE("buffer %p, offset %u, size %u, data %p, flags %#x.\n", buffer, offset, size, data, flags);
+#endif /* STAGING_CSMT */
 
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
@@ -961,7 +1089,11 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
+#if defined(STAGING_CSMT)
     if (buffer->ignore_discard)
+#else  /* STAGING_CSMT */
+    if (buffer->flags & WINED3D_BUFFER_DISCARD)
+#endif /* STAGING_CSMT */
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -972,6 +1104,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
+#if defined(STAGING_CSMT)
             wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
             wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
@@ -989,6 +1122,19 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                     wined3d_cs_emit_glfinish(device->cs);
                     device->cs->ops->finish(device->cs);
                 }
+#else  /* STAGING_CSMT */
+            buffer_invalidate_bo_range(buffer, 0, 0);
+        else if (!(flags & WINED3D_MAP_READONLY))
+            buffer_invalidate_bo_range(buffer, offset, size);
+
+        if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
+        {
+            if (count == 1)
+            {
+                struct wined3d_device *device = buffer->resource.device;
+                struct wined3d_context *context;
+                const struct wined3d_gl_info *gl_info;
+#endif /* STAGING_CSMT */
 
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
@@ -1034,6 +1180,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                         buffer_get_sysmem(buffer, context);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
+#if defined(STAGING_CSMT)
                 }
                 context_release(context);
             }
@@ -1073,6 +1220,21 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
     }
 
     base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
+#else  /* STAGING_CSMT */
+                    buffer->map_ptr = NULL;
+                }
+                context_release(context);
+            }
+        }
+
+        if (flags & WINED3D_MAP_DISCARD)
+            buffer->flags |= WINED3D_BUFFER_DISCARD;
+        else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+            buffer->flags |= WINED3D_BUFFER_SYNC;
+    }
+
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+#endif /* STAGING_CSMT */
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1135,6 +1297,7 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
         }
 
         GL_EXTCALL(glUnmapBuffer(buffer->buffer_type_hint));
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
@@ -1143,6 +1306,18 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
 
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+            gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+        context_release(context);
+
+        buffer_clear_dirty_areas(buffer);
+        buffer->map_ptr = NULL;
+    }
+    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
+    {
+        wined3d_buffer_preload(buffer);
+#endif /* STAGING_CSMT */
     }
 }
 
@@ -1335,7 +1510,9 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+#if defined(STAGING_CSMT)
     buffer->ignore_discard = TRUE;
+#endif /* STAGING_CSMT */
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1371,6 +1548,7 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         buffer->flags |= WINED3D_BUFFER_USE_BO;
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
 
@@ -1381,6 +1559,13 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         resource_cleanup(&buffer->resource);
         if (wined3d_settings.cs_multithreaded)
             buffer->resource.device->cs->ops->finish(buffer->resource.device->cs);
+#else  /* STAGING_CSMT */
+    if (!(buffer->maps = HeapAlloc(GetProcessHeap(), 0, sizeof(*buffer->maps))))
+    {
+        ERR("Out of memory.\n");
+        buffer_unload(&buffer->resource);
+        resource_cleanup(&buffer->resource);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
     buffer->maps_size = 1;
@@ -1391,8 +1576,10 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         buffer_unload(&buffer->resource);
         resource_cleanup(&buffer->resource);
         HeapFree(GetProcessHeap(), 0, buffer->maps);
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             buffer->resource.device->cs->ops->finish(buffer->resource.device->cs);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -1503,6 +1690,7 @@ HRESULT CDECL wined3d_buffer_create_ib(struct wined3d_device *device, UINT size,
 
     return WINED3D_OK;
 }
+#if defined(STAGING_CSMT)
 
 void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
 {
@@ -1510,3 +1698,4 @@ void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
     buffer->resource.heap_memory = mem;
     buffer->flags |= WINED3D_BUFFER_DISCARD;
 }
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1699,11 +1699,13 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+#if defined(STAGING_CSMT)
     ret->current_fb.rt_size = gl_info->limits.buffers;
     if (!(ret->current_fb.render_targets = wined3d_calloc(ret->current_fb.rt_size,
             sizeof(*ret->current_fb.render_targets))))
         goto out;
 
+#endif /* STAGING_CSMT */
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -2009,7 +2011,9 @@ out:
     if (hdc) wined3d_release_dc(swapchain->win_handle, hdc);
     device->shader_backend->shader_free_context_data(ret);
     device->adapter->fragment_pipe->free_context_data(ret);
+#if defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -2046,7 +2050,9 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     device->shader_backend->shader_free_context_data(context);
     device->adapter->fragment_pipe->free_context_data(context);
     HeapFree(GetProcessHeap(), 0, context->fbo_key);
+#if defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2462,6 +2468,9 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
 {
     /* Onscreen surfaces are always in a swapchain */
     struct wined3d_swapchain *swapchain = context->current_rt.texture->swapchain;
+#if !defined(STAGING_CSMT)
+    struct wined3d_surface *surface;
+#endif /* STAGING_CSMT */
 
     if (context->render_offscreen || !depth_stencil) return;
     if (match_depth_stencil_format(swapchain->ds_format, depth_stencil->format)) return;
@@ -2472,8 +2481,13 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(context->current_rt.texture, context->current_rt.sub_resource_idx,
             context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    surface = context->current_rt.texture->sub_resources[context->current_rt.sub_resource_idx].u.surface;
+    surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
@@ -2574,7 +2588,11 @@ static BOOL context_validate_rt_config(UINT rt_count, struct wined3d_rendertarge
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb)
 {
     struct wined3d_rendertarget_view **rts = fb->render_targets;
@@ -2583,7 +2601,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context,
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
+#if defined(STAGING_CSMT)
     if (isStateDirty(context, STATE_FRAMEBUFFER) || wined3d_fb_equal(fb, &context->current_fb)
+#else  /* STAGING_CSMT */
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != state->fb
+#endif /* STAGING_CSMT */
             || rt_count != gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, dsv))
@@ -2628,8 +2650,10 @@ BOOL context_apply_clear_state(struct wined3d_context *context,
             rt_mask = context_generate_rt_mask_no_fbo(context,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0])->container : NULL);
         }
+#if defined(STAGING_CSMT)
 
         wined3d_fb_copy(&context->current_fb, fb);
+#endif /* STAGING_CSMT */
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2670,8 +2694,12 @@ BOOL context_apply_clear_state(struct wined3d_context *context,
     gl_info->gl_ops.gl.p_glEnable(GL_SCISSOR_TEST);
     if (rt_count && gl_info->supported[ARB_FRAMEBUFFER_SRGB])
     {
+#if defined(STAGING_CSMT)
         /* FIXME: The way to access the state is ugly. */
         if (needs_srgb_write(context, &rts[0]->resource->device->cs->state, fb))
+#else  /* STAGING_CSMT */
+        if (needs_srgb_write(context, state, fb))
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
         else
             gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
@@ -2688,7 +2716,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context,
 
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view **rts = state->fb.render_targets;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view **rts = state->fb->render_targets;
+#endif /* STAGING_CSMT */
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
@@ -2718,7 +2750,11 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     DWORD rt_mask = find_draw_buffers_mask(context, state);
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2749,8 +2785,10 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+#if defined(STAGING_CSMT)
 
     wined3d_fb_copy(&context->current_fb, &state->fb);
+#endif /* STAGING_CSMT */
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -3382,7 +3420,11 @@ BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state)
 {
     const struct StateEntry *state_table = context->state_table;
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     unsigned int i;
     WORD map;
 
@@ -3415,12 +3457,17 @@ BOOL context_apply_draw_state(struct wined3d_context *context,
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
+#if defined(STAGING_CSMT)
                 buffer_internal_preload(state->streams[context->stream_info.elements[i].stream_idx].buffer,
                         context, state);
         }
         /* PreLoad may kick buffers out of vram. */
         if (isStateDirty(context, STATE_STREAMSRC))
             context_update_stream_info(context, state);
+#else  /* STAGING_CSMT */
+                buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
+        }
+#endif /* STAGING_CSMT */
     }
     if (state->index_buffer)
     {
@@ -3539,9 +3586,11 @@ struct wined3d_context *context_acquire(const struct wined3d_device *device, str
 
     TRACE("device %p, target %p.\n", device, target);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded && device->cs->thread_id != GetCurrentThreadId())
         FIXME("Acquiring a GL context from outside the CS thread.\n");
 
+#endif /* STAGING_CSMT */
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,11 +22,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
+#if defined(STAGING_CSMT)
 enum wined3d_cs_op
 {
     WINED3D_CS_OP_NOP,
     WINED3D_CS_OP_SKIP,
     WINED3D_CS_OP_FENCE,
+#else  /* STAGING_CSMT */
+#define WINED3D_INITIAL_CS_SIZE 4096
+
+enum wined3d_cs_op
+{
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -54,6 +61,7 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
     WINED3D_CS_OP_DESTROY_OBJECT,
+#if defined(STAGING_CSMT)
     WINED3D_CS_OP_SET_VS_CONSTS_F,
     WINED3D_CS_OP_SET_VS_CONSTS_B,
     WINED3D_CS_OP_SET_VS_CONSTS_I,
@@ -99,6 +107,7 @@ struct wined3d_cs_fence
 {
     enum wined3d_cs_op opcode;
     BOOL *signalled;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -306,6 +315,7 @@ struct wined3d_cs_destroy_object
     void *object;
 };
 
+#if defined(STAGING_CSMT)
 struct wined3d_cs_set_consts_f
 {
     enum wined3d_cs_op opcode;
@@ -612,6 +622,23 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
     struct wined3d_cs_present *op;
     LONG pending;
     unsigned int i;
+#else  /* STAGING_CSMT */
+static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
+
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+
+    swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
+}
+
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override, DWORD flags)
+{
+    struct wined3d_cs_present *op;
+#endif /* STAGING_CSMT */
 
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_PRESENT;
@@ -621,6 +648,7 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
     op->dst_rect = *dst_rect;
     op->flags = flags;
 
+#if defined(STAGING_CSMT)
     wined3d_resource_inc_fence(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; i++)
         wined3d_resource_inc_fence(&swapchain->back_buffers[i]->resource);
@@ -678,6 +706,30 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     unsigned int i;
 
     op = cs->ops->require_space(cs, size);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
+
+    device = cs->device;
+    wined3d_get_draw_rect(&device->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
+}
+
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+{
+    struct wined3d_cs_clear *op;
+
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CLEAR;
     op->flags = flags;
     op->color = *color;
@@ -686,6 +738,7 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     op->rect_count = rect_count;
     memcpy(op->rects, rects, sizeof(*rects) * rect_count);
 
+#if defined(STAGING_CSMT)
     if (flags & WINED3DCLEAR_TARGET)
     {
         for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; i++)
@@ -744,6 +797,15 @@ static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
         cs->state.load_base_vertex_index = 0;
         device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
     }
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_state *state = &cs->device->state;
+    const struct wined3d_cs_draw *op = data;
+#endif /* STAGING_CSMT */
 
     if (!cs->device->adapter->gl_info.supported[ARB_DRAW_ELEMENTS_BASE_VERTEX]
             && state->load_base_vertex_index != op->base_vertex_idx)
@@ -754,6 +816,7 @@ static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
 
     draw_primitive(cs->device, state, op->base_vertex_idx, op->start_idx,
             op->index_count, op->start_instance, op->instance_count, op->indexed);
+#if defined(STAGING_CSMT)
 
     if (op->indexed)
         wined3d_resource_dec_fence(&cs->state.index_buffer->resource);
@@ -784,6 +847,14 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     struct wined3d_cs_draw *op;
     unsigned int i;
     const struct wined3d_state *state = &cs->device->state;
+#else  /* STAGING_CSMT */
+}
+
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned int start_idx,
+        unsigned int index_count, unsigned int start_instance, unsigned int instance_count, BOOL indexed)
+{
+    struct wined3d_cs_draw *op;
+#endif /* STAGING_CSMT */
 
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_DRAW;
@@ -794,6 +865,7 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     op->instance_count = instance_count;
     op->indexed = indexed;
 
+#if defined(STAGING_CSMT)
     if (indexed)
     {
         wined3d_resource_inc_fence(&state->index_buffer->resource);
@@ -831,6 +903,17 @@ static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *d
     cs->state.predicate_value = op->value;
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_predication *op = data;
+
+    cs->state.predicate = op->predicate;
+    cs->state.predicate_value = op->value;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
@@ -842,6 +925,7 @@ void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query
     op->predicate = predicate;
     op->value = value;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -853,6 +937,17 @@ static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data
     device_invalidate_state(cs->device, STATE_VIEWPORT);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_viewport *op = data;
+
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(cs->device, STATE_VIEWPORT);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
@@ -863,6 +958,7 @@ void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_vi
     op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
     op->viewport = *viewport;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -874,6 +970,17 @@ static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *
     device_invalidate_state(cs->device, STATE_SCISSORRECT);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
@@ -884,6 +991,7 @@ void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
     op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
     op->rect = *rect;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -895,6 +1003,17 @@ static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const v
     device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_rendertarget_view *op = data;
+
+    cs->state.fb->render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
@@ -907,6 +1026,7 @@ void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int v
     op->view_idx = view_idx;
     op->view = view;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -917,6 +1037,18 @@ static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     struct wined3d_rendertarget_view *prev;
 
     if ((prev = cs->state.fb.depth_stencil))
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil_view *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_rendertarget_view *prev;
+
+    if ((prev = cs->state.fb->depth_stencil))
+#endif /* STAGING_CSMT */
     {
         struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
 
@@ -924,6 +1056,7 @@ static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
                 || prev_surface->container->flags & WINED3D_TEXTURE_DISCARD))
         {
             surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
+#if defined(STAGING_CSMT)
             if (prev_surface == cs->onscreen_depth_stencil)
             {
                 wined3d_texture_decref(cs->onscreen_depth_stencil->container);
@@ -933,6 +1066,17 @@ static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     }
 
     cs->state.fb.depth_stencil = op->view;
+#else  /* STAGING_CSMT */
+            if (prev_surface == device->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(device->onscreen_depth_stencil->container);
+                device->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->fb.depth_stencil = op->view;
+#endif /* STAGING_CSMT */
 
     if (!prev != !op->view)
     {
@@ -949,8 +1093,10 @@ static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     }
 
     device_invalidate_state(device, STATE_FRAMEBUFFER);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
@@ -961,6 +1107,7 @@ void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3
     op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
     op->view = view;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -972,6 +1119,17 @@ static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const
     device_invalidate_state(cs->device, STATE_VDECL);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
@@ -982,10 +1140,17 @@ void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3
     op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
     op->declaration = declaration;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source *op = data;
     struct wined3d_stream_state *stream;
@@ -1003,8 +1168,10 @@ static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
@@ -1019,10 +1186,17 @@ void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
     op->offset = offset;
     op->stride = stride;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source_freq *op = data;
     struct wined3d_stream_state *stream;
@@ -1032,8 +1206,10 @@ static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const
     stream->flags = op->flags;
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
@@ -1046,10 +1222,17 @@ void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_i
     op->frequency = frequency;
     op->flags = flags;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_output *op = data;
     struct wined3d_stream_output *stream;
@@ -1064,8 +1247,10 @@ static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void
         InterlockedIncrement(&op->buffer->resource.bind_count);
     if (prev)
         InterlockedDecrement(&prev->resource.bind_count);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
@@ -1079,10 +1264,17 @@ void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
     op->buffer = buffer;
     op->offset = offset;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_index_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -1098,8 +1290,10 @@ static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
@@ -1113,10 +1307,17 @@ void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buff
     op->format_id = format_id;
     op->offset = offset;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_constant_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -1130,7 +1331,9 @@ static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const voi
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+#if defined(STAGING_CSMT)
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1144,10 +1347,17 @@ void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_sha
     op->cb_idx = cb_idx;
     op->buffer = buffer;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
@@ -1224,8 +1434,10 @@ static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
 
     if (new_use_color_key)
         device_invalidate_state(cs->device, STATE_COLOR_KEY);
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
@@ -1236,6 +1448,7 @@ void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined
     op->opcode = WINED3D_CS_OP_SET_TEXTURE;
     op->stage = stage;
     op->texture = texture;
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1247,6 +1460,18 @@ static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, cons
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader_resource_view *op = data;
+
+    cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1260,6 +1485,7 @@ void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3
     op->view_idx = view_idx;
     op->view = view;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1271,6 +1497,17 @@ static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1284,6 +1521,7 @@ void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type
     op->sampler_idx = sampler_idx;
     op->sampler = sampler;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1296,6 +1534,18 @@ static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
@@ -1307,6 +1557,7 @@ void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type
     op->type = type;
     op->shader = shader;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1378,6 +1629,17 @@ static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *
     device_invalidate_state(cs->device, STATE_RENDER(op->state));
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
@@ -1389,6 +1651,7 @@ void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render
     op->state = state;
     op->value = value;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1516,6 +1779,17 @@ static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void
     device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
@@ -1529,6 +1803,7 @@ void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
     op->state = state;
     op->value = value;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1540,6 +1815,17 @@ static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void
     device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
@@ -1553,6 +1839,7 @@ void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
     op->state = state;
     op->value = value;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1565,6 +1852,18 @@ static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *dat
         device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->d3d_info.limits.ffp_vertex_blend_matrices))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
@@ -1577,6 +1876,7 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
     op->state = state;
     op->matrix = *matrix;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1588,6 +1888,17 @@ static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *da
     device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
@@ -1599,10 +1910,17 @@ void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const
     op->plane_idx = plane_idx;
     op->plane = *plane;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
 static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_color_key *op = data;
     struct wined3d_texture *texture = op->texture;
@@ -1663,8 +1981,10 @@ static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *dat
                 break;
         }
     }
+#if defined(STAGING_CSMT)
 
     return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -1684,6 +2004,7 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
     else
         op->set = 0;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1695,6 +2016,17 @@ static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data
     device_invalidate_state(cs->device, STATE_MATERIAL);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
@@ -1705,6 +2037,7 @@ void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_ma
     op->opcode = WINED3D_CS_OP_SET_MATERIAL;
     op->material = *material;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1720,6 +2053,19 @@ static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
         ERR("Failed to initialize CS state, hr %#x.\n", hr);
 
     return sizeof(struct wined3d_cs_reset_state);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+
+    state_cleanup(&cs->state);
+    memset(&cs->state, 0, sizeof(cs->state));
+    state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
@@ -1729,6 +2075,7 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_RESET_STATE;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -1739,6 +2086,16 @@ static UINT wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *da
     op->callback(op->object);
 
     return sizeof(*op);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_destroy_object *op = data;
+
+    op->callback(op->object);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void *object), void *object)
@@ -1750,6 +2107,7 @@ void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void
     op->callback = callback;
     op->object = object;
 
+#if defined(STAGING_CSMT)
     cs->ops->submit(cs, sizeof(*op));
 }
 
@@ -3027,5 +3385,152 @@ void wined3d_cs_destroy(struct wined3d_cs *cs)
             ERR("Closing event failed.\n");
     }
 
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs);
+}
+
+static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+    /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
+    /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
+    /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
+    /* WINED3D_CS_OP_SET_PREDICATION            */ wined3d_cs_exec_set_predication,
+    /* WINED3D_CS_OP_SET_VIEWPORT               */ wined3d_cs_exec_set_viewport,
+    /* WINED3D_CS_OP_SET_SCISSOR_RECT           */ wined3d_cs_exec_set_scissor_rect,
+    /* WINED3D_CS_OP_SET_RENDERTARGET_VIEW      */ wined3d_cs_exec_set_rendertarget_view,
+    /* WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW     */ wined3d_cs_exec_set_depth_stencil_view,
+    /* WINED3D_CS_OP_SET_VERTEX_DECLARATION     */ wined3d_cs_exec_set_vertex_declaration,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE          */ wined3d_cs_exec_set_stream_source,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ     */ wined3d_cs_exec_set_stream_source_freq,
+    /* WINED3D_CS_OP_SET_STREAM_OUTPUT          */ wined3d_cs_exec_set_stream_output,
+    /* WINED3D_CS_OP_SET_INDEX_BUFFER           */ wined3d_cs_exec_set_index_buffer,
+    /* WINED3D_CS_OP_SET_CONSTANT_BUFFER        */ wined3d_cs_exec_set_constant_buffer,
+    /* WINED3D_CS_OP_SET_TEXTURE                */ wined3d_cs_exec_set_texture,
+    /* WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW   */ wined3d_cs_exec_set_shader_resource_view,
+    /* WINED3D_CS_OP_SET_SAMPLER                */ wined3d_cs_exec_set_sampler,
+    /* WINED3D_CS_OP_SET_SHADER                 */ wined3d_cs_exec_set_shader,
+    /* WINED3D_CS_OP_SET_RENDER_STATE           */ wined3d_cs_exec_set_render_state,
+    /* WINED3D_CS_OP_SET_TEXTURE_STATE          */ wined3d_cs_exec_set_texture_state,
+    /* WINED3D_CS_OP_SET_SAMPLER_STATE          */ wined3d_cs_exec_set_sampler_state,
+    /* WINED3D_CS_OP_SET_TRANSFORM              */ wined3d_cs_exec_set_transform,
+    /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
+    /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
+    /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
+    /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
+    /* WINED3D_CS_OP_DESTROY_OBJECT             */ wined3d_cs_exec_destroy_object,
+};
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    if (size > cs->data_size)
+    {
+        void *new_data;
+
+        size = max( size, cs->data_size * 2 );
+        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
+            return NULL;
+
+        cs->data_size = size;
+        cs->data = new_data;
+    }
+
+    return cs->data;
+}
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+
+    wined3d_cs_op_handlers[opcode](cs, cs->data);
+}
+
+static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_device *device = cs->device;
+    unsigned int context_count;
+    unsigned int i;
+    size_t offset;
+
+    static const struct
+    {
+        size_t offset;
+        size_t size;
+        DWORD mask;
+    }
+    push_constant_info[] =
+    {
+        /* WINED3D_PUSH_CONSTANTS_VS_F */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
+        /* WINED3D_PUSH_CONSTANTS_PS_F */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
+        /* WINED3D_PUSH_CONSTANTS_VS_I */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
+        /* WINED3D_PUSH_CONSTANTS_PS_I */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
+        /* WINED3D_PUSH_CONSTANTS_VS_B */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
+        /* WINED3D_PUSH_CONSTANTS_PS_B */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
+    };
+
+    if (p == WINED3D_PUSH_CONSTANTS_VS_F)
+        device->shader_backend->shader_update_float_vertex_constants(device, start_idx, count);
+    else if (p == WINED3D_PUSH_CONSTANTS_PS_F)
+        device->shader_backend->shader_update_float_pixel_constants(device, start_idx, count);
+
+    offset = push_constant_info[p].offset + start_idx * push_constant_info[p].size;
+    memcpy((BYTE *)&cs->state + offset, constants, count * push_constant_info[p].size);
+    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= push_constant_info[p].mask;
+    }
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_push_constants,
+};
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_cs *cs;
+
+    if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
+        return NULL;
+
+    if (!(cs->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*cs->fb.render_targets))))
+    {
+        HeapFree(GetProcessHeap(), 0, cs);
+        return NULL;
+    }
+
+    state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+
+    cs->ops = &wined3d_cs_st_ops;
+    cs->device = device;
+
+    cs->data_size = WINED3D_INITIAL_CS_SIZE;
+    if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+    {
+        state_cleanup(&cs->state);
+        HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+        HeapFree(GetProcessHeap(), 0, cs);
+        return NULL;
+    }
+
+    return cs;
+}
+
+void wined3d_cs_destroy(struct wined3d_cs *cs)
+{
+    state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+    HeapFree(GetProcessHeap(), 0, cs->data);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -198,6 +198,24 @@ void device_context_remove(struct wined3d_device *device, struct wined3d_context
     device->contexts = new_array;
 }
 
+#if !defined(STAGING_CSMT)
+void device_switch_onscreen_ds(struct wined3d_device *device,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (device->onscreen_depth_stencil)
+    {
+        surface_load_location(device->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(device->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                device->onscreen_depth_stencil->ds_current_size.cx,
+                device->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_texture_decref(device->onscreen_depth_stencil->container);
+    }
+    device->onscreen_depth_stencil = depth_stencil;
+    wined3d_texture_incref(device->onscreen_depth_stencil->container);
+}
+
+#endif /* STAGING_CSMT */
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     unsigned int height = wined3d_texture_get_level_height(target->container, target->texture_level);
@@ -267,7 +285,11 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
     }
 
     /* Full load. */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#else  /* STAGING_CSMT */
+    surface_load_location(ds, context, location);
+#endif /* STAGING_CSMT */
     SetRect(out_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
 }
 
@@ -278,6 +300,9 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     struct wined3d_surface *target = rt_count ? wined3d_rendertarget_view_get_surface(fb->render_targets[0]) : NULL;
     struct wined3d_rendertarget_view *dsv = fb->depth_stencil;
     struct wined3d_surface *depth_stencil = dsv ? wined3d_rendertarget_view_get_surface(dsv) : NULL;
+#if !defined(STAGING_CSMT)
+    const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     UINT drawable_width, drawable_height;
     struct wined3d_color corrected_color;
@@ -307,6 +332,7 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     for (i = 0; i < rt_count; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if defined(STAGING_CSMT)
 
         if (rtv && rtv->format->id != WINED3DFMT_NULL)
         {
@@ -316,6 +342,16 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
                 wined3d_texture_load_location(rt, rtv->sub_resource_idx, context, rtv->resource->draw_binding);
             else
                 wined3d_texture_prepare_location(rt, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+        struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(rtv);
+
+        if (rt && rtv->format->id != WINED3DFMT_NULL)
+        {
+            if (flags & WINED3DCLEAR_TARGET && !is_full_clear(target, draw_rect, rect_count ? clear_rect : NULL))
+                surface_load_location(rt, context, rtv->resource->draw_binding);
+            else
+                wined3d_texture_prepare_location(rt->container, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
         }
     }
@@ -342,6 +378,7 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? dsv->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
+#if defined(STAGING_CSMT)
         if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
             wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
         prepare_ds_clear(depth_stencil, context, location,
@@ -349,6 +386,15 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     }
 
     if (!context_apply_clear_state(context, rt_count, fb))
+#else  /* STAGING_CSMT */
+        if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
+            device_switch_onscreen_ds(device, context, depth_stencil);
+        prepare_ds_clear(depth_stencil, context, location,
+                draw_rect, rect_count, clear_rect, &ds_rect);
+    }
+
+    if (!context_apply_clear_state(context, state, rt_count, fb))
+#endif /* STAGING_CSMT */
     {
         context_release(context);
         WARN("Failed to apply clear state, skipping clear.\n");
@@ -404,7 +450,11 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
             wined3d_texture_invalidate_location(texture, rtv->sub_resource_idx, ~rtv->resource->draw_binding);
         }
 
+#if defined(STAGING_CSMT)
         if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, &device->cs->state, fb))
+#else  /* STAGING_CSMT */
+        if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, fb))
+#endif /* STAGING_CSMT */
         {
             if (rt_count > 1)
                 WARN("Clearing multiple sRGB render targets with no GL_ARB_framebuffer_sRGB "
@@ -664,6 +714,7 @@ out:
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 static void create_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -698,6 +749,9 @@ static void create_default_samplers(struct wined3d_device *device)
 
 /* Context activation is done by the caller. */
 void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -789,8 +843,10 @@ void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_
             checkGLcall("glTexImage3D");
         }
     }
+#if defined(STAGING_CSMT)
 
     create_default_samplers(device);
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -833,6 +889,41 @@ static void destroy_dummy_textures(struct wined3d_device *device, const struct w
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
+static void create_default_samplers(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+
+    if (gl_info->supported[ARB_SAMPLER_OBJECTS])
+    {
+        /* In SM4+ shaders there is a separation between resources and samplers. Some shader
+         * instructions allow access to resources without using samplers.
+         * In GLSL, resources are always accessed through sampler or image variables. The default
+         * sampler object is used to emulate the direct resource access when there is no sampler state
+         * to use.
+         */
+        GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST));
+        checkGLcall("Create default sampler");
+
+        /* In D3D10+, a NULL sampler maps to the default sampler state. */
+        GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
+        checkGLcall("Create null sampler");
+    }
+    else
+    {
+        device->default_sampler = 0;
+        device->null_sampler = 0;
+    }
+}
+
+/* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void destroy_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -969,7 +1060,11 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
+#if defined(STAGING_CSMT)
     if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
+    if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -987,7 +1082,13 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
+#if defined(STAGING_CSMT)
     struct wined3d_swapchain *swapchain = NULL;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_swapchain *swapchain = NULL;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -998,6 +1099,11 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
+    if (!(device->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*device->fb.render_targets))))
+        return E_OUTOFMEMORY;
+
+#endif /* STAGING_CSMT */
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -1046,11 +1152,24 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
+#else  /* STAGING_CSMT */
+    context = context_acquire(device, swapchain->front_buffer->sub_resources[0].u.surface);
+
+    create_dummy_textures(device, context);
+    create_default_samplers(device);
+
+    device->contexts[0]->last_was_rhw = 0;
+
+    TRACE("All defaults now set up, leaving 3D init.\n");
+
+    context_release(context);
+#endif /* STAGING_CSMT */
 
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
@@ -1067,6 +1186,9 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
+#if !defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1123,6 +1245,10 @@ static void device_free_sampler(struct wine_rb_entry *entry, void *context)
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
+#if !defined(STAGING_CSMT)
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1131,6 +1257,7 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         device->cs->ops->finish(device->cs);
 
@@ -1171,6 +1298,82 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     /* FIXME: Is this in the right place??? */
     wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
 
+#else  /* STAGING_CSMT */
+    /* I don't think that the interface guarantees that the device is destroyed from the same thread
+     * it was created. Thus make sure a context is active for the glDelete* calls
+     */
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    if (device->logo_texture)
+        wined3d_texture_decref(device->logo_texture);
+    if (device->cursor_texture)
+        wined3d_texture_decref(device->cursor_texture);
+
+    state_unbind_resources(&device->state);
+
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        resource->resource_ops->resource_unload(resource);
+    }
+
+    wine_rb_clear(&device->samplers, device_free_sampler, NULL);
+
+    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
+     * private data, it might contain opengl pointers
+     */
+    if (device->depth_blt_texture)
+    {
+        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
+        device->depth_blt_texture = 0;
+    }
+
+    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
+    device->blitter->free_private(device);
+    device->shader_backend->shader_free_private(device);
+    destroy_dummy_textures(device, gl_info);
+    destroy_default_samplers(device);
+
+    /* Release the context again as soon as possible. In particular,
+     * releasing the render target views below may release the last reference
+     * to the swapchain associated with this context, which in turn will
+     * destroy the context. */
+    context_release(context);
+
+    /* Release the buffers (with sanity checks)*/
+    if (device->onscreen_depth_stencil)
+    {
+        surface = device->onscreen_depth_stencil;
+        device->onscreen_depth_stencil = NULL;
+        wined3d_texture_decref(surface->container);
+    }
+
+    if (device->fb.depth_stencil)
+    {
+        struct wined3d_rendertarget_view *view = device->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil view %p.\n", view);
+
+        device->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (device->auto_depth_stencil_view)
+    {
+        struct wined3d_rendertarget_view *view = device->auto_depth_stencil_view;
+
+        device->auto_depth_stencil_view = NULL;
+        if (wined3d_rendertarget_view_decref(view))
+            ERR("Something's still holding the auto depth/stencil view (%p).\n", view);
+    }
+
+    for (i = 0; i < gl_info->limits.buffers; ++i)
+    {
+        wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
+    }
+#endif /* STAGING_CSMT */
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
@@ -1188,6 +1391,11 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
+#if !defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+    device->fb.render_targets = NULL;
+
+#endif /* STAGING_CSMT */
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1232,7 +1440,11 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     /* We can not acquire the context unless there is a swapchain. */
     if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+#if defined(STAGING_CSMT)
             !wined3d_settings.emulated_textureram && !wined3d_settings.cs_multithreaded)
+#else  /* STAGING_CSMT */
+            !wined3d_settings.emulated_textureram)
+#endif /* STAGING_CSMT */
     {
         GLint vram_free_kb;
         UINT64 vram_free;
@@ -1573,6 +1785,16 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             light->direction.x, light->direction.y, light->direction.z,
             light->range, light->falloff, light->theta, light->phi);
 
+#if !defined(STAGING_CSMT)
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1 && !device->recording)
+    {
+        if (object->OriginalParms.type != light->type)
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+#endif /* STAGING_CSMT */
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1652,9 +1874,11 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+#if defined(STAGING_CSMT)
     if (!device->recording)
         wined3d_cs_emit_set_light(device->cs, object);
 
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1727,6 +1951,14 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
+#if !defined(STAGING_CSMT)
+            if (!device->recording)
+            {
+                device_invalidate_state(device, STATE_LIGHT_TYPE);
+                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            }
+
+#endif /* STAGING_CSMT */
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1768,11 +2000,23 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
+#if defined(STAGING_CSMT)
         }
     }
 
     if (!device->recording)
         wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+#else  /* STAGING_CSMT */
+
+            /* i == light_info->glIndex */
+            if (!device->recording)
+            {
+                device_invalidate_state(device, STATE_LIGHT_TYPE);
+                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+            }
+        }
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -1944,9 +2188,11 @@ void CDECL wined3d_device_set_base_vertex_index(struct wined3d_device *device, I
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+#if defined(STAGING_CSMT)
 
     if (!device->recording)
         wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
+#endif /* STAGING_CSMT */
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1992,7 +2238,11 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(dst_texture->resource.format_flags & WINED3DFMT_FLAG_DEPTH))
         return;
 
+#if defined(STAGING_CSMT)
     if (!(src_view = state->fb.depth_stencil))
+#else  /* STAGING_CSMT */
+    if (!(src_view = state->fb->depth_stencil))
+#endif /* STAGING_CSMT */
         return;
     if (src_view->resource->type == WINED3D_RTYPE_BUFFER)
     {
@@ -2327,6 +2577,7 @@ struct wined3d_sampler * CDECL wined3d_device_get_vs_sampler(const struct wined3
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
+#if defined(STAGING_CSMT)
 void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
 {
     UINT i;
@@ -2337,6 +2588,7 @@ void device_invalidate_shader_constants(const struct wined3d_device *device, DWO
     }
 }
 
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
         unsigned int start_idx, unsigned int count, const BOOL *constants)
 {
@@ -2364,8 +2616,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2414,8 +2670,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2460,8 +2720,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.vs_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.vs_consts_f));
     else
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
                 WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2600,8 +2864,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2650,8 +2918,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2697,8 +2969,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.ps_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.ps_consts_f));
     else
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
                 WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2858,6 +3134,7 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         return hr;
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
     {
         FIXME("Waiting for cs.\n");
@@ -2865,6 +3142,7 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         device->cs->ops->finish(device->cs);
     }
 
+#endif /* STAGING_CSMT */
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3350,6 +3628,10 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
+    struct wined3d_context *context;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3358,6 +3640,15 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
+    context = context_acquire(device, NULL);
+    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
+    context->gl_info->gl_ops.gl.p_glFlush();
+    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
+     * fails. */
+    context_release(context);
+
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3365,8 +3656,10 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &device->state.fb;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, debug_color(color), depth, stencil);
 
@@ -3378,7 +3671,11 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
+#if defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *ds = fb->depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3387,8 +3684,13 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
+#if defined(STAGING_CSMT)
             if (ds->width < fb->render_targets[0]->width
                     || ds->height < fb->render_targets[0]->height)
+#else  /* STAGING_CSMT */
+            if (ds->width < device->fb.render_targets[0]->width
+                    || ds->height < device->fb.render_targets[0]->height)
+#endif /* STAGING_CSMT */
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3434,6 +3736,9 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
+#if !defined(STAGING_CSMT)
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3441,8 +3746,13 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
+#if defined(STAGING_CSMT)
     else if (gl_primitive_type != prev)
         wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
+    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
+        device_invalidate_state(device, STATE_POINT_ENABLE);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3502,6 +3812,7 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
 static void wined3d_device_update_texture_3d(struct wined3d_context *context,
         struct wined3d_texture *src_texture, unsigned int src_level,
@@ -3512,6 +3823,36 @@ static void wined3d_device_update_texture_3d(struct wined3d_context *context,
 
     TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
             context, src_texture, src_level, dst_texture, level_count);
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, unsigned int src_level,
+        struct wined3d_texture *dst_texture, unsigned int level_count)
+{
+    struct wined3d_const_bo_address data;
+    struct wined3d_context *context;
+    struct wined3d_map_desc src;
+    HRESULT hr = WINED3D_OK;
+    unsigned int i;
+
+    TRACE("device %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            device, src_texture, src_level, dst_texture, level_count);
+
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (wined3d_texture_get_level_width(src_texture, src_level) != dst_texture->resource.width
+            || wined3d_texture_get_level_height(src_texture, src_level) != dst_texture->resource.height
+            || wined3d_texture_get_level_depth(src_texture, src_level) != dst_texture->resource.depth)
+    {
+        WARN("Source and destination dimensions do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    context = context_acquire(device, NULL);
+#endif /* STAGING_CSMT */
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3519,6 +3860,7 @@ static void wined3d_device_update_texture_3d(struct wined3d_context *context,
 
     for (i = 0; i < level_count; ++i)
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_get_memory(src_texture, src_level + i, &data,
                 src_texture->resource.map_binding, FALSE);
 
@@ -3596,6 +3938,34 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     unsigned int src_size, dst_size, src_skip_levels = 0;
     unsigned int layer_count;
     enum wined3d_resource_type type;
+#else  /* STAGING_CSMT */
+        if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
+                src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
+            goto done;
+
+        data.buffer_object = 0;
+        data.addr = src.data;
+        wined3d_volume_upload_data(dst_texture, i, context, &data);
+        wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
+
+        if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            goto done;
+    }
+
+done:
+    context_release(context);
+    return hr;
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int layer_count, level_count, i, j;
+    enum wined3d_resource_type type;
+    HRESULT hr;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3632,6 +4002,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
      * rejects mismatching formats, and we can't report the error back after dispatching the
      * call. */
@@ -3674,6 +4045,65 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    context = context_acquire(device, NULL);
+    wined3d_texture_load(dst_texture, context, FALSE);
+    context_release(context);
+
+    /* Update every surface level of the texture. */
+    switch (type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return hr;
+                    }
+                }
+            }
+            return WINED3D_OK;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            if (FAILED(hr = wined3d_device_update_texture_3d(device,
+                    src_texture, src_skip_levels, dst_texture, level_count)))
+                WARN("Failed to update 3D texture, hr %#x.\n", hr);
+            return hr;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", type);
+            return WINED3DERR_INVALIDCALL;
+    }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3721,8 +4151,13 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
+#if defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
         struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -3911,7 +4346,9 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     struct wined3d_texture *dst_texture, *src_texture;
     RECT dst_rect, src_rect;
     HRESULT hr;
+#if defined(STAGING_CSMT)
     struct wined3d_box dst_box;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, dst_resource %p, dst_sub_resource_idx %u, dst_x %u, dst_y %u, dst_z %u, "
             "src_resource %p, src_sub_resource_idx %u, src_box %s.\n",
@@ -3999,6 +4436,7 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
 
     if (src_box)
     {
+#if defined(STAGING_CSMT)
         if ((src_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
                 && !wined3d_texture_check_block_align(src_texture,
                 src_sub_resource_idx % src_texture->level_count, src_box))
@@ -4007,6 +4445,7 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
             return WINED3DERR_INVALIDCALL;
         }
 
+#endif /* STAGING_CSMT */
         SetRect(&src_rect, src_box->left, src_box->top, src_box->right, src_box->bottom);
     }
     else
@@ -4020,6 +4459,7 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     SetRect(&dst_rect, dst_x, dst_y, dst_x + (src_rect.right - src_rect.left),
             dst_y + (src_rect.bottom - src_rect.top));
 
+#if defined(STAGING_CSMT)
     if (dst_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
     {
         dst_box.left = dst_rect.left;
@@ -4037,6 +4477,7 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
         }
     }
 
+#endif /* STAGING_CSMT */
     if (FAILED(hr = wined3d_texture_blt(dst_texture, dst_sub_resource_idx, &dst_rect,
             src_texture, src_sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_POINT)))
         WARN("Failed to blit, hr %#x.\n", hr);
@@ -4049,7 +4490,18 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         unsigned int depth_pitch)
 {
     struct wined3d_texture_sub_resource *sub_resource;
+#if defined(STAGING_CSMT)
+    struct wined3d_texture *texture;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_const_bo_address addr;
+    unsigned int width, height, level;
+    struct wined3d_context *context;
     struct wined3d_texture *texture;
+    struct wined3d_surface *surface;
+    POINT dst_point;
+    RECT src_rect;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, resource %p, sub_resource_idx %u, box %s, data %p, row_pitch %u, depth_pitch %u.\n",
             device, resource, sub_resource_idx, debug_box(box), data, row_pitch, depth_pitch);
@@ -4083,6 +4535,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         WARN("Invalid sub_resource_idx %u.\n", sub_resource_idx);
         return;
     }
+#if defined(STAGING_CSMT)
 
     if (box)
     {
@@ -4092,6 +4545,18 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         width = wined3d_texture_get_level_width(texture, level);
         height = wined3d_texture_get_level_height(texture, level);
 
+#else  /* STAGING_CSMT */
+    surface = sub_resource->u.surface;
+
+    level = sub_resource_idx % texture->level_count;
+    width = wined3d_texture_get_level_width(texture, level);
+    height = wined3d_texture_get_level_height(texture, level);
+
+    src_rect.left = 0;
+    src_rect.top = 0;
+    if (box)
+    {
+#endif /* STAGING_CSMT */
         if (box->left >= box->right || box->right > width
                 || box->top >= box->bottom || box->bottom > height
                 || box->front >= box->back)
@@ -4099,9 +4564,46 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
             WARN("Invalid box %s specified.\n", debug_box(box));
             return;
         }
+#if defined(STAGING_CSMT)
     }
 
     wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
+#else  /* STAGING_CSMT */
+
+        src_rect.right = box->right - box->left;
+        src_rect.bottom = box->bottom - box->top;
+        dst_point.x = box->left;
+        dst_point.y = box->top;
+    }
+    else
+    {
+        src_rect.right = width;
+        src_rect.bottom = height;
+        dst_point.x = 0;
+        dst_point.y = 0;
+    }
+
+    addr.buffer_object = 0;
+    addr.addr = data;
+
+    context = context_acquire(resource->device, NULL);
+    gl_info = context->gl_info;
+
+    /* Only load the surface for partial updates. */
+    if (!dst_point.x && !dst_point.y && src_rect.right == width && src_rect.bottom == height)
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+    else
+        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
+
+    wined3d_surface_upload_data(surface, gl_info, resource->format,
+            &src_rect, row_pitch, &dst_point, FALSE, &addr);
+
+    context_release(context);
+
+    wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -4110,8 +4612,13 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
 {
     const struct blit_shader *blitter;
     struct wined3d_resource *resource;
+#if defined(STAGING_CSMT)
     RECT r;
     enum wined3d_blit_op blit_op;
+#else  /* STAGING_CSMT */
+    enum wined3d_blit_op blit_op;
+    RECT r;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view %p, rect %s, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, view, wine_dbgstr_rect(rect), flags, debug_color(color), depth, stencil);
@@ -4150,8 +4657,15 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
+        return blitter->color_fill(device, view, rect, color);
+    else
+        return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4165,6 +4679,7 @@ struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(co
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
     return device->state.fb.render_targets[view_idx];
 }
 
@@ -4180,6 +4695,22 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 {
     struct wined3d_rendertarget_view *prev;
     struct wined3d_fb_state *fb = &device->state.fb;
+#else  /* STAGING_CSMT */
+    return device->fb.render_targets[view_idx];
+}
+
+struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
+{
+    TRACE("device %p.\n", device);
+
+    return device->fb.depth_stencil;
+}
+
+HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
+        unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
+{
+    struct wined3d_rendertarget_view *prev;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -4219,6 +4750,7 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     }
 
 
+#if defined(STAGING_CSMT)
     prev = fb->render_targets[view_idx];
     if (view == prev)
         return WINED3D_OK;
@@ -4226,6 +4758,15 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     if (view)
         wined3d_rendertarget_view_incref(view);
     fb->render_targets[view_idx] = view;
+#else  /* STAGING_CSMT */
+    prev = device->fb.render_targets[view_idx];
+    if (view == prev)
+        return WINED3D_OK;
+
+    if (view)
+        wined3d_rendertarget_view_incref(view);
+    device->fb.render_targets[view_idx] = view;
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -4237,6 +4778,7 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state *fb = &device->state.fb;
     struct wined3d_rendertarget_view *prev;
 
@@ -4250,6 +4792,20 @@ void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device,
     }
 
     if ((fb->depth_stencil = view))
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view *prev;
+
+    TRACE("device %p, view %p.\n", device, view);
+
+    prev = device->fb.depth_stencil;
+    if (prev == view)
+    {
+        TRACE("Trying to do a NOP SetRenderTarget operation.\n");
+        return;
+    }
+
+    if ((device->fb.depth_stencil = view))
+#endif /* STAGING_CSMT */
         wined3d_rendertarget_view_incref(view);
     wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
     if (prev)
@@ -4471,8 +5027,10 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 
     TRACE("device %p.\n", device);
 
+#if defined(STAGING_CSMT)
     /* The resource list is manged by the main thread, iterate here and emit commands for
      * each resource */
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4480,6 +5038,7 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
+#if defined(STAGING_CSMT)
             wined3d_cs_emit_evict_resource(device->cs, resource);
         }
     }
@@ -4498,6 +5057,36 @@ void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wine
 
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
+#else  /* STAGING_CSMT */
+            resource->resource_ops->resource_unload(resource);
+        }
+    }
+
+    /* Invalidate stream sources, the buffer(s) may have been evicted. */
+    device_invalidate_state(device, STATE_STREAMSRC);
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_shader *shader;
+
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        resource->resource_ops->resource_unload(resource);
+    }
+
+    LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
+    {
+        device->shader_backend->shader_destroy(shader);
+    }
+#endif /* STAGING_CSMT */
 
     if (device->depth_blt_texture)
     {
@@ -4519,6 +5108,7 @@ void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wine
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+#if defined(STAGING_CSMT)
     swapchain->num_contexts = 0;
 }
 
@@ -4537,6 +5127,14 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
+#else  /* STAGING_CSMT */
+}
+
+static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_context *context;
+    struct wined3d_texture *target;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4553,6 +5151,7 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
+#if defined(STAGING_CSMT)
     hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
     if (FAILED(hr))
     {
@@ -4563,6 +5162,33 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
     }
 
     wined3d_cs_emit_create_dummy_textures(device->cs);
+#else  /* STAGING_CSMT */
+    /* Recreate the primary swapchain's context */
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to allocate memory for swapchain context array.\n");
+        device->blitter->free_private(device);
+        device->shader_backend->shader_free_private(device);
+        return E_OUTOFMEMORY;
+    }
+
+    target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
+    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    {
+        WARN("Failed to create context.\n");
+        device->blitter->free_private(device);
+        device->shader_backend->shader_free_private(device);
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        return E_FAIL;
+    }
+
+    swapchain->context[0] = context;
+    swapchain->num_contexts = 1;
+    create_dummy_textures(device, context);
+    create_default_samplers(device);
+    context_release(context);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4582,12 +5208,14 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p, reset_state %#x.\n",
             device, swapchain_desc, mode, callback, reset_state);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
     {
         wined3d_cs_emit_glfinish(device->cs);
         device->cs->ops->finish(device->cs);
     }
 
+#endif /* STAGING_CSMT */
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
@@ -4607,9 +5235,16 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->cursor_texture);
             device->cursor_texture = NULL;
         }
+#if defined(STAGING_CSMT)
     }
 
     if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4618,6 +5253,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
+#if defined(STAGING_CSMT)
     if (reset_state)
     {
         state_unbind_resources(&device->state);
@@ -4627,6 +5263,12 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     {
         wined3d_texture_decref(device->cs->onscreen_depth_stencil->container);
         device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    if (device->onscreen_depth_stencil)
+    {
+        wined3d_texture_decref(device->onscreen_depth_stencil->container);
+        device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (reset_state)
@@ -4848,6 +5490,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
+#if defined(STAGING_CSMT)
         if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -4872,6 +5515,32 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         state->scissor_rect.left = 0;
         state->scissor_rect.right = swapchain->desc.backbuffer_width;
         state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
+#else  /* STAGING_CSMT */
+        state_init(&device->state, &device->fb, &device->adapter->gl_info,
+                &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+        device->update_state = &device->state;
+
+        device_init_swapchain_state(device, swapchain);
+    }
+    else if (device->back_buffer_view)
+    {
+        struct wined3d_rendertarget_view *view = device->back_buffer_view;
+        struct wined3d_state *state = &device->state;
+
+        wined3d_device_set_rendertarget_view(device, 0, view, FALSE);
+
+        /* Note the min_z / max_z is not reset. */
+        state->viewport.x = 0;
+        state->viewport.y = 0;
+        state->viewport.width = view->width;
+        state->viewport.height = view->height;
+        wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
+
+        state->scissor_rect.top = 0;
+        state->scissor_rect.left = 0;
+        state->scissor_rect.right = view->width;
+        state->scissor_rect.bottom = view->height;
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4879,7 +5548,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     {
         if (reset_state)
             hr = create_primary_opengl_context(device, swapchain);
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
+#else  /* STAGING_CSMT */
+        swapchain_update_swap_interval(swapchain);
+#endif /* STAGING_CSMT */
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -4959,6 +5632,7 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
     TRACE("device %p, resource %p, type %s.\n", device, resource, debug_d3dresourcetype(type));
 
+#if defined(STAGING_CSMT)
     for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
     {
         if ((rtv = device->state.fb.render_targets[i]) && rtv->resource == resource)
@@ -4966,6 +5640,17 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
     }
 
     if ((rtv = device->state.fb.depth_stencil) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+    context_resource_released(device, resource, type);
+
+    for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
+    {
+        if ((rtv = device->fb.render_targets[i]) && rtv->resource == resource)
+            ERR("Resource %p is still in use as render target %u.\n", resource, i);
+    }
+
+    if ((rtv = device->fb.depth_stencil) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
         ERR("Resource %p is still in use as depth/stencil buffer.\n", resource);
 
     switch (type)
@@ -5101,12 +5786,17 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
+#if defined(STAGING_CSMT)
     if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
         goto err;
     }
+#else  /* STAGING_CSMT */
+    state_init(&device->state, &device->fb, &adapter->gl_info,
+            &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#endif /* STAGING_CSMT */
     device->update_state = &device->state;
 
     if (!(device->cs = wined3d_cs_create(device)))
@@ -5200,6 +5890,7 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
 
 /* Context activation is done by the caller */
 struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
@@ -5253,3 +5944,4 @@ void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_
 
     wined3d_device_destroy_bo(device, context, bo);
 }
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -412,7 +412,11 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         int base_vertex_idx, unsigned int start_idx, unsigned int index_count,
         unsigned int start_instance, unsigned int instance_count, BOOL indexed)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -438,6 +442,7 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
     for (i = 0; i < gl_info->limits.buffers; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if defined(STAGING_CSMT)
 
         if (rtv && rtv->format->id != WINED3DFMT_NULL)
         {
@@ -451,6 +456,21 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
             else
             {
                 wined3d_texture_prepare_location(target, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+        struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(rtv);
+
+        if (target && rtv->format->id != WINED3DFMT_NULL)
+        {
+            if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
+            {
+                surface_load_location(target, context, rtv->resource->draw_binding);
+                wined3d_texture_invalidate_location(target->container,
+                        rtv->sub_resource_idx, ~rtv->resource->draw_binding);
+            }
+            else
+            {
+                wined3d_texture_prepare_location(target->container, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
             }
         }
@@ -470,8 +490,13 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         {
             RECT current_rect, draw_rect, r;
 
+#if defined(STAGING_CSMT)
             if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
                 wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
+#else  /* STAGING_CSMT */
+            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
+                device_switch_onscreen_ds(device, context, ds);
+#endif /* STAGING_CSMT */
 
             if (surface_get_sub_resource(ds)->locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -482,7 +507,11 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
 
             IntersectRect(&r, &draw_rect, &current_rect);
             if (!EqualRect(&r, &draw_rect))
+#if defined(STAGING_CSMT)
                 wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#else  /* STAGING_CSMT */
+                surface_load_location(ds, context, location);
+#endif /* STAGING_CSMT */
             else
                 wined3d_texture_prepare_location(ds->container, dsv->sub_resource_idx, context, location);
         }
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1475,7 +1475,11 @@ static void shader_glsl_load_constants(void *shader_priv, struct wined3d_context
         const struct wined3d_vec4 correction_params =
         {
             /* Position is relative to the framebuffer, not the viewport. */
+#if defined(STAGING_CSMT)
             context->render_offscreen ? 0.0f : (float)state->fb.render_targets[0]->height,
+#else  /* STAGING_CSMT */
+            context->render_offscreen ? 0.0f : (float)state->fb->render_targets[0]->height,
+#endif /* STAGING_CSMT */
             context->render_offscreen ? 1.0f : -1.0f,
             0.0f,
             0.0f,
@@ -1581,11 +1585,13 @@ static void shader_glsl_update_float_vertex_constants(struct wined3d_device *dev
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
     }
+#endif /* STAGING_CSMT */
 }
 
 static void shader_glsl_update_float_pixel_constants(struct wined3d_device *device, UINT start, UINT count)
@@ -1598,11 +1604,13 @@ static void shader_glsl_update_float_pixel_constants(struct wined3d_device *devi
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
     }
+#endif /* STAGING_CSMT */
 }
 
 static unsigned int vec4_varyings(DWORD shader_major, const struct wined3d_gl_info *gl_info)
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -237,9 +237,11 @@ static void wined3d_query_destroy_object(void *object)
 {
     struct wined3d_query *query = object;
 
+#if defined(STAGING_CSMT)
     if (!list_empty(&query->poll_list_entry))
         list_remove(&query->poll_list_entry);
 
+#endif /* STAGING_CSMT */
     /* Queries are specific to the GL context that created them. Not
      * deleting the query will obviously leak it, but that's still better
      * than potentially deleting a different query with the same id in this
@@ -300,6 +302,7 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
+#if defined(STAGING_CSMT)
     if (flags & WINED3DISSUE_END)
         query->counter_main++;
 
@@ -311,6 +314,9 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
         query->state = QUERY_SIGNALLED;
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    return query->query_ops->query_issue(query, flags);
+#endif /* STAGING_CSMT */
 }
 
 static void fill_query_data(void *out, unsigned int out_size, const void *result, unsigned int result_size)
@@ -321,10 +327,25 @@ static void fill_query_data(void *out, unsigned int out_size, const void *result
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_occlusion_query *oq = query->extendedData;
     GLuint samples;
+#else  /* STAGING_CSMT */
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    HRESULT res;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!oq->context)
+        query->state = QUERY_CREATED;
+#endif /* STAGING_CSMT */
 
     if (query->state == QUERY_CREATED)
     {
@@ -335,8 +356,10 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
     TRACE("(%p) : type D3DQUERY_OCCLUSION, data %p, size %#x, flags %#x.\n", query, data, size, flags);
 
+#endif /* STAGING_CSMT */
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -352,6 +375,7 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
     if (!wined3d_settings.cs_multithreaded)
     {
         if (!query->query_ops->query_poll(query))
@@ -383,6 +407,14 @@ static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
         FIXME("%p Wrong thread, returning 1.\n", query);
         oq->samples = 1;
         return TRUE;
+#else  /* STAGING_CSMT */
+    if (oq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        samples = 1;
+        fill_query_data(data, size, &samples, sizeof(samples));
+        return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(oq->context));
@@ -393,6 +425,7 @@ static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
 
     if (available)
     {
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
         checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
         TRACE("Returning %d samples.\n", samples);
@@ -464,6 +497,69 @@ static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
 
     if (data)
         fill_query_data(data, dwSize, &ret, sizeof(ret));
+#else  /* STAGING_CSMT */
+        if (size)
+        {
+            GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
+            checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
+            TRACE("Returning %d samples.\n", samples);
+            fill_query_data(data, size, &samples, sizeof(samples));
+        }
+        res = S_OK;
+    }
+    else
+    {
+        res = S_FALSE;
+    }
+
+    context_release(context);
+
+    return res;
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL signaled;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!data || !size) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        signaled = TRUE;
+        fill_query_data(data, size, &signaled, sizeof(signaled));
+        return S_OK;
+    }
+
+    ret = wined3d_event_query_test(event_query, query->device);
+    switch(ret)
+    {
+        case WINED3D_EVENT_QUERY_OK:
+        case WINED3D_EVENT_QUERY_NOT_STARTED:
+            signaled = TRUE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_WAITING:
+            signaled = FALSE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_WRONG_THREAD:
+            FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
+            signaled = TRUE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_ERROR:
+            ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
+            return WINED3DERR_INVALIDCALL;
+    }
+#endif /* STAGING_CSMT */
 
     return S_OK;
 }
@@ -482,7 +578,11 @@ enum wined3d_query_type CDECL wined3d_query_get_type(const struct wined3d_query
     return query->type;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -492,6 +592,7 @@ static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD fla
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
+#if defined(STAGING_CSMT)
         if (!event_query) return FALSE;
 
         wined3d_event_query_issue(event_query, query->device);
@@ -510,6 +611,30 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     BOOL poll = FALSE;
+#else  /* STAGING_CSMT */
+        if (!event_query) return WINED3D_OK;
+
+        wined3d_event_query_issue(event_query, query->device);
+    }
+    else if (flags & WINED3DISSUE_BEGIN)
+    {
+        /* Started implicitly at device creation */
+        ERR("Event query issued with START flag - what to do?\n");
+    }
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+}
+
+static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+#endif /* STAGING_CSMT */
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -521,7 +646,11 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
+#if defined(STAGING_CSMT)
             if (oq->started)
+#else  /* STAGING_CSMT */
+            if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -550,7 +679,9 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+#if defined(STAGING_CSMT)
             oq->started = TRUE;
+#endif /* STAGING_CSMT */
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -558,7 +689,11 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
+#if defined(STAGING_CSMT)
             if (oq->started)
+#else  /* STAGING_CSMT */
+            if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -572,10 +707,15 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+#if defined(STAGING_CSMT)
                     poll = TRUE;
                 }
             }
             oq->started = FALSE;
+#else  /* STAGING_CSMT */
+                }
+            }
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -583,6 +723,7 @@ static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
+#if defined(STAGING_CSMT)
     return poll;
 }
 
@@ -641,6 +782,47 @@ static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
         FIXME("%p Wrong thread, returning 1.\n", query);
         tq->timestamp = 1;
         return TRUE;
+#else  /* STAGING_CSMT */
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+}
+
+static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    struct wined3d_timestamp_query *tq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint64 timestamp;
+    HRESULT res;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!tq->context)
+        query->state = QUERY_CREATED;
+
+    if (query->state == QUERY_CREATED)
+    {
+        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves. */
+        TRACE("Query wasn't yet started, returning S_OK.\n");
+        timestamp = 0;
+        fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        return S_OK;
+    }
+
+    if (tq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        timestamp = 1;
+        fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(tq->context));
@@ -651,6 +833,7 @@ static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
 
     if (available)
     {
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
         checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
         TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
@@ -668,6 +851,28 @@ static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
 }
 
 static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+        if (size)
+        {
+            GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
+            checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
+            TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
+            fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        }
+        res = S_OK;
+    }
+    else
+    {
+        res = S_FALSE;
+    }
+
+    context_release(context);
+
+    return res;
+}
+
+static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -700,6 +905,7 @@ static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD
     }
 
     if (flags & WINED3DISSUE_END)
+#if defined(STAGING_CSMT)
         return TRUE;
     return FALSE;
 }
@@ -708,6 +914,18 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
         void *data, DWORD size, DWORD flags)
 {
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+#else  /* STAGING_CSMT */
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+}
+
+static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+#endif /* STAGING_CSMT */
     if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP_DISJOINT)
     {
         static const struct wined3d_query_data_timestamp_disjoint disjoint_data = {1000 * 1000 * 1000, FALSE};
@@ -729,6 +947,7 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -738,6 +957,18 @@ static BOOL wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *que
 {
     TRACE("query %p, flags %#x.\n", query, flags);
     return FALSE;
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    TRACE("query %p, flags %#x.\n", query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    if (flags & WINED3DISSUE_END)
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_statistics_query_ops_get_data(struct wined3d_query *query,
@@ -752,6 +983,7 @@ static HRESULT wined3d_statistics_query_ops_get_data(struct wined3d_query *query
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_statistics_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -761,6 +993,12 @@ static BOOL wined3d_statistics_query_ops_issue(struct wined3d_query *query, DWOR
 {
     FIXME("query %p, flags %#x.\n", query, flags);
     return FALSE;
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_statistics_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_overflow_query_ops_get_data(struct wined3d_query *query,
@@ -775,6 +1013,7 @@ static HRESULT wined3d_overflow_query_ops_get_data(struct wined3d_query *query,
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_overflow_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -825,6 +1064,47 @@ static const struct wined3d_query_ops overflow_query_ops =
 {
     wined3d_overflow_query_ops_get_data,
     wined3d_overflow_query_ops_poll,
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_overflow_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return WINED3D_OK;
+}
+
+static const struct wined3d_query_ops event_query_ops =
+{
+    wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_issue,
+};
+
+static const struct wined3d_query_ops occlusion_query_ops =
+{
+    wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_query_ops =
+{
+    wined3d_timestamp_query_ops_get_data,
+    wined3d_timestamp_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_disjoint_query_ops =
+{
+    wined3d_timestamp_disjoint_query_ops_get_data,
+    wined3d_timestamp_disjoint_query_ops_issue,
+};
+
+static const struct wined3d_query_ops statistics_query_ops =
+{
+    wined3d_statistics_query_ops_get_data,
+    wined3d_statistics_query_ops_issue,
+};
+
+static const struct wined3d_query_ops overflow_query_ops =
+{
+    wined3d_overflow_query_ops_get_data,
+#endif /* STAGING_CSMT */
     wined3d_overflow_query_ops_issue
 };
 
@@ -846,6 +1126,7 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
+#if defined(STAGING_CSMT)
             query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                     sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
@@ -853,6 +1134,15 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
                 ERR("Failed to allocate occlusion query extended data.\n");
                 return E_OUTOFMEMORY;
             }
+#else  /* STAGING_CSMT */
+            query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
+            if (!query->extendedData)
+            {
+                ERR("Failed to allocate occlusion query extended data.\n");
+                return E_OUTOFMEMORY;
+            }
+            ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -939,7 +1229,9 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+#if defined(STAGING_CSMT)
     list_init(&query->poll_list_entry);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -213,7 +213,9 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+#if defined(STAGING_CSMT)
         resource->heap_memory = resource->map_heap_memory;
+#endif /* STAGING_CSMT */
     }
     else
     {
@@ -237,6 +239,7 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
 {
     wined3d_resource_free_sysmem(resource);
@@ -244,6 +247,7 @@ void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
     context_resource_released(resource->device, resource, resource->type);
 }
 
+#endif /* STAGING_CSMT */
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -256,8 +260,14 @@ void resource_cleanup(struct wined3d_resource *resource)
         adapter_adjust_memory(resource->device->adapter, (INT64)0 - resource->size);
     }
 
+#if defined(STAGING_CSMT)
     device_resource_released(resource->device, resource);
     wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
+#else  /* STAGING_CSMT */
+    wined3d_resource_free_sysmem(resource);
+
+    device_resource_released(resource->device, resource);
+#endif /* STAGING_CSMT */
 }
 
 void resource_unload(struct wined3d_resource *resource)
@@ -340,7 +350,11 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
+#if defined(STAGING_CSMT)
     resource->map_heap_memory = ++p;
+#else  /* STAGING_CSMT */
+    resource->heap_memory = ++p;
+#endif /* STAGING_CSMT */
 
     return TRUE;
 }
diff --git a/dlls/wined3d/sampler.c b/dlls/wined3d/sampler.c
--- a/dlls/wined3d/sampler.c
+++ b/dlls/wined3d/sampler.c
@@ -66,6 +66,7 @@ void * CDECL wined3d_sampler_get_parent(const struct wined3d_sampler *sampler)
     return sampler->parent;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_sampler_init(struct wined3d_sampler *sampler)
 {
     const struct wined3d_gl_info *gl_info;
@@ -97,6 +98,45 @@ void wined3d_sampler_init(struct wined3d_sampler *sampler)
             wined3d_gl_compare_func(sampler->desc.comparison_func)));
     if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
             && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !sampler->desc.srgb_decode)
+#else  /* STAGING_CSMT */
+static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d_device *device,
+        const struct wined3d_sampler_desc *desc, void *parent)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+
+    sampler->refcount = 1;
+    sampler->device = device;
+    sampler->parent = parent;
+    sampler->desc = *desc;
+
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenSamplers(1, &sampler->name));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_S,
+            gl_info->wrap_lookup[desc->address_u - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
+            gl_info->wrap_lookup[desc->address_v - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_R,
+            gl_info->wrap_lookup[desc->address_w - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &desc->border_color[0]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAG_FILTER,
+            wined3d_gl_mag_filter(desc->mag_filter)));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MIN_FILTER,
+            wined3d_gl_min_mip_filter(desc->min_filter, desc->mip_filter)));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, desc->lod_bias));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, desc->min_lod));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, desc->max_lod));
+    if (gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC])
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, desc->max_anisotropy));
+    if (desc->compare)
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_FUNC,
+            wined3d_gl_compare_func(desc->comparison_func)));
+    if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
+            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !desc->srgb_decode)
+#endif /* STAGING_CSMT */
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_SRGB_DECODE_EXT, GL_SKIP_DECODE_EXT));
     checkGLcall("sampler creation");
 
@@ -108,12 +148,14 @@ void wined3d_sampler_init(struct wined3d_sampler *sampler)
 HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler)
 {
+#if defined(STAGING_CSMT)
     return wined3d_sampler_create_from_cs(device, desc, parent, sampler, FALSE);
 }
 
 HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler, BOOL from_cs)
 {
+#endif /* STAGING_CSMT */
     struct wined3d_sampler *object;
 
     TRACE("device %p, desc %p, parent %p, sampler %p.\n", device, desc, parent, sampler);
@@ -134,6 +176,7 @@ HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const stru
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
+#if defined(STAGING_CSMT)
     object->refcount = 1;
     object->device = device;
     object->parent = parent;
@@ -142,6 +185,9 @@ HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const stru
         wined3d_sampler_init(object);
     else
         wined3d_cs_emit_sampler_init(device->cs, object);
+#else  /* STAGING_CSMT */
+    wined3d_sampler_init(object, device, desc, parent);
+#endif /* STAGING_CSMT */
 
     TRACE("Created sampler %p.\n", object);
     *sampler = object;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -3058,7 +3058,11 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     UINT i;
 
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
+#if defined(STAGING_CSMT)
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb))
+#else  /* STAGING_CSMT */
+    if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb))
+#endif /* STAGING_CSMT */
     {
         static unsigned int warned = 0;
 
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -105,7 +105,11 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     /* No z test without depth stencil buffers */
+#if defined(STAGING_CSMT)
     if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -382,6 +386,7 @@ static void state_blend(struct wined3d_context *context, const struct wined3d_st
     GLenum srcBlend, dstBlend;
     unsigned int rt_fmt_flags;
 
+#if defined(STAGING_CSMT)
     if (!state->fb.render_targets[0])
     {
         gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
@@ -390,6 +395,16 @@ static void state_blend(struct wined3d_context *context, const struct wined3d_st
 
     rt_format = state->fb.render_targets[0]->format;
     rt_fmt_flags = state->fb.render_targets[0]->format_flags;
+#else  /* STAGING_CSMT */
+    if (!state->fb->render_targets[0])
+    {
+        gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+        return;
+    }
+
+    rt_format = state->fb->render_targets[0]->format;
+    rt_fmt_flags = state->fb->render_targets[0]->format_flags;
+#endif /* STAGING_CSMT */
 
     /* According to the red book, GL_LINE_SMOOTH needs GL_BLEND with specific
      * blending parameters to work. */
@@ -823,7 +838,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
+#if defined(STAGING_CSMT)
     if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -919,7 +938,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -933,7 +956,11 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1671,7 +1698,11 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+#endif /* STAGING_CSMT */
         float scale;
 
         union
@@ -3604,7 +3635,11 @@ static void sampler(struct wined3d_context *context, const struct wined3d_state
             }
             else
             {
+#if defined(STAGING_CSMT)
                 if (FAILED(wined3d_sampler_create_from_cs(device, &desc, NULL, &sampler, TRUE)))
+#else  /* STAGING_CSMT */
+                if (FAILED(wined3d_sampler_create(device, &desc, NULL, &sampler)))
+#endif /* STAGING_CSMT */
                 {
                     ERR("Failed to create sampler.\n");
                     sampler = NULL;
@@ -4580,8 +4615,13 @@ static void vertexdeclaration(struct wined3d_context *context, const struct wine
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_rendertarget_view *depth_stencil = state->fb.depth_stencil;
     const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
+    const struct wined3d_rendertarget_view *depth_stencil = state->fb->depth_stencil;
+    const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
     unsigned int width, height;
@@ -4767,7 +4807,11 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
         UINT height;
         UINT width;
 
@@ -4835,7 +4879,11 @@ void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
+#if defined(STAGING_CSMT)
     if (needs_srgb_write(context, state, &state->fb))
+#else  /* STAGING_CSMT */
+    if (needs_srgb_write(context, state, state->fb))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
     else
         gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -430,7 +430,9 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -507,6 +509,7 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+#if defined(STAGING_CSMT)
 
     if (state->fb.depth_stencil)
     {
@@ -532,6 +535,7 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+#endif /* STAGING_CSMT */
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -556,8 +560,10 @@ void state_cleanup(struct wined3d_state *state)
             HeapFree(GetProcessHeap(), 0, light);
         }
     }
+#if defined(STAGING_CSMT)
 
     HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
+#endif /* STAGING_CSMT */
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1009,8 +1015,13 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
+#if defined(STAGING_CSMT)
         if (gl_primitive_type != prev)
             wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
+        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
+            device_invalidate_state(device, STATE_POINT_ENABLE);
+#endif /* STAGING_CSMT */
     }
 
     if (stateblock->changed.indices)
@@ -1269,6 +1280,7 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+#if defined(STAGING_CSMT)
         state->textures[i] = NULL;
     }
 
@@ -1315,6 +1327,37 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
 
     if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
         return hr;
+#else  /* STAGING_CSMT */
+    }
+}
+
+void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD flags)
+{
+    unsigned int i;
+
+    state->flags = flags;
+    state->fb = fb;
+
+    for (i = 0; i < LIGHTMAP_SIZE; i++)
+    {
+        list_init(&state->light_map[i]);
+    }
+
+    if (flags & WINED3D_STATE_INIT_DEFAULT)
+        state_init_default(state, gl_info);
+}
+
+static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
+        struct wined3d_device *device, enum wined3d_stateblock_type type)
+{
+    const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+
+    stateblock->ref = 1;
+    stateblock->device = device;
+    state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0);
+#endif /* STAGING_CSMT */
 
     if (type == WINED3D_SBT_RECORDED)
         return WINED3D_OK;
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,11 +36,13 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 static const DWORD surface_simple_locations = WINED3D_LOCATION_SYSMEM
         | WINED3D_LOCATION_USER_MEMORY | WINED3D_LOCATION_BUFFER;
 
+#if defined(STAGING_CSMT)
 static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int dst_sub_resource_idx,
         const struct wined3d_box *dst_box, struct wined3d_texture *src_texture, unsigned int src_sub_resource_idx,
         const struct wined3d_box *src_box, DWORD flags, const struct wined3d_blt_fx *fx,
         enum wined3d_texture_filter_type filter);
 
+#endif /* STAGING_CSMT */
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
         unsigned int *width, unsigned int *height)
 {
@@ -324,7 +326,11 @@ void wined3d_surface_destroy_dc(struct wined3d_surface *surface)
         gl_info = context->gl_info;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
     wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
 
     if (context)
@@ -360,7 +366,11 @@ HRESULT wined3d_surface_create_dc(struct wined3d_surface *surface)
         gl_info = context->gl_info;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
     desc.pMemory = wined3d_texture_map_bo_address(&data, texture->sub_resources[sub_resource_idx].size,
             gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
@@ -455,11 +465,17 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
 
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
             context, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
         wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
                 context, dst_location);
+#else  /* STAGING_CSMT */
+    surface_load_location(src_surface, context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        surface_load_location(dst_surface, context, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, context, dst_location);
 
@@ -553,11 +569,17 @@ static void surface_blt_fbo(const struct wined3d_device *device,
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
             old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
         wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
                                       old_ctx, dst_location);
+#else  /* STAGING_CSMT */
+    surface_load_location(src_surface, old_ctx, src_location);
+    if (!surface_is_full_rect(dst_surface, &dst_rect))
+        surface_load_location(dst_surface, old_ctx, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, old_ctx, dst_location);
 
@@ -628,8 +650,12 @@ static void surface_blt_fbo(const struct wined3d_device *device,
             dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, GL_COLOR_BUFFER_BIT, gl_filter);
     checkGLcall("glBlitFramebuffer()");
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering
             || (dst_location == WINED3D_LOCATION_DRAWABLE
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering || (dst_location == WINED3D_LOCATION_DRAWABLE
+#endif /* STAGING_CSMT */
             && dst_texture->swapchain->front_buffer == dst_texture))
         gl_info->gl_ops.gl.p_glFlush();
 
@@ -718,7 +744,12 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view_desc view_desc;
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -729,6 +760,7 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     view.resource = resource;
     view.parent = NULL;
     view.parent_ops = &wined3d_null_parent_ops;
@@ -740,6 +772,21 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
     view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
 
     hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+#else  /* STAGING_CSMT */
+    view_desc.format_id = resource->format->id;
+    view_desc.u.texture.level_idx = surface->texture_level;
+    view_desc.u.texture.layer_idx = surface->texture_layer;
+    view_desc.u.texture.layer_count = 1;
+    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
+            resource, NULL, &wined3d_null_parent_ops, &view)))
+    {
+        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
+        return hr;
+    }
+
+    hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+    wined3d_rendertarget_view_decref(view);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -804,7 +851,11 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         }
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#endif /* STAGING_CSMT */
 
     if (texture->flags & WINED3D_TEXTURE_COND_NP2_EMULATED)
     {
@@ -1182,6 +1233,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     /* Use surface_cpu_blt() instead of uploading directly if we need
      * conversion. Avoid calling wined3d_surface_blt() since that goes
      * through the CS. */
@@ -1192,6 +1244,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
         return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box, src_texture,
                 src_sub_resource_idx, &src_box, 0, NULL, WINED3D_TEXF_POINT);
     }
+#else  /* STAGING_CSMT */
+    /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
+    if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_texture, FALSE))
+        return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+#endif /* STAGING_CSMT */
 
     context = context_acquire(dst_texture->resource.device, NULL);
     gl_info = context->gl_info;
@@ -1202,11 +1259,19 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
     else
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(dst_texture, dst_sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
 
     wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
             src_texture->sub_resources[src_sub_resource_idx].locations, FALSE);
+#else  /* STAGING_CSMT */
+        surface_load_location(dst_surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
+
+    wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
+            src_texture->sub_resources[src_sub_resource_idx].locations);
+#endif /* STAGING_CSMT */
     wined3d_texture_get_pitch(src_texture, src_surface->texture_level, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
@@ -1707,6 +1772,7 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
 {
     unsigned int texture_level = sub_resource_idx % src_texture->level_count;
     const struct wined3d_format *src_format = src_texture->resource.format;
+#if defined(STAGING_CSMT)
     void *dst_data = NULL, *src_data = NULL;
     UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const struct d3dfmt_converter_desc *conv;
@@ -1715,6 +1781,13 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
     struct wined3d_context *context = NULL;
     struct wined3d_device *device = src_texture->resource.device;
     struct wined3d_bo_address src_bo_addr;
+#else  /* STAGING_CSMT */
+    struct wined3d_device *device = src_texture->resource.device;
+    const struct d3dfmt_converter_desc *conv = NULL;
+    struct wined3d_texture *dst_texture;
+    struct wined3d_resource_desc desc;
+    struct wined3d_map_desc src_map;
+#endif /* STAGING_CSMT */
 
     if (!(conv = find_converter(src_format->id, dst_format->id)) && (!device->d3d_initialized
             || !is_identity_fixup(src_format->color_fixup) || src_format->convert
@@ -1744,6 +1817,7 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_pitch(src_texture, sub_resource_idx & src_texture->level_count,
             &src_row_pitch, &src_slice_pitch);
     wined3d_texture_get_pitch(dst_texture, 0, &dst_row_pitch, &dst_slice_pitch);
@@ -1783,6 +1857,36 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         /* FIXME: This seems weird, considering that we got a wined3d_bo_address from the source
          * surface above. Though not sure if the upload_data would work properly with a PBO src. */
         struct wined3d_bo_address data = {0, src_data};
+#else  /* STAGING_CSMT */
+    memset(&src_map, 0, sizeof(src_map));
+    if (FAILED(wined3d_resource_map(&src_texture->resource, sub_resource_idx,
+            &src_map, NULL, WINED3D_MAP_READONLY)))
+    {
+        ERR("Failed to map the source texture.\n");
+        wined3d_texture_decref(dst_texture);
+        return NULL;
+    }
+    if (conv)
+    {
+        struct wined3d_map_desc dst_map;
+
+        memset(&dst_map, 0, sizeof(dst_map));
+        if (FAILED(wined3d_resource_map(&dst_texture->resource, 0, &dst_map, NULL, 0)))
+        {
+            ERR("Failed to map the destination texture.\n");
+            wined3d_resource_unmap(&src_texture->resource, sub_resource_idx);
+            wined3d_texture_decref(dst_texture);
+            return NULL;
+        }
+
+        conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch, desc.width, desc.height);
+
+        wined3d_resource_unmap(&dst_texture->resource, 0);
+    }
+    else
+    {
+        struct wined3d_bo_address data = {0, src_map.data};
+#endif /* STAGING_CSMT */
         RECT src_rect = {0, 0, desc.width, desc.height};
         const struct wined3d_gl_info *gl_info;
         struct wined3d_context *context;
@@ -1795,6 +1899,7 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
         wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
         wined3d_surface_upload_data(dst_texture->sub_resources[0].u.surface, gl_info, src_format,
+#if defined(STAGING_CSMT)
                 &src_rect, src_row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
 
         context_release(context);
@@ -1819,6 +1924,18 @@ error:
     if (context)
         context_release(context);
     return NULL;
+#else  /* STAGING_CSMT */
+                &src_rect, src_map.row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
+
+        context_release(context);
+
+        wined3d_texture_validate_location(dst_texture, 0, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_texture_invalidate_location(dst_texture, 0, ~WINED3D_LOCATION_TEXTURE_RGB);
+    }
+    wined3d_resource_unmap(&src_texture->resource, sub_resource_idx);
+
+    return dst_texture;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -1896,7 +2013,11 @@ static void read_from_framebuffer(struct wined3d_surface *surface,
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#endif /* STAGING_CSMT */
 
     restore_rt = context_get_rt_surface(old_ctx);
     if (restore_rt != surface)
@@ -2423,9 +2544,13 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
@@ -2490,9 +2615,15 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
 
     gl_info = context->gl_info;
 
+#if defined(STAGING_CSMT)
     /* Make sure the surface is up-to-date. This should probably use
      * wined3d_texture_load_location() and worry about the destination surface too,
      * unless we're overwriting it completely. */
+#else  /* STAGING_CSMT */
+    /* Make sure the surface is up-to-date. This should probably use
+     * surface_load_location() and worry about the destination surface too,
+     * unless we're overwriting it completely. */
+#endif /* STAGING_CSMT */
     wined3d_texture_load(src_texture, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -2535,11 +2666,16 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain
             && dst_texture->swapchain->front_buffer == dst_texture))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain && dst_texture->swapchain->front_buffer == dst_texture))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     if (restore_rt)
@@ -2550,7 +2686,12 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view_desc view_desc;
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2561,6 +2702,7 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     view.resource = resource;
     view.parent = NULL;
     view.parent_ops = &wined3d_null_parent_ops;
@@ -2572,6 +2714,21 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
     view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
 
     hr = blitter->color_fill(device, &view, rect, color);
+#else  /* STAGING_CSMT */
+    view_desc.format_id = resource->format->id;
+    view_desc.u.texture.level_idx = s->texture_level;
+    view_desc.u.texture.layer_idx = s->texture_layer;
+    view_desc.u.texture.layer_count = 1;
+    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
+            resource, NULL, &wined3d_null_parent_ops, &view)))
+    {
+        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
+        return hr;
+    }
+
+    hr = blitter->color_fill(device, view, rect, color);
+    wined3d_rendertarget_view_decref(view);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2582,7 +2739,11 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
 {
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
+#if defined(STAGING_CSMT)
     const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
+#else  /* STAGING_CSMT */
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
+#endif /* STAGING_CSMT */
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_texture *src_texture;
 
@@ -2883,9 +3044,13 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -2902,9 +3067,13 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -2913,6 +3082,69 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
     }
 }
 
+#if !defined(STAGING_CSMT)
+static DWORD resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_BUFFER:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
+{
+    unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
+    struct wined3d_texture *texture = surface->container;
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_context *context;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    wined3d_texture_get_memory(texture, sub_resource_idx, &dst, location);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &src, sub_resource->locations);
+
+    if (dst.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
+        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, sub_resource->size, src.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+        checkGLcall("Upload PBO");
+        context_release(context);
+        return;
+    }
+    if (src.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, sub_resource->size, dst.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
+        checkGLcall("Download PBO");
+        context_release(context);
+        return;
+    }
+    memcpy(dst.addr, src.addr, sub_resource->size);
+}
+
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD dst_location)
@@ -2925,9 +3157,20 @@ static void surface_load_sysmem(struct wined3d_surface *surface,
     wined3d_texture_prepare_location(texture, sub_resource_idx, context, dst_location);
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if defined(STAGING_CSMT)
     if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
         wined3d_texture_load_location(surface->container, surface_get_sub_resource_idx(surface),
                 context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    if (sub_resource->locations & surface_simple_locations)
+    {
+        surface_copy_simple_location(surface, dst_location);
+        return;
+    }
+
+    if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 
     /* Download the surface to system memory. */
     if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
@@ -2965,8 +3208,12 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
             context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     surface_blt_to_drawable(texture->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
@@ -3043,8 +3290,12 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
                 == WINED3D_LOCATION_TEXTURE_RGB)
         {
             FIXME_(d3d_perf)("Downloading RGB surface %p to reload it as sRGB.\n", surface);
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
                     context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(surface, context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -3053,8 +3304,12 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
                 == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             FIXME_(d3d_perf)("Downloading sRGB surface %p to reload it as RGB.\n", surface);
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
                     context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(surface, context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
 
@@ -3062,7 +3317,11 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     {
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface), context, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
+        surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
     }
 
     wined3d_texture_prepare_texture(texture, context, srgb);
@@ -3076,6 +3335,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
@@ -3085,6 +3345,17 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     }
 
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations, FALSE);
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+    {
+        TRACE("Removing the pbo attached to surface %p.\n", surface);
+
+        surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_texture_set_map_binding(texture, WINED3D_LOCATION_SYSMEM);
+    }
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations);
+#endif /* STAGING_CSMT */
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -3167,6 +3438,7 @@ static void surface_load_renderbuffer(struct wined3d_surface *surface, struct wi
 }
 
 /* Context activation is done by the caller. Context may be NULL in ddraw-only mode. */
+#if defined(STAGING_CSMT)
 void surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
 {
     unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
@@ -3177,6 +3449,52 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#else  /* STAGING_CSMT */
+HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
+{
+    unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
+    struct wined3d_texture *texture = surface->container;
+    struct wined3d_texture_sub_resource *sub_resource;
+    unsigned int surface_w, surface_h;
+    HRESULT hr;
+
+    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
+
+    surface_w = wined3d_texture_get_level_width(texture, surface->texture_level);
+    surface_h = wined3d_texture_get_level_height(texture, surface->texture_level);
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    if (sub_resource->locations & location && (!(texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+            || (surface->ds_current_size.cx == surface_w && surface->ds_current_size.cy == surface_h)))
+    {
+        TRACE("Location (%#x) is already up to date.\n", location);
+        return WINED3D_OK;
+    }
+
+    if (WARN_ON(d3d))
+    {
+        DWORD required_access = resource_access_from_location(location);
+        if ((texture->resource.access_flags & required_access) != required_access)
+            WARN("Operation requires %#x access, but surface only has %#x.\n",
+                    required_access, texture->resource.access_flags);
+    }
+
+    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface previously discarded, nothing to do.\n");
+        wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        goto done;
+    }
+
+    if (!sub_resource->locations)
+    {
+        ERR("Surface %p does not have any up to date location.\n", surface);
+        wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        return surface_load_location(surface, context, location);
+    }
+#endif /* STAGING_CSMT */
 
     if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
@@ -3189,7 +3507,11 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
 
         FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
                 wined3d_debug_location(sub_resource->locations), wined3d_debug_location(location));
+#if defined(STAGING_CSMT)
         return;
+#else  /* STAGING_CSMT */
+        return WINED3DERR_INVALIDCALL;
+#endif /* STAGING_CSMT */
     }
 
     switch (location)
@@ -3202,7 +3524,11 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
 
         case WINED3D_LOCATION_DRAWABLE:
             if (FAILED(hr = surface_load_drawable(surface, context)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return hr;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_LOCATION_RB_RESOLVED:
@@ -3214,7 +3540,11 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
         case WINED3D_LOCATION_TEXTURE_SRGB:
             if (FAILED(hr = surface_load_texture(surface, context,
                     location == WINED3D_LOCATION_TEXTURE_SRGB)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return hr;
+#endif /* STAGING_CSMT */
             break;
 
         default:
@@ -3223,7 +3553,19 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
     }
 
 done:
+#if defined(STAGING_CSMT)
     return;
+#else  /* STAGING_CSMT */
+    wined3d_texture_validate_location(texture, sub_resource_idx, location);
+
+    if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+    {
+        surface->ds_current_size.cx = surface_w;
+        surface->ds_current_size.cy = surface_h;
+    }
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT ffp_blit_alloc(struct wined3d_device *device) { return WINED3D_OK; }
@@ -3555,6 +3897,7 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_context *context = NULL;
     struct wined3d_bo_address src_bo_addr, dst_bo_addr;
@@ -3582,6 +3925,18 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
         wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
                 &dst_map.row_pitch, &dst_map.slice_pitch);
 
+#else  /* STAGING_CSMT */
+
+    TRACE("dst_texture %p, dst_sub_resource_idx %u, dst_box %s, src_texture %p, "
+            "src_sub_resource_idx %u, src_box %s, flags %#x, fx %p, filter %s.\n",
+            dst_texture, dst_sub_resource_idx, debug_box(dst_box), src_texture,
+            src_sub_resource_idx, debug_box(src_box), flags, fx, debug_d3dtexturefiltertype(filter));
+
+    if (src_texture == dst_texture && src_sub_resource_idx == dst_sub_resource_idx)
+    {
+        same_sub_resource = TRUE;
+        wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, NULL, 0);
+#endif /* STAGING_CSMT */
         src_map = dst_map;
         src_format = dst_texture->resource.format;
         dst_format = src_format;
@@ -3606,6 +3961,7 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
                 src_texture = converted_texture;
                 src_sub_resource_idx = 0;
             }
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(src_texture, src_sub_resource_idx,
                     context, src_texture->resource.map_binding);
             wined3d_texture_get_pitch(src_texture, src_sub_resource_idx % src_texture->level_count,
@@ -3616,6 +3972,9 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
                     src_texture->sub_resources[src_sub_resource_idx].size,
                     context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
+#else  /* STAGING_CSMT */
+            wined3d_resource_map(&src_texture->resource, src_sub_resource_idx, &src_map, NULL, WINED3D_MAP_READONLY);
+#endif /* STAGING_CSMT */
             src_format = src_texture->resource.format;
             src_fmt_flags = src_texture->resource.format_flags;
         }
@@ -3625,6 +3984,7 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
             src_fmt_flags = dst_fmt_flags;
         }
 
+#if defined(STAGING_CSMT)
         wined3d_texture_get_memory(dst_texture, dst_sub_resource_idx, &dst_bo_addr,
                 dst_texture->resource.map_binding, FALSE);
         dst_map.data = wined3d_texture_map_bo_address(&dst_bo_addr,
@@ -3632,6 +3992,9 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
                 context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
         wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
                 &dst_map.row_pitch, &dst_map.slice_pitch);
+#else  /* STAGING_CSMT */
+        wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, dst_box, 0);
+#endif /* STAGING_CSMT */
     }
 
     bpp = dst_format->byte_count;
@@ -3645,9 +4008,18 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
         sbase = (BYTE *)src_map.data
                 + ((src_box->top / src_format->block_height) * src_map.row_pitch)
                 + ((src_box->left / src_format->block_width) * src_format->block_byte_count);
+#if defined(STAGING_CSMT)
     dbuf = (BYTE *)dst_map.data
             + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
             + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
+#else  /* STAGING_CSMT */
+    if (same_sub_resource)
+        dbuf = (BYTE *)dst_map.data
+                + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
+                + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
+    else
+        dbuf = dst_map.data;
+#endif /* STAGING_CSMT */
 
     if (src_fmt_flags & dst_fmt_flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -4040,6 +4412,7 @@ do { \
         }
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
             ~dst_texture->resource.map_binding);
 
@@ -4066,6 +4439,18 @@ release:
         wined3d_texture_decref(converted_texture);
     if (context)
         context_release(context);
+#else  /* STAGING_CSMT */
+error:
+    if (flags)
+        FIXME("    Unsupported flags %#x.\n", flags);
+
+release:
+    wined3d_resource_unmap(&dst_texture->resource, dst_sub_resource_idx);
+    if (src_texture && !same_sub_resource)
+        wined3d_resource_unmap(&src_texture->resource, src_sub_resource_idx);
+    if (converted_texture)
+        wined3d_texture_decref(converted_texture);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -4110,7 +4495,11 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_blit_surface,
 };
 
+#if defined(STAGING_CSMT)
 void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#else  /* STAGING_CSMT */
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#endif /* STAGING_CSMT */
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -4120,8 +4509,14 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#if defined(STAGING_CSMT)
     struct wined3d_texture *src_texture;
     unsigned int src_sub_resource_idx;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *src_texture = NULL;
+    unsigned int dst_w, dst_h, src_w, src_h;
+    unsigned int src_sub_resource_idx = 0;
+#endif /* STAGING_CSMT */
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
 
@@ -4134,6 +4529,7 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
+#if defined(STAGING_CSMT)
     if (src_surface)
     {
         src_texture = src_surface->container;
@@ -4145,6 +4541,86 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
         src_texture = NULL;
         src_sub_resource_idx = 0;
         src_swapchain = NULL;
+#else  /* STAGING_CSMT */
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_texture = src_surface->container;
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+    }
+
+    if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
+            || (src_texture && src_texture->sub_resources[src_sub_resource_idx].map_count))
+    {
+        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+        return WINEDDERR_SURFACEBUSY;
+    }
+
+    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
+    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
+    if (IsRectEmpty(dst_rect) || dst_rect->left > dst_w || dst_rect->left < 0
+            || dst_rect->top > dst_h || dst_rect->top < 0
+            || dst_rect->right > dst_w || dst_rect->right < 0
+            || dst_rect->bottom > dst_h || dst_rect->bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_texture)
+    {
+        src_w = wined3d_texture_get_level_width(src_texture, src_surface->texture_level);
+        src_h = wined3d_texture_get_level_height(src_texture, src_surface->texture_level);
+        if (IsRectEmpty(src_rect) || src_rect->left > src_w || src_rect->left < 0
+                || src_rect->top > src_h || src_rect->top < 0
+                || src_rect->right > src_w || src_rect->right < 0
+                || src_rect->bottom > src_h || src_rect->bottom < 0)
+        {
+            WARN("The application gave us a bad source rectangle.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+#endif /* STAGING_CSMT */
     }
 
     if (!device->d3d_initialized)
@@ -4169,6 +4645,13 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
         goto fallback;
     }
 
+#if !defined(STAGING_CSMT)
+    if (src_texture)
+        src_swapchain = src_texture->swapchain;
+    else
+        src_swapchain = NULL;
+
+#endif /* STAGING_CSMT */
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -4204,6 +4687,7 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->fill_color, &depth))
+#if defined(STAGING_CSMT)
                 return;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
@@ -4214,6 +4698,24 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3DERR_INVALIDCALL;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return WINED3D_OK;
+        }
+        else
+        {
+            if (src_ds_flags != dst_ds_flags)
+            {
+                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
+                    src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -4249,7 +4751,11 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -4288,11 +4794,18 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
                         if (!wined3d_resource_is_offscreen(&dst_texture->resource))
                         {
                             struct wined3d_context *context = context_acquire(device, dst_surface);
+#if defined(STAGING_CSMT)
                             wined3d_texture_load_location(dst_texture, surface_get_sub_resource_idx(dst_surface),
                                     context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
                         return;
+#else  /* STAGING_CSMT */
+                            surface_load_location(dst_surface, context, dst_texture->resource.draw_binding);
+                            context_release(context);
+                        }
+                        return WINED3D_OK;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4316,7 +4829,11 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4337,7 +4854,11 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4347,7 +4868,11 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -4355,6 +4880,7 @@ void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+#if defined(STAGING_CSMT)
         return;
 
 cpu:
@@ -4499,4 +5025,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             flags, fx, filter);
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+        return WINED3D_OK;
+
+cpu:
+    return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+            src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -105,11 +105,13 @@ ULONG CDECL wined3d_swapchain_decref(struct wined3d_swapchain *swapchain)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         struct wined3d_device *device = swapchain->device;
 
         if (wined3d_settings.cs_multithreaded)
             device->cs->ops->finish(device->cs);
 
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -332,7 +334,11 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (texture->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, 0, context, location);
+#else  /* STAGING_CSMT */
+            surface_load_location(back_buffer, context, location);
+#endif /* STAGING_CSMT */
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, back_buffer, NULL, location);
@@ -462,7 +468,11 @@ static void wined3d_swapchain_rotate(struct wined3d_swapchain *swapchain, struct
         sub_resource = &texture->sub_resources[0];
 
         if (!(sub_resource->locations & supported_locations))
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(sub_resource->u.surface, context, texture->resource.draw_binding);
+#endif /* STAGING_CSMT */
 
         texture_prev->texture_rgb = texture->texture_rgb;
         texture_prev->rb_multisample = texture->rb_multisample;
@@ -483,10 +493,17 @@ static void wined3d_swapchain_rotate(struct wined3d_swapchain *swapchain, struct
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
+#if defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags,
         struct wined3d_rendertarget_view *depth_stencil)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+{
+    struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
+    const struct wined3d_fb_state *fb = &swapchain->device->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_texture *logo_texture;
     struct wined3d_context *context;
@@ -507,8 +524,12 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         RECT rect = {0, 0, logo_texture->resource.width, logo_texture->resource.height};
 
         /* Blit the logo into the upper left corner of the drawable. */
+#if defined(STAGING_CSMT)
         surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &rect,
                 logo_texture->sub_resources[0].u.surface, &rect,
+#else  /* STAGING_CSMT */
+        wined3d_texture_blt(swapchain->back_buffers[0], 0, &rect, logo_texture, 0, &rect,
+#endif /* STAGING_CSMT */
                 WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -537,8 +558,13 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         if (swapchain->desc.windowed)
             MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&dst_rect, 2);
         if (wined3d_clip_blit(&clip_rect, &dst_rect, &src_rect))
+#if defined(STAGING_CSMT)
             surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &dst_rect,
                     swapchain->device->cursor_texture->sub_resources[0].u.surface, &src_rect,
+#else  /* STAGING_CSMT */
+            wined3d_texture_blt(swapchain->back_buffers[0], 0, &dst_rect,
+                    swapchain->device->cursor_texture, 0, &src_rect,
+#endif /* STAGING_CSMT */
                     WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -562,6 +588,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(back_buffer->container, 0, context, WINED3D_LOCATION_TEXTURE_RGB);
         wined3d_texture_invalidate_location(back_buffer->container, 0, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
@@ -571,6 +598,16 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
     {
         wined3d_texture_load_location(swapchain->back_buffers[0], 0, context,
                 swapchain->back_buffers[0]->resource.draw_binding);
+#else  /* STAGING_CSMT */
+        surface_load_location(back_buffer, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_texture_invalidate_location(back_buffer->container, 0, WINED3D_LOCATION_DRAWABLE);
+        swapchain->render_to_fbo = TRUE;
+        swapchain_update_draw_bindings(swapchain);
+    }
+    else
+    {
+        surface_load_location(back_buffer, context, back_buffer->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->render_to_fbo)
@@ -583,8 +620,13 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFlush();
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1)
+        gl_info->gl_ops.gl.p_glFinish();
+#endif /* STAGING_CSMT */
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc);
@@ -621,6 +663,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         wined3d_texture_validate_location(swapchain->back_buffers[swapchain->desc.backbuffer_count - 1],
                 0, WINED3D_LOCATION_DISCARDED);
 
+#if defined(STAGING_CSMT)
     if (depth_stencil)
     {
         struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(depth_stencil);
@@ -634,6 +677,21 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
             {
                 wined3d_texture_decref(swapchain->device->cs->onscreen_depth_stencil->container);
                 swapchain->device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    if (fb->depth_stencil)
+    {
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(fb->depth_stencil);
+
+        if (ds && (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || ds->container->flags & WINED3D_TEXTURE_DISCARD))
+        {
+            surface_modify_ds_location(ds, WINED3D_LOCATION_DISCARDED,
+                    fb->depth_stencil->width, fb->depth_stencil->height);
+            if (ds == swapchain->device->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(swapchain->device->onscreen_depth_stencil->container);
+                swapchain->device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -643,12 +701,21 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
 
 static void swapchain_gl_frontbuffer_updated(struct wined3d_swapchain *swapchain)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_texture *texture = swapchain->front_buffer;
     struct wined3d_surface *surface = texture->sub_resources[0].u.surface;
     struct wined3d_context *context;
 
     context = context_acquire(swapchain->device, surface);
     wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#else  /* STAGING_CSMT */
+    struct wined3d_surface *surface;
+    struct wined3d_context *context;
+
+    surface = swapchain->front_buffer->sub_resources[0].u.surface;
+    context = context_acquire(swapchain->device, surface);
+    surface_load_location(surface, context, surface->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
     context_release(context);
     SetRectEmpty(&swapchain->front_buffer_update);
 }
@@ -702,8 +769,12 @@ static void swapchain_gdi_frontbuffer_updated(struct wined3d_swapchain *swapchai
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain,
+#if defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags,
         struct wined3d_rendertarget_view *depth_stencil)
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_surface *front, *back;
     HBITMAP bitmap;
@@ -814,6 +885,7 @@ static void wined3d_swapchain_apply_sample_count_override(const struct wined3d_s
     *quality = 0;
 }
 
+#if defined(STAGING_CSMT)
 HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
     const struct wined3d_adapter *adapter = device->adapter;
@@ -877,6 +949,7 @@ HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3
     return WINED3D_OK;
 }
 
+#endif /* STAGING_CSMT */
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -994,9 +1067,67 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if defined(STAGING_CSMT)
         hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
         if (FAILED(hr))
             goto err;
+#else  /* STAGING_CSMT */
+        static const enum wined3d_format_id formats[] =
+        {
+            WINED3DFMT_D24_UNORM_S8_UINT,
+            WINED3DFMT_D32_UNORM,
+            WINED3DFMT_R24_UNORM_X8_TYPELESS,
+            WINED3DFMT_D16_UNORM,
+            WINED3DFMT_S1_UINT_D15_UNORM
+        };
+
+        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+        if (!swapchain->context)
+        {
+            ERR("Failed to create the context array.\n");
+            hr = E_OUTOFMEMORY;
+            goto err;
+        }
+        swapchain->num_contexts = 1;
+
+        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+         * You are able to add a depth + stencil surface at a later stage when you need it.
+         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+         * context, need torecreate shaders, textures and other resources.
+         *
+         * The context manager already takes care of the state problem and for the other tasks code from Reset
+         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+         * issue needs to be fixed. */
+        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+        {
+            swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+            swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+            if (swapchain->context[0]) break;
+            TRACE("Depth stencil format %s is not supported, trying next format\n",
+                  debug_d3dformat(formats[i]));
+        }
+
+        if (!swapchain->context[0])
+        {
+            WARN("Failed to create context.\n");
+            hr = WINED3DERR_NOTAVAILABLE;
+            goto err;
+        }
+
+        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+                && (!desc->enable_auto_depth_stencil
+                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+        {
+            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+        }
+        context_release(swapchain->context[0]);
+        swapchain_update_swap_interval(swapchain);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1322,7 +1453,9 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1334,9 +1467,11 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         device->cs->ops->finish(device->cs);
 
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -104,7 +104,9 @@ static void wined3d_texture_evict_sysmem(struct wined3d_texture *texture)
         sub_resource->locations &= ~WINED3D_LOCATION_SYSMEM;
     }
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
     texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
@@ -196,7 +198,11 @@ void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
 }
 
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+#if defined(STAGING_CSMT)
         struct wined3d_bo_address *data, DWORD locations, BOOL map)
+#else  /* STAGING_CSMT */
+        struct wined3d_bo_address *data, DWORD locations)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
@@ -207,10 +213,14 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if defined(STAGING_CSMT)
         if (map)
             data->buffer_object = sub_resource->map_buffer->name;
         else
             data->buffer_object = sub_resource->buffer->name;
+#else  /* STAGING_CSMT */
+        data->buffer_object = sub_resource->buffer_object;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -221,10 +231,14 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     }
     if (locations & WINED3D_LOCATION_SYSMEM)
     {
+#if defined(STAGING_CSMT)
         if (map)
             data->addr = texture->resource.map_heap_memory;
         else
             data->addr = texture->resource.heap_memory;
+#else  /* STAGING_CSMT */
+        data->addr = texture->resource.heap_memory;
+#endif /* STAGING_CSMT */
         data->addr += sub_resource->offset;
         data->buffer_object = 0;
         return;
@@ -310,6 +324,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if defined(STAGING_CSMT)
         unsigned int sub_resource_idx, struct wined3d_context *context)
 {
     struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
@@ -326,6 +341,20 @@ static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
             name, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+{
+    GLuint *buffer_object;
+
+    buffer_object = &texture->sub_resources[sub_resource_idx].buffer_object;
+    GL_EXTCALL(glDeleteBuffers(1, buffer_object));
+    checkGLcall("glDeleteBuffers");
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+    *buffer_object = 0;
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            *buffer_object, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -342,10 +371,17 @@ static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
     for (i = 0; i < sub_count; ++i)
     {
         if (texture->sub_resources[i].locations == texture->resource.map_binding
+#if defined(STAGING_CSMT)
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
             wined3d_texture_remove_buffer_object(texture, i, context);
+#else  /* STAGING_CSMT */
+                && !texture->texture_ops->texture_load_location(texture, i, context, map_binding))
+            ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
+        if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -479,6 +515,7 @@ static void wined3d_texture_unload_gl_texture(struct wined3d_texture *texture)
     resource_unload(&texture->resource);
 }
 
+#if defined(STAGING_CSMT)
 static void wined3d_texture_destroy_object(void *object)
 {
     struct wined3d_texture *texture = object;
@@ -516,6 +553,42 @@ static void wined3d_texture_destroy_object(void *object)
     texture->texture_ops->texture_cleanup_sub_resources(texture);
     wined3d_texture_unload_gl_texture(texture);
     HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+static void wined3d_texture_cleanup(struct wined3d_texture *texture)
+{
+    unsigned int sub_count = texture->level_count * texture->layer_count;
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    const struct wined3d_gl_info *gl_info;
+    GLuint buffer_object;
+    unsigned int i;
+
+    TRACE("texture %p.\n", texture);
+
+    for (i = 0; i < sub_count; ++i)
+    {
+        if (!(buffer_object = texture->sub_resources[i].buffer_object))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer_object);
+
+        /* We may not be able to get a context in wined3d_texture_cleanup() in
+         * general, but if a buffer object was previously created we can. */
+        if (!context)
+        {
+            context = context_acquire(device, NULL);
+            gl_info = context->gl_info;
+        }
+
+        GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+    }
+    if (context)
+        context_release(context);
+
+    texture->texture_ops->texture_cleanup_sub_resources(texture);
+    wined3d_texture_unload_gl_texture(texture);
+    resource_cleanup(&texture->resource);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture, struct wined3d_swapchain *swapchain)
@@ -809,6 +882,7 @@ ULONG CDECL wined3d_texture_incref(struct wined3d_texture *texture)
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 static void wined3d_texture_cleanup_main(struct wined3d_texture *texture)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -832,6 +906,7 @@ static void wined3d_texture_cleanup_main(struct wined3d_texture *texture)
     wined3d_cs_emit_destroy_object(device->cs, wined3d_texture_destroy_object, texture);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 {
     ULONG refcount;
@@ -846,8 +921,14 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(texture);
+        texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -897,7 +978,11 @@ void wined3d_texture_load(struct wined3d_texture *texture,
         TRACE("Reloading because of color key value change.\n");
         for (i = 0; i < sub_count; i++)
         {
+#if defined(STAGING_CSMT)
             if (!wined3d_texture_load_location(texture, i, context, texture->resource.map_binding))
+#else  /* STAGING_CSMT */
+            if (!texture->texture_ops->texture_load_location(texture, i, context, texture->resource.map_binding))
+#endif /* STAGING_CSMT */
                 ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
             else
                 wined3d_texture_invalidate_location(texture, i, ~texture->resource.map_binding);
@@ -915,7 +1000,11 @@ void wined3d_texture_load(struct wined3d_texture *texture,
     /* Reload the surfaces if the texture is marked dirty. */
     for (i = 0; i < sub_count; ++i)
     {
+#if defined(STAGING_CSMT)
         if (!wined3d_texture_load_location(texture, i, context,
+#else  /* STAGING_CSMT */
+        if (!texture->texture_ops->texture_load_location(texture, i, context,
+#endif /* STAGING_CSMT */
                 srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB))
             ERR("Failed to load location (srgb %#x).\n", srgb);
     }
@@ -924,8 +1013,15 @@ void wined3d_texture_load(struct wined3d_texture *texture,
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_device *device = texture->resource.device;
     wined3d_cs_emit_texture_preload(device->cs, texture);
+#else  /* STAGING_CSMT */
+    struct wined3d_context *context;
+    context = context_acquire(texture->resource.device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -988,6 +1084,7 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
 
     if (texture->lod != lod)
     {
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
         {
             struct wined3d_device *device = texture->resource.device;
@@ -995,6 +1092,7 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
             device->cs->ops->finish(device->cs);
         }
 
+#endif /* STAGING_CSMT */
         texture->lod = lod;
 
         texture->texture_rgb.base_level = ~0u;
@@ -1115,10 +1213,14 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     if (device->d3d_initialized)
+#if defined(STAGING_CSMT)
     {
         wined3d_cs_emit_evict_resource(device->cs, &texture->resource);
         device->cs->ops->finish(device->cs);
     }
+#else  /* STAGING_CSMT */
+        texture->resource.resource_ops->resource_unload(&texture->resource);
+#endif /* STAGING_CSMT */
 
     sub_resource = &texture->sub_resources[0];
     surface = sub_resource->u.surface;
@@ -1129,7 +1231,9 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
     texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 
     if ((texture->row_pitch = pitch))
         texture->slice_pitch = height * pitch;
@@ -1186,6 +1290,7 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if defined(STAGING_CSMT)
     {
         HDC dc;
         wined3d_texture_get_dc(texture, 0, &dc);
@@ -1219,6 +1324,31 @@ static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *textur
      * message. Freeing the actual memory and setting the read pointer to 0 is
      * the task of the worker thread. */
     texture->resource.map_heap_memory = NULL;
+#else  /* STAGING_CSMT */
+        wined3d_surface_create_dc(surface);
+
+    return WINED3D_OK;
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+{
+    struct wined3d_texture_sub_resource *sub_resource;
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    if (sub_resource->buffer_object)
+        return;
+
+    GL_EXTCALL(glGenBuffers(1, &sub_resource->buffer_object));
+    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, sub_resource->buffer_object));
+    GL_EXTCALL(glBufferData(GL_PIXEL_UNPACK_BUFFER, sub_resource->size, NULL, GL_STREAM_DRAW));
+    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer_object, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1336,7 +1466,9 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
                 ERR("Failed to allocate system memory.\n");
                 return FALSE;
             }
+#if defined(STAGING_CSMT)
             texture->resource.heap_memory = texture->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_USER_MEMORY:
@@ -1345,7 +1477,11 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1416,7 +1552,11 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
         WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
 
     context = context_acquire(texture->resource.device, NULL);
+#if defined(STAGING_CSMT)
     if (!wined3d_texture_load_location(texture, sub_resource_idx,
+#else  /* STAGING_CSMT */
+    if (!texture->texture_ops->texture_load_location(texture, sub_resource_idx,
+#endif /* STAGING_CSMT */
             context, texture->resource.map_binding))
     {
         ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
@@ -1462,7 +1602,9 @@ static HRESULT wined3d_texture_upload_data(struct wined3d_texture *texture,
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -1485,8 +1627,12 @@ static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int
 static BOOL texture2d_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location)
 {
+#if defined(STAGING_CSMT)
     surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location);
     return TRUE;
+#else  /* STAGING_CSMT */
+    return SUCCEEDED(surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location));
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -1576,6 +1722,10 @@ static void texture2d_cleanup_sub_resources(struct wined3d_texture *texture)
             list_remove(&overlay->overlay_entry);
             overlay->overlay_dest = NULL;
         }
+#if !defined(STAGING_CSMT)
+
+        sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -1624,7 +1774,11 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
         struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[i];
 
         if (resource->pool != WINED3D_POOL_DEFAULT
+#if defined(STAGING_CSMT)
                 && wined3d_texture_load_location(texture, i, context, resource->map_binding))
+#else  /* STAGING_CSMT */
+                && texture->texture_ops->texture_load_location(texture, i, context, resource->map_binding))
+#endif /* STAGING_CSMT */
         {
             wined3d_texture_invalidate_location(texture, i, ~resource->map_binding);
         }
@@ -1639,8 +1793,13 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if defined(STAGING_CSMT)
         if (sub_resource->buffer)
             wined3d_texture_remove_buffer_object(texture, i, context);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer_object)
+            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -1665,6 +1824,7 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
     wined3d_texture_unload_gl_texture(texture);
 }
 
+#if defined(STAGING_CSMT)
 void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx, DWORD flags)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -1746,6 +1906,7 @@ void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int
     return data;
 }
 
+#endif /* STAGING_CSMT */
 static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
@@ -1753,9 +1914,19 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_device *device = resource->device;
     unsigned int fmt_flags = resource->format_flags;
+#if defined(STAGING_CSMT)
     struct wined3d_texture *texture;
     unsigned int texture_level;
     BYTE *base_memory;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = NULL;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture *texture;
+    struct wined3d_bo_address data;
+    unsigned int texture_level;
+    BYTE *base_memory;
+    BOOL ret;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %s, flags %#x.\n",
             resource, sub_resource_idx, map_desc, debug_box(box), flags);
@@ -1802,6 +1973,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
 
     flags = wined3d_resource_sanitize_map_flags(resource, flags);
 
+#if defined(STAGING_CSMT)
     if (flags & WINED3D_MAP_NOOVERWRITE)
         FIXME("WINED3D_MAP_NOOVERWRITE is not implemented yet.\n");
 
@@ -1823,6 +1995,47 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
         wined3d_resource_wait_fence(&texture->resource);
 
     base_memory = wined3d_cs_emit_texture_map(device->cs, texture, sub_resource_idx, flags);
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
+                wined3d_debug_location(texture->resource.map_binding));
+        if ((ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
+                context, texture->resource.map_binding)))
+            wined3d_texture_validate_location(texture, sub_resource_idx, texture->resource.map_binding);
+    }
+    else
+    {
+        if (resource->usage & WINED3DUSAGE_DYNAMIC)
+            WARN_(d3d_perf)("Mapping a dynamic texture without WINED3D_MAP_DISCARD.\n");
+        ret = texture->texture_ops->texture_load_location(texture,
+                sub_resource_idx, context, texture->resource.map_binding);
+    }
+
+    if (!ret)
+    {
+        ERR("Failed to prepare location.\n");
+        context_release(context);
+        return E_OUTOFMEMORY;
+    }
+
+    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    base_memory = wined3d_texture_map_bo_address(&data, sub_resource->size,
+            gl_info, GL_PIXEL_UNPACK_BUFFER, flags);
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (context)
+        context_release(context);
+#endif /* STAGING_CSMT */
 
     if (fmt_flags & WINED3DFMT_FLAG_BROKEN_PITCH)
     {
@@ -1858,6 +2071,19 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
         }
     }
 
+#if !defined(STAGING_CSMT)
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        RECT *r = &texture->swapchain->front_buffer_update;
+
+        if (!box)
+            SetRect(r, 0, 0, resource->width, resource->height);
+        else
+            SetRect(r, box->left, box->top, box->right, box->bottom);
+        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
+    }
+
+#endif /* STAGING_CSMT */
     ++resource->map_count;
     ++sub_resource->map_count;
 
@@ -1867,6 +2093,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_texture_unmap_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx)
 {
     struct wined3d_context *context = NULL;
@@ -1922,6 +2149,16 @@ static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *reso
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_texture *texture;
     struct wined3d_device *device = resource->device;
+#else  /* STAGING_CSMT */
+static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
+{
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_device *device = resource->device;
+    const struct wined3d_gl_info *gl_info = NULL;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture *texture;
+    struct wined3d_bo_address data;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
@@ -1937,6 +2174,7 @@ static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *reso
         return WINEDDERR_NOTLOCKED;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_texture_unmap(device->cs, texture, sub_resource_idx);
 
     if (sub_resource->unmap_dirtify)
@@ -1944,6 +2182,28 @@ static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *reso
         wined3d_cs_emit_texture_changed(device->cs, texture, sub_resource_idx, sub_resource->map_buffer,
                 resource->map_heap_memory);
         sub_resource->unmap_dirtify = FALSE;
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+    }
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        if (!(sub_resource->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
+            texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(texture->swapchain);
+    }
+    else if (resource->format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
+    {
+        FIXME("Depth / stencil buffer locking is not implemented.\n");
+#endif /* STAGING_CSMT */
     }
 
     --sub_resource->map_count;
@@ -1977,7 +2237,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             && !gl_info->supported[EXT_TEXTURE_ARRAY])
     {
         WARN("OpenGL implementation does not support array textures.\n");
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1986,7 +2248,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2009,7 +2273,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             if (desc->pool != WINED3D_POOL_SCRATCH)
             {
                 WARN("Attempted to create a mipmapped/cube/array NPOT texture without unconditional NPOT support.\n");
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
 
@@ -2027,7 +2293,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             {
                 FIXME("Compressed or height scaled non-power-of-two (%ux%u) textures are not supported.\n",
                         desc->width, desc->height);
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_NOTAVAILABLE;
             }
 
@@ -2059,7 +2327,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (desc->pool == WINED3D_POOL_DEFAULT || desc->pool == WINED3D_POOL_MANAGED)
         {
             WARN("Dimensions (%ux%u) exceed the maximum texture size.\n", pow2_width, pow2_height);
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
             return WINED3DERR_NOTAVAILABLE;
         }
 
@@ -2073,6 +2343,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
@@ -2081,6 +2352,14 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
             HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (level_count != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2089,7 +2368,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2131,7 +2412,11 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (level_count > ~(SIZE_T)0 / layer_count
             || !(surfaces = wined3d_calloc(level_count * layer_count, sizeof(*surfaces))))
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
 
@@ -2174,7 +2459,11 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                     texture, idx, &sub_resource->parent, &sub_resource->parent_ops)))
             {
                 WARN("Failed to create surface parent, hr %#x.\n", hr);
+#if defined(STAGING_CSMT)
                 wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+                wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
                 return hr;
             }
 
@@ -2182,6 +2471,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
+#if defined(STAGING_CSMT)
             if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
             {
                 HDC dc;
@@ -2191,6 +2481,13 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                     return hr;
                 }
                 wined3d_texture_release_dc(texture, idx, dc);
+#else  /* STAGING_CSMT */
+            if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
+                    && FAILED(hr = wined3d_surface_create_dc(surface)))
+            {
+                wined3d_texture_cleanup(texture);
+                return hr;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -2198,7 +2495,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture3d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -2257,6 +2556,23 @@ static void texture3d_prepare_texture(struct wined3d_texture *texture, struct wi
 
 static void texture3d_cleanup_sub_resources(struct wined3d_texture *texture)
 {
+#if !defined(STAGING_CSMT)
+    unsigned int sub_count = texture->level_count * texture->layer_count;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_volume *volume;
+    unsigned int i;
+
+    for (i = 0; i < sub_count; ++i)
+    {
+        sub_resource = &texture->sub_resources[i];
+        if ((volume = sub_resource->u.volume))
+        {
+            TRACE("volume %p.\n", volume);
+
+            sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
+        }
+    }
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, texture->sub_resources[0].u.volume);
 }
 
@@ -2310,7 +2626,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (layer_count != 1)
     {
         ERR("Invalid layer count for volume texture.\n");
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return E_INVALIDARG;
     }
 
@@ -2319,6 +2637,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
@@ -2327,6 +2646,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
         HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!gl_info->supported[EXT_TEXTURE3D])
+    {
+        WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2336,6 +2663,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
@@ -2344,6 +2672,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
             HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (level_count != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2352,7 +2688,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             || desc->pool == WINED3D_POOL_SCRATCH))
     {
         WARN("Attempted to create a DYNAMIC texture in pool %s.\n", debug_d3dpool(desc->pool));
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2379,7 +2717,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -2389,7 +2729,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             0, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2402,6 +2744,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (wined3d_texture_use_pbo(texture, gl_info))
     {
         wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
         texture->resource.map_heap_memory = NULL;
         texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
     }
@@ -2409,6 +2752,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (!(volumes = wined3d_calloc(level_count, sizeof(*volumes))))
     {
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
+    }
+
+    if (!(volumes = wined3d_calloc(level_count, sizeof(*volumes))))
+    {
+        wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
 
@@ -2430,7 +2781,11 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
                 texture, i, &sub_resource->parent, &sub_resource->parent_ops)))
         {
             WARN("Failed to create volume parent, hr %#x.\n", hr);
+#if defined(STAGING_CSMT)
             wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+            wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
             return hr;
         }
 
@@ -2727,6 +3082,9 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if !defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2734,7 +3092,12 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
      * in this case. */
     if (data && FAILED(hr = wined3d_texture_upload_data(object, data)))
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_cleanup_main(object);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(object);
+        HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2744,6 +3107,7 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -2777,6 +3141,15 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_surface *surface;
+#else  /* STAGING_CSMT */
+HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_context *context = NULL;
+    struct wined3d_surface *surface;
+    HRESULT hr = WINED3D_OK;
+#endif /* STAGING_CSMT */
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -2794,6 +3167,7 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
     if (FAILED(texture->dc_hr))
         return texture->dc_hr;
@@ -2818,6 +3192,30 @@ void wined3d_texture_release_dc_cs(struct wined3d_texture *texture, unsigned int
         wined3d_texture_update_map_binding(texture);
     if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    surface_load_location(surface, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        hr = wined3d_surface_create_dc(surface);
+    if (context)
+        context_release(context);
+    if (FAILED(hr))
+        return WINED3DERR_INVALIDCALL;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+
+    *dc = surface->dc;
+    TRACE("Returning dc %p.\n", *dc);
+
+    return hr;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -2848,6 +3246,7 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
 
     return WINED3D_OK;
@@ -2981,4 +3380,16 @@ BOOL wined3d_texture_load_location(struct wined3d_texture *texture, unsigned int
         }
     }
     return ret;
+#else  /* STAGING_CSMT */
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
+
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -4474,7 +4474,11 @@ void get_projection_matrix(const struct wined3d_context *context, const struct w
         float y_offset = context->render_offscreen
                 ? (center_offset - (2.0f * y) - h) / h
                 : (center_offset - (2.0f * y) - h) / -h;
+#if defined(STAGING_CSMT)
         enum wined3d_depth_buffer_type zenable = state->fb.depth_stencil ?
+#else  /* STAGING_CSMT */
+        enum wined3d_depth_buffer_type zenable = state->fb->depth_stencil ?
+#endif /* STAGING_CSMT */
                 state->render_states[WINED3D_RS_ZENABLE] : WINED3D_ZB_FALSE;
         float z_scale = zenable ? 2.0f : 0.0f;
         float z_offset = zenable ? -1.0f : 0.0f;
@@ -5271,7 +5275,11 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
                 break;
         }
     }
+#if defined(STAGING_CSMT)
     settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb);
+#else  /* STAGING_CSMT */
+    settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb);
+#endif /* STAGING_CSMT */
     if (d3d_info->vs_clipping || !use_vs(state) || !state->render_states[WINED3D_RS_CLIPPING]
             || !state->render_states[WINED3D_RS_CLIPPLANEENABLE])
     {
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -119,6 +119,29 @@ static void wined3d_volume_download_data(struct wined3d_volume *volume,
 
 }
 
+#if !defined(STAGING_CSMT)
+static DWORD volume_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void wined3d_volume_srgb_transfer(struct wined3d_volume *volume,
         struct wined3d_context *context, BOOL dest_is_srgb)
@@ -149,6 +172,9 @@ static void wined3d_volume_srgb_transfer(struct wined3d_volume *volume,
 BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         struct wined3d_context *context, DWORD location)
 {
+#if !defined(STAGING_CSMT)
+    DWORD required_access = volume_access_from_location(location);
+#endif /* STAGING_CSMT */
     unsigned int sub_resource_idx = volume->texture_level;
     struct wined3d_texture *texture = volume->container;
     struct wined3d_texture_sub_resource *sub_resource;
@@ -157,8 +183,34 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
         wined3d_debug_location(sub_resource->locations));
 
+#if defined(STAGING_CSMT)
     if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
         return FALSE;
+#else  /* STAGING_CSMT */
+    if ((sub_resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return TRUE;
+    }
+
+    if ((texture->resource.access_flags & required_access) != required_access)
+    {
+        ERR("Operation requires %#x access, but volume only has %#x.\n",
+                required_access, texture->resource.access_flags);
+        return FALSE;
+    }
+
+    if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
+        return FALSE;
+
+    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Volume previously discarded, nothing to do.\n");
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        goto done;
+    }
+#endif /* STAGING_CSMT */
 
     switch (location)
     {
@@ -174,7 +226,11 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_volume_upload_data(texture, sub_resource_idx, context, &data);
@@ -219,7 +275,11 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -242,6 +302,9 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
             return FALSE;
     }
 
+#if !defined(STAGING_CSMT)
+done:
+#endif /* STAGING_CSMT */
     wined3d_texture_validate_location(texture, sub_resource_idx, location);
 
     return TRUE;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -91,7 +91,9 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No PS shader model limit by default. */
     ~0u,            /* No CS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
     TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -335,6 +337,7 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if defined(STAGING_CSMT)
         if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
                 && !strcmp(buffer,"disabled"))
         {
@@ -345,6 +348,9 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
 
     FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
         wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#else  /* STAGING_CSMT */
+    }
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -31,7 +31,9 @@
 #define WINE_GLAPI
 #endif
 
+#if defined(STAGING_CSMT)
 #include <assert.h>
+#endif /* STAGING_CSMT */
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -311,7 +313,9 @@ struct wined3d_settings
     unsigned int max_sm_ps;
     unsigned int max_sm_cs;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
     BOOL cs_multithreaded;
+#endif /* STAGING_CSMT */
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1367,8 +1371,10 @@ struct wined3d_occlusion_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
     DWORD samples;
     BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1404,6 +1410,7 @@ struct wined3d_timestamp_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
     UINT64 timestamp;
 };
 
@@ -1439,6 +1446,12 @@ static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wi
     for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
         dst->render_targets[i] = src->render_targets[i];
 }
+#else  /* STAGING_CSMT */
+};
+
+void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_context
 {
@@ -1454,7 +1467,9 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state current_fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_swapchain *swapchain;
     struct
@@ -1562,6 +1577,14 @@ struct wined3d_context
     GLuint                  dummy_arbfp_prog;
 };
 
+#if !defined(STAGING_CSMT)
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+};
+
+#endif /* STAGING_CSMT */
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
 
 struct StateEntry
@@ -1700,7 +1723,11 @@ void context_alloc_event_query(struct wined3d_context *context,
 void context_alloc_occlusion_query(struct wined3d_context *context,
         struct wined3d_occlusion_query *query) DECLSPEC_HIDDEN;
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
 BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -2326,7 +2353,11 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -2372,6 +2403,7 @@ struct wined3d_state
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+#if defined(STAGING_CSMT)
 struct wined3d_gl_bo
 {
     GLuint name;
@@ -2380,6 +2412,7 @@ struct wined3d_gl_bo
     UINT size;
 };
 
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2432,11 +2465,23 @@ struct wined3d_device
     struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *auto_depth_stencil_view;
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
     struct wine_rb_tree samplers;
+#else  /* STAGING_CSMT */
+
+    struct list             resources; /* a linked list to track resources created by the device */
+    struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
+    struct wine_rb_tree samplers;
+
+    /* Render Target Support */
+    struct wined3d_fb_state fb;
+    struct wined3d_surface *onscreen_depth_stencil;
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
+#endif /* STAGING_CSMT */
 
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
@@ -2484,6 +2529,7 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
 void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
 void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
@@ -2495,6 +2541,11 @@ void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_
 void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void device_delete_opengl_contexts_cs(struct wined3d_device *device,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2538,9 +2589,14 @@ struct wined3d_resource
     UINT depth;
     UINT size;
     DWORD priority;
+#if defined(STAGING_CSMT)
     void *heap_memory, *map_heap_memory;
     struct list resource_list_entry;
     LONG access_fence;
+#else  /* STAGING_CSMT */
+    void *heap_memory;
+    struct list resource_list_entry;
+#endif /* STAGING_CSMT */
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2566,7 +2622,9 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         const struct wined3d_resource_ops *resource_ops) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
 GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
@@ -2574,6 +2632,7 @@ BOOL wined3d_resource_is_offscreen(struct wined3d_resource *resource) DECLSPEC_H
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_resource_update_draw_binding(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 
+#if defined(STAGING_CSMT)
 static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
 {
     InterlockedIncrement(&resource->access_fence);
@@ -2589,6 +2648,7 @@ static inline void wined3d_resource_wait_fence(struct wined3d_resource *resource
     while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
 }
 
+#endif /* STAGING_CSMT */
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
 
@@ -2646,7 +2706,9 @@ struct wined3d_texture
     DWORD flags;
     GLenum target;
     DWORD update_map_binding;
+#if defined(STAGING_CSMT)
     HRESULT dc_hr;
+#endif /* STAGING_CSMT */
 
     GLuint rb_multisample;
     GLuint rb_resolved;
@@ -2684,8 +2746,12 @@ struct wined3d_texture
 
         unsigned int map_count;
         DWORD locations;
+#if defined(STAGING_CSMT)
         struct wined3d_gl_bo *buffer, *map_buffer;
         BOOL unmap_dirtify;
+#else  /* STAGING_CSMT */
+        GLuint buffer_object;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -2736,6 +2802,7 @@ void wined3d_texture_bind(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_texture_changed(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
         void *swap_heap_memory) DECLSPEC_HIDDEN;
@@ -2745,6 +2812,13 @@ void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_bo_address *data, DWORD locations, BOOL map) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
+        unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_texture_invalidate_location(struct wined3d_texture *texture,
@@ -2755,6 +2829,7 @@ void *wined3d_texture_map_bo_address(const struct wined3d_bo_address *data, size
         const struct wined3d_gl_info *gl_info, GLenum binding, DWORD flags) DECLSPEC_HIDDEN;
 BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 BOOL wined3d_texture_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location);
 void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx,
@@ -2770,6 +2845,15 @@ void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
         const struct wined3d_gl_info *gl_info, GLenum binding) DECLSPEC_HIDDEN;
 void wined3d_texture_unmap_internal(struct wined3d_texture *texture,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
+        struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
+void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
+        const struct wined3d_gl_info *gl_info, GLenum binding) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, DWORD location) DECLSPEC_HIDDEN;
 
@@ -2887,7 +2971,11 @@ void surface_get_drawable_size(const struct wined3d_surface *surface, const stru
         unsigned int *width, unsigned int *height) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void surface_load_location(struct wined3d_surface *surface,
+#else  /* STAGING_CSMT */
+HRESULT surface_load_location(struct wined3d_surface *surface,
+#endif /* STAGING_CSMT */
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_set_compatible_renderbuffer(struct wined3d_surface *surface,
@@ -2898,9 +2986,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
         struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -2915,10 +3005,12 @@ struct wined3d_sampler
     GLuint name;
 };
 
+#if defined(STAGING_CSMT)
 HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler, BOOL from_cs) DECLSPEC_HIDDEN;
 void wined3d_sampler_init(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
 
+#endif /* STAGING_CSMT */
 struct wined3d_vertex_declaration_element
 {
     const struct wined3d_format *format;
@@ -3014,6 +3106,7 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
         const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -3064,6 +3157,44 @@ struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HID
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
         struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD flags) DECLSPEC_HIDDEN;
+void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
+
+enum wined3d_push_constants
+{
+    WINED3D_PUSH_CONSTANTS_VS_F,
+    WINED3D_PUSH_CONSTANTS_PS_F,
+    WINED3D_PUSH_CONSTANTS_VS_I,
+    WINED3D_PUSH_CONSTANTS_PS_I,
+    WINED3D_PUSH_CONSTANTS_VS_B,
+    WINED3D_PUSH_CONSTANTS_PS_B,
+};
+
+struct wined3d_cs_ops
+{
+    void *(*require_space)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs);
+    void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
+            unsigned int start_idx, unsigned int count, const void *constants);
+};
+
+struct wined3d_cs
+{
+    const struct wined3d_cs_ops *ops;
+    struct wined3d_device *device;
+    struct wined3d_fb_state fb;
+    struct wined3d_state state;
+
+    size_t data_size;
+    void *data;
+};
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
+void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -3114,6 +3245,7 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, unsigned int start_idx,
         unsigned int count, const struct wined3d_vec4 *constants, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, unsigned int start_idx,
@@ -3171,6 +3303,14 @@ HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
 void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+
+static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    cs->ops->push_constants(cs, p, start_idx, count, constants);
+}
+#endif /* STAGING_CSMT */
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -3185,8 +3325,12 @@ enum query_state {
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
+#if defined(STAGING_CSMT)
     BOOL (*query_poll)(struct wined3d_query *query);
     BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
+#else  /* STAGING_CSMT */
+    HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_query
@@ -3200,9 +3344,11 @@ struct wined3d_query
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+#if defined(STAGING_CSMT)
 
     LONG                     counter_main, counter_retrieved;
     struct list              poll_list_entry;
+#endif /* STAGING_CSMT */
 };
 
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
@@ -3230,7 +3376,9 @@ struct wined3d_buffer
     GLenum buffer_object_usage;
     GLenum buffer_type_hint;
     DWORD flags;
+#if defined(STAGING_CSMT)
     BOOL ignore_discard;
+#endif /* STAGING_CSMT */
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -3255,6 +3403,7 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
 BYTE *buffer_get_sysmem(struct wined3d_buffer *buffer, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
         struct wined3d_buffer *src_buffer, unsigned int src_offset, unsigned int size) DECLSPEC_HIDDEN;
 HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
@@ -3263,6 +3412,13 @@ void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offs
 void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
 void buffer_create_buffer_object(struct wined3d_buffer *This,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
+        struct wined3d_buffer *src_buffer, unsigned int src_offset, unsigned int size) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
+        const struct wined3d_box *box, const void *data) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_rendertarget_view
 {
@@ -3324,8 +3480,12 @@ struct wined3d_unordered_access_view
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain,
+#if defined(STAGING_CSMT)
             const RECT *src_rect, const RECT *dst_rect, DWORD flags,
             struct wined3d_rendertarget_view *depth_stencil);
+#else  /* STAGING_CSMT */
+            const RECT *src_rect, const RECT *dst_rect, DWORD flags);
+#endif /* STAGING_CSMT */
     void (*swapchain_frontbuffer_updated)(struct wined3d_swapchain *swapchain);
 };
 
@@ -3361,8 +3521,10 @@ struct wined3d_swapchain
 
 void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT swapchain_create_context_cs(struct wined3d_device *device,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2011,7 +2011,9 @@ static void wglFinish(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
     ERR("glFinish\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -2037,7 +2039,9 @@ static void wglFlush(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
     ERR("glFlush\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
