From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

Based on patches by:
    Michael Müller <michael@fds-team.de>
    Nils Kuhnhenn <nils@volafile.io>
    Sebastian Lackner <sebastian@fds-team.de>
    Stefan Dösinger <stefan@codeweavers.com>
    Stefan Dösinger <stefandoesinger@gmx.at>

diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1337,7 +1337,11 @@ static void color_fill_test(void)
          * result on Wine.
          * {D3DFMT_YUY2,     "D3DFMT_YUY2",     BLOCKS,                              0},
          * {D3DFMT_UYVY,     "D3DFMT_UYVY",     BLOCKS,                              0}, */
+#if !defined(STAGING_CSMT)
         {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS | TODO_FILL_RETURN,           0},
+#else  /* STAGING_CSMT */
+        {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS,                              0},
+#endif /* STAGING_CSMT */
         /* Vendor-specific formats like ATI2N are a non-issue here since they're not
          * supported as offscreen plain surfaces and do not support D3DUSAGE_RENDERTARGET
          * when created as texture. */
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -701,7 +701,11 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
+#if !defined(STAGING_CSMT)
         UINT rt_height = state->fb->render_targets[0]->height;
+#else  /* STAGING_CSMT */
+        UINT rt_height = state->fb.render_targets[0]->height;
+#endif /* STAGING_CSMT */
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constants_f(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -4610,7 +4614,11 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
+#if !defined(STAGING_CSMT)
             UINT rt_height = state->fb->render_targets[0]->height;
+#else  /* STAGING_CSMT */
+            UINT rt_height = state->fb.render_targets[0]->height;
+#endif /* STAGING_CSMT */
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1353,6 +1353,11 @@ void context_release(struct wined3d_context *context)
             WARN("Context %p is not the current context.\n", context);
     }
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded && context->device->cs->thread_id != GetCurrentThreadId())
+        context->gl_info->gl_ops.gl.p_glFinish();
+
+#endif /* STAGING_CSMT */
     if (!--context->level)
     {
         if (context_restore_pixel_format(context))
@@ -1713,6 +1718,13 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+#if defined(STAGING_CSMT)
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!(ret->current_fb.render_targets = wined3d_calloc(ret->current_fb.rt_size,
+            sizeof(*ret->current_fb.render_targets))))
+        goto out;
+
+#endif /* STAGING_CSMT */
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -2033,6 +2045,9 @@ out:
     if (hdc) wined3d_release_dc(swapchain->win_handle, hdc);
     device->shader_backend->shader_free_context_data(ret);
     device->adapter->fragment_pipe->free_context_data(ret);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -2080,6 +2095,9 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     device->shader_backend->shader_free_context_data(context);
     device->adapter->fragment_pipe->free_context_data(context);
     HeapFree(GetProcessHeap(), 0, context->fbo_key);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2629,7 +2647,11 @@ static BOOL context_validate_rt_config(UINT rt_count, struct wined3d_rendertarge
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb)
 {
     struct wined3d_rendertarget_view **rts = fb->render_targets;
@@ -2638,7 +2660,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
+#if !defined(STAGING_CSMT)
     if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != state->fb
+#else  /* STAGING_CSMT */
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
+#endif /* STAGING_CSMT */
             || rt_count != gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, dsv))
@@ -2683,6 +2709,10 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
             rt_mask = context_generate_rt_mask_no_fbo(context,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0])->container : NULL);
         }
+#if defined(STAGING_CSMT)
+
+        wined3d_fb_copy(&context->current_fb, fb);
+#endif /* STAGING_CSMT */
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2722,7 +2752,12 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     gl_info->gl_ops.gl.p_glEnable(GL_SCISSOR_TEST);
     if (rt_count && gl_info->supported[ARB_FRAMEBUFFER_SRGB])
     {
+#if !defined(STAGING_CSMT)
         if (needs_srgb_write(context, state, fb))
+#else  /* STAGING_CSMT */
+        /* FIXME: The way to access the state is ugly. */
+        if (needs_srgb_write(context, &rts[0]->resource->device->cs->state, fb))
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
         else
             gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
@@ -2739,7 +2774,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
 
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view **rts = state->fb->render_targets;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view **rts = state->fb.render_targets;
+#endif /* STAGING_CSMT */
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
@@ -2769,7 +2808,11 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     DWORD rt_mask = find_draw_buffers_mask(context, state);
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -3058,6 +3101,10 @@ void context_state_drawbuf(struct wined3d_context *context, const struct wined3d
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
+#endif /* STAGING_CSMT */
 }
 
 static BOOL fixed_get_input(BYTE usage, BYTE usage_idx, unsigned int *regnum)
@@ -3489,7 +3536,11 @@ BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state)
 {
     const struct StateEntry *state_table = context->state_table;
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     unsigned int i;
     WORD map;
 
@@ -3658,6 +3709,15 @@ struct wined3d_context *context_acquire(const struct wined3d_device *device, str
 
     TRACE("device %p, target %p.\n", device, target);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded && device->cs->thread_id != GetCurrentThreadId())
+    {
+        FIXME("Acquiring a GL context from outside the CS thread.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        wined3d_cs_emit_sync(device->cs);
+    }
+
+#endif /* STAGING_CSMT */
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -18,14 +18,33 @@
 
 #include "config.h"
 #include "wine/port.h"
+#if defined(STAGING_CSMT)
+#include <assert.h>
+#endif /* STAGING_CSMT */
 #include "wined3d_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
 #define WINED3D_INITIAL_CS_SIZE 4096
 
+#if !defined(STAGING_CSMT)
 enum wined3d_cs_op
 {
+#else  /* STAGING_CSMT */
+static CRITICAL_SECTION wined3d_cs_list_mutex;
+static CRITICAL_SECTION_DEBUG wined3d_cs_list_mutex_debug =
+{
+    0, 0, &wined3d_cs_list_mutex,
+    {&wined3d_cs_list_mutex_debug.ProcessLocksList,
+    &wined3d_cs_list_mutex_debug.ProcessLocksList},
+    0, 0, {(DWORD_PTR)(__FILE__ ": wined3d_cs_list_mutex")}
+};
+static CRITICAL_SECTION wined3d_cs_list_mutex = {&wined3d_cs_list_mutex_debug, -1, 0, 0, 0, 0};
+
+enum wined3d_cs_op
+{
+    WINED3D_CS_OP_SYNC,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DISPATCH,
@@ -57,10 +76,37 @@ enum wined3d_cs_op
     WINED3D_CS_OP_RESET_STATE,
     WINED3D_CS_OP_DESTROY_OBJECT,
     WINED3D_CS_OP_QUERY_ISSUE,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_QUERY_POLL,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRELOAD_RESOURCE,
     WINED3D_CS_OP_UNLOAD_RESOURCE,
     WINED3D_CS_OP_MAP,
     WINED3D_CS_OP_UNMAP,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_PUSH_CONSTANTS,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_UPDATE_SUB_RESOURCE,
+    WINED3D_CS_OP_GET_DC,
+    WINED3D_CS_OP_RELEASE_DC,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_UPDATE_SWAP_INTERVAL,
+    WINED3D_CS_OP_SAMPLER_INIT,
+    WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION,
+    WINED3D_CS_OP_BUFFER_COPY,
+    WINED3D_CS_OP_CREATE_BUFFER_TEXTURE,
+    WINED3D_CS_OP_CREATE_TEXTURE_VIEW,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_MAP_vertex_buffers,
+    WINED3D_CS_OP_STOP,
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -296,6 +342,16 @@ struct wined3d_cs_query_issue
     DWORD flags;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_cs_query_poll
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+    BOOL *ret;
+};
+
+#endif /* STAGING_CSMT */
 struct wined3d_cs_preload_resource
 {
     enum wined3d_cs_op opcode;
@@ -327,7 +383,299 @@ struct wined3d_cs_unmap
     HRESULT *hr;
 };
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_sync
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_push_constants
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_push_constants p;
+    unsigned int start_idx;
+    unsigned int count;
+    BYTE constants[1];
+};
+
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
+
+struct wined3d_cs_set_light
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
+
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
+
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    struct wined3d_blt_fx fx;
+    enum wined3d_texture_filter_type filter;
+};
+
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    DWORD flags;
+    struct wined3d_color color;
+    float depth;
+    DWORD stencil;
+    const struct blit_shader *blitter;
+};
+
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
+struct wined3d_cs_update_sub_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    unsigned int sub_resource_idx, row_pitch, depth_pitch;
+    const struct wined3d_box *box;
+    const void *data;
+};
+
+struct wined3d_cs_sampler_init
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_sampler *sampler;
+};
+
+struct wined3d_cs_get_release_dc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+    HRESULT *hr;
+};
+
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *hr;
+};
+
+struct wined3d_cs_update_swap_interval
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_texture_add_dirty_region
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+};
+
+struct wined3d_cs_buffer_copy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *dst_buffer;
+    unsigned int dst_offset;
+    struct wined3d_buffer *src_buffer;
+    unsigned int src_offset;
+    unsigned int size;
+};
+
+struct wined3d_cs_create_buffer_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_gl_view *view;
+    struct wined3d_buffer *buffer;
+    const struct wined3d_format *view_format;
+};
+
+struct wined3d_cs_create_texture_view
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_gl_view *view;
+    GLenum view_target;
+    const struct wined3d_view_desc *desc;
+    struct wined3d_texture *texture;
+    const struct wined3d_format *view_format;
+};
+
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_map_vertex_buffers
+{
+    enum wined3d_cs_op opcode;
+    UINT src_start_idx;
+    struct wined3d_stream_info *stream_info;
+};
+
+static inline BOOL wined3d_cs_process_block(struct wined3d_cs *cs, struct wined3d_cs_block *block);
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs);
+
+/* FIXME: The list synchronization probably isn't particularly fast. */
+static void wined3d_cs_list_enqueue(struct wined3d_cs_list *list, struct wined3d_cs_block *block)
+{
+    EnterCriticalSection(&wined3d_cs_list_mutex);
+    list_add_tail(&list->blocks, &block->entry);
+    LeaveCriticalSection(&wined3d_cs_list_mutex);
+    InterlockedIncrement(&list->count);
+}
+
+static struct wined3d_cs_block *wined3d_cs_list_dequeue(struct wined3d_cs_list *list)
+{
+    struct list *head;
+
+    if (!list->count) return NULL;
+    EnterCriticalSection(&wined3d_cs_list_mutex);
+    if (!(head = list_head(&list->blocks)))
+    {
+        LeaveCriticalSection(&wined3d_cs_list_mutex);
+        return NULL;
+    }
+    list_remove(head);
+    LeaveCriticalSection(&wined3d_cs_list_mutex);
+    InterlockedDecrement(&list->count);
+
+    return LIST_ENTRY(head, struct wined3d_cs_block, entry);
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (cs->exec_list.count || cs->exec_prio_list.count)
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static struct wined3d_cs_block *wined3d_cs_dequeue_block(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+    DWORD spin_count = 0;
+
+    /* FIXME: Use an event to wait after a couple of spins. */
+    for (;;)
+    {
+        if ((block = wined3d_cs_list_dequeue(&cs->exec_prio_list)))
+            return block;
+        if ((block = wined3d_cs_list_dequeue(&cs->exec_list)))
+            return block;
+
+        spin_count++;
+        if (spin_count >= WINED3D_CS_SPIN_COUNT)
+        {
+            wined3d_cs_wait_event(cs);
+            spin_count = 0;
+        }
+    }
+}
+
+static void wined3d_cs_list_init(struct wined3d_cs_list *list)
+{
+    list_init(&list->blocks);
+}
+
+static void wined3d_cs_list_cleanup(struct wined3d_cs_list *list)
+{
+    struct wined3d_cs_block *block, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(block, next, &list->blocks, struct wined3d_cs_block, entry)
+    {
+        list_remove(&block->entry);
+        HeapFree(GetProcessHeap(), 0, block);
+    }
+}
+
+static struct wined3d_cs_block *wined3d_cs_get_block(struct wined3d_cs *cs, struct wined3d_cs_list *list)
+{
+    struct wined3d_cs_block *block;
+
+    if (!(block = wined3d_cs_list_dequeue(&cs->free_list)))
+    {
+        if (!(block = HeapAlloc(GetProcessHeap(), 0, sizeof(*block))))
+        {
+            ERR("Failed to get new block.\n");
+            return NULL;
+        }
+    }
+
+    block->pos = 0;
+    block->list = list;
+    block->fence = NULL;
+
+    return block;
+}
+
+static UINT wined3d_cs_exec_sync(struct wined3d_cs *cs, const void *data)
+{
+    return sizeof(struct wined3d_cs_sync);
+}
+
+void wined3d_cs_emit_sync(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_sync *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SYNC;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_present *op = data;
     struct wined3d_swapchain *swapchain;
@@ -336,13 +684,24 @@ static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
     swapchain = op->swapchain;
     wined3d_swapchain_set_window(swapchain, op->dst_window_override);
 
+#if !defined(STAGING_CSMT)
     swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
+#else  /* STAGING_CSMT */
+    swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags,
+            cs->state.fb.depth_stencil);
+
+    InterlockedDecrement(&cs->pending_presents);
+#endif /* STAGING_CSMT */
 
     wined3d_resource_release(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
     {
         wined3d_resource_release(&swapchain->back_buffers[i]->resource);
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
@@ -350,8 +709,14 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
 {
     struct wined3d_cs_present *op;
     unsigned int i;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    LONG pending;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRESENT;
     op->dst_window_override = dst_window_override;
     op->swapchain = swapchain;
@@ -365,34 +730,75 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
         wined3d_resource_acquire(&swapchain->back_buffers[i]->resource);
     }
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs);
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_clear *op = data;
     const struct wined3d_state *state;
     struct wined3d_device *device;
     unsigned int i;
     RECT draw_rect;
+#if !defined(STAGING_CSMT)
 
     device = cs->device;
     state = &device->state;
     wined3d_get_draw_rect(state, &draw_rect);
     device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
             &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
+#else  /* STAGING_CSMT */
+    size_t size = FIELD_OFFSET(struct wined3d_cs_clear, rects[op->rect_count]);
+
+    device = cs->device;
+    state = &cs->state;
+    wined3d_get_draw_rect(state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rects, &draw_rect, op->flags,
+#endif /* STAGING_CSMT */
             &op->color, op->depth, op->stencil);
 
     if (op->flags & WINED3DCLEAR_TARGET)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
+#if !defined(STAGING_CSMT)
             if (state->fb->render_targets[i])
                 wined3d_resource_release(state->fb->render_targets[i]->resource);
+#else  /* STAGING_CSMT */
+            if (state->fb.render_targets[i])
+                wined3d_resource_release(state->fb.render_targets[i]->resource);
+#endif /* STAGING_CSMT */
         }
     }
     if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+#if !defined(STAGING_CSMT)
         wined3d_resource_release(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        wined3d_resource_release(state->fb.depth_stencil->resource);
+
+    return size;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
@@ -402,7 +808,11 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     struct wined3d_cs_clear *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CLEAR;
     op->flags = flags;
     op->color = *color;
@@ -415,12 +825,21 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     {
         for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
         {
+#if !defined(STAGING_CSMT)
             if (state->fb->render_targets[i])
                 wined3d_resource_acquire(state->fb->render_targets[i]->resource);
+#else  /* STAGING_CSMT */
+            if (state->fb.render_targets[i])
+                wined3d_resource_acquire(state->fb.render_targets[i]->resource);
+#endif /* STAGING_CSMT */
         }
     }
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+#if !defined(STAGING_CSMT)
         wined3d_resource_acquire(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        wined3d_resource_acquire(state->fb.depth_stencil->resource);
+#endif /* STAGING_CSMT */
 
     cs->ops->submit(cs);
 }
@@ -491,14 +910,27 @@ static void release_shader_resources(const struct wined3d_state *state, unsigned
     }
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_dispatch(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_dispatch(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_dispatch *op = data;
 
+#if !defined(STAGING_CSMT)
     dispatch_compute(cs->device, &cs->device->state,
             op->group_count_x, op->group_count_y, op->group_count_z);
 
     release_shader_resources(&cs->device->state, 1u << WINED3D_SHADER_TYPE_COMPUTE);
+#else  /* STAGING_CSMT */
+    dispatch_compute(cs->device, &cs->state,
+            op->group_count_x, op->group_count_y, op->group_count_z);
+
+    release_shader_resources(&cs->state, 1u << WINED3D_SHADER_TYPE_COMPUTE);
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
@@ -506,7 +938,11 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
 {
     struct wined3d_cs_dispatch *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DISPATCH;
     op->group_count_x = group_count_x;
     op->group_count_y = group_count_y;
@@ -517,9 +953,15 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_state *state = &cs->device->state;
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_state *state = &cs->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_cs_draw *op = data;
     struct wined3d_shader *shader;
     unsigned int i;
@@ -548,11 +990,19 @@ static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
     }
     for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (state->fb->render_targets[i])
             wined3d_resource_release(state->fb->render_targets[i]->resource);
     }
     if (state->fb->depth_stencil)
         wined3d_resource_release(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        if (state->fb.render_targets[i])
+            wined3d_resource_release(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil)
+        wined3d_resource_release(state->fb.depth_stencil->resource);
+#endif /* STAGING_CSMT */
     release_shader_resources(state, ~(1u << WINED3D_SHADER_TYPE_COMPUTE));
     if ((shader = state->shader[WINED3D_SHADER_TYPE_PIXEL]))
     {
@@ -568,6 +1018,10 @@ static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
             wined3d_resource_release(view->resource);
         }
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned int start_idx,
@@ -578,7 +1032,11 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     struct wined3d_cs_draw *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DRAW;
     op->base_vertex_idx = base_vertex_idx;
     op->start_idx = start_idx;
@@ -601,11 +1059,19 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     }
     for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (state->fb->render_targets[i])
             wined3d_resource_acquire(state->fb->render_targets[i]->resource);
     }
     if (state->fb->depth_stencil)
         wined3d_resource_acquire(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        if (state->fb.render_targets[i])
+            wined3d_resource_acquire(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil)
+        wined3d_resource_acquire(state->fb.depth_stencil->resource);
+#endif /* STAGING_CSMT */
     acquire_shader_resources(state, ~(1u << WINED3D_SHADER_TYPE_COMPUTE));
     if ((shader = state->shader[WINED3D_SHADER_TYPE_PIXEL]))
     {
@@ -625,38 +1091,61 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_predication *op = data;
 
     cs->state.predicate = op->predicate;
     cs->state.predicate_value = op->value;
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
 {
     struct wined3d_cs_set_predication *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_PREDICATION;
     op->predicate = predicate;
     op->value = value;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_viewport *op = data;
 
     cs->state.viewport = op->viewport;
     device_invalidate_state(cs->device, STATE_VIEWPORT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
 {
     struct wined3d_cs_set_viewport *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
     op->viewport = *viewport;
@@ -665,17 +1154,30 @@ void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_vi
 }
 
 static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_scissor_rect *op = data;
 
     cs->state.scissor_rect = op->rect;
     device_invalidate_state(cs->device, STATE_SCISSORRECT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
 {
     struct wined3d_cs_set_scissor_rect *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
     op->rect = *rect;
@@ -684,11 +1186,26 @@ void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
 }
 
 static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+}
+
+static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_rendertarget_view *op = data;
 
+#if !defined(STAGING_CSMT)
     cs->state.fb->render_targets[op->view_idx] = op->view;
     device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+#else  /* STAGING_CSMT */
+    cs->state.fb.render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
@@ -696,21 +1213,35 @@ void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int v
 {
     struct wined3d_cs_set_rendertarget_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
     op->view_idx = view_idx;
     op->view = view;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_depth_stencil_view *op = data;
     struct wined3d_device *device = cs->device;
     struct wined3d_rendertarget_view *prev;
 
+#if !defined(STAGING_CSMT)
     if ((prev = cs->state.fb->depth_stencil))
+#else  /* STAGING_CSMT */
+    if ((prev = cs->state.fb.depth_stencil))
+#endif /* STAGING_CSMT */
     {
         struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
 
@@ -722,7 +1253,11 @@ static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
         }
     }
 
+#if !defined(STAGING_CSMT)
     cs->fb.depth_stencil = op->view;
+#else  /* STAGING_CSMT */
+    cs->state.fb.depth_stencil = op->view;
+#endif /* STAGING_CSMT */
 
     if (!prev != !op->view)
     {
@@ -739,12 +1274,17 @@ static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     }
 
     device_invalidate_state(device, STATE_FRAMEBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
 {
     struct wined3d_cs_set_depth_stencil_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
     op->view = view;
@@ -753,17 +1293,30 @@ void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3
 }
 
 static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
+    op->view = view;
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_vertex_declaration *op = data;
 
     cs->state.vertex_declaration = op->declaration;
     device_invalidate_state(cs->device, STATE_VDECL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
 {
     struct wined3d_cs_set_vertex_declaration *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
     op->declaration = declaration;
@@ -772,6 +1325,14 @@ void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3
 }
 
 static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source *op = data;
     struct wined3d_stream_state *stream;
@@ -789,6 +1350,10 @@ static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
@@ -796,17 +1361,27 @@ void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_source *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
     op->offset = offset;
     op->stride = stride;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source_freq *op = data;
     struct wined3d_stream_state *stream;
@@ -816,22 +1391,36 @@ static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const
     stream->flags = op->flags;
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
 {
     struct wined3d_cs_set_stream_source_freq *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
     op->stream_idx = stream_idx;
     op->frequency = frequency;
     op->flags = flags;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_output *op = data;
     struct wined3d_stream_output *stream;
@@ -846,6 +1435,10 @@ static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void
         InterlockedIncrement(&op->buffer->resource.bind_count);
     if (prev)
         InterlockedDecrement(&prev->resource.bind_count);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
@@ -853,16 +1446,26 @@ void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_output *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
     op->offset = offset;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_index_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -878,6 +1481,10 @@ static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
@@ -885,16 +1492,26 @@ void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buff
 {
     struct wined3d_cs_set_index_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
     op->buffer = buffer;
     op->format_id = format_id;
     op->offset = offset;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_constant_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -908,6 +1525,9 @@ static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const voi
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+#if defined(STAGING_CSMT)
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -915,16 +1535,26 @@ void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_sha
 {
     struct wined3d_cs_set_constant_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
     op->type = type;
     op->cb_idx = cb_idx;
     op->buffer = buffer;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
@@ -1001,26 +1631,44 @@ static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
 
     if (new_use_color_key)
         device_invalidate_state(cs->device, STATE_COLOR_KEY);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
 {
     struct wined3d_cs_set_texture *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE;
     op->stage = stage;
     op->texture = texture;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader_resource_view *op = data;
 
     cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, unsigned int view_idx,
@@ -1028,15 +1676,25 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, unsigned i
 {
     struct wined3d_cs_set_unordered_access_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_UNORDERED_ACCESS_VIEW;
     op->view_idx = view_idx;
     op->view = view;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_unordered_access_view *op = data;
     struct wined3d_unordered_access_view *prev;
@@ -1050,6 +1708,10 @@ static void wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, con
         InterlockedDecrement(&prev->resource->bind_count);
 
     device_invalidate_state(cs->device, STATE_UNORDERED_ACCESS_VIEW_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1057,21 +1719,35 @@ void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3
 {
     struct wined3d_cs_set_shader_resource_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
     op->type = type;
     op->view_idx = view_idx;
     op->view = view;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler *op = data;
 
     cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1079,42 +1755,70 @@ void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type
 {
     struct wined3d_cs_set_sampler *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER;
     op->type = type;
     op->sampler_idx = sampler_idx;
     op->sampler = sampler;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader *op = data;
 
     cs->state.shader[op->type] = op->shader;
     device_invalidate_state(cs->device, STATE_SHADER(op->type));
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
 {
     struct wined3d_cs_set_shader *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER;
     op->type = type;
     op->shader = shader;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_rasterizer_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_rasterizer_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_rasterizer_state *op = data;
 
     cs->state.rasterizer_state = op->state;
     device_invalidate_state(cs->device, STATE_FRONTFACE);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
@@ -1122,6 +1826,7 @@ void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
 {
     struct wined3d_cs_set_rasterizer_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_RASTERIZER_STATE;
     op->state = rasterizer_state;
@@ -1130,31 +1835,57 @@ void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
 }
 
 static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_RASTERIZER_STATE;
+    op->state = rasterizer_state;
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_render_state *op = data;
 
     cs->state.render_states[op->state] = op->value;
     device_invalidate_state(cs->device, STATE_RENDER(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
 {
     struct wined3d_cs_set_render_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
     op->state = state;
     op->value = value;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_texture_state *op = data;
 
     cs->state.texture_states[op->stage][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
@@ -1162,21 +1893,35 @@ void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
 {
     struct wined3d_cs_set_texture_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
     op->stage = stage;
     op->state = state;
     op->value = value;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler_state *op = data;
 
     cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
@@ -1184,22 +1929,36 @@ void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
 {
     struct wined3d_cs_set_sampler_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
     op->sampler_idx = sampler_idx;
     op->state = state;
     op->value = value;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_transform *op = data;
 
     cs->state.transforms[op->state] = op->matrix;
     if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->d3d_info.limits.ffp_vertex_blend_matrices))
         device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
@@ -1207,35 +1966,59 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 {
     struct wined3d_cs_set_transform *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
     op->state = state;
     op->matrix = *matrix;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_clip_plane *op = data;
 
     cs->state.clip_planes[op->plane_idx] = op->plane;
     device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
 {
     struct wined3d_cs_set_clip_plane *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
     op->plane_idx = plane_idx;
     op->plane = *plane;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_color_key *op = data;
     struct wined3d_texture *texture = op->texture;
@@ -1296,6 +2079,10 @@ static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *dat
                 break;
         }
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -1303,7 +2090,11 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
 {
     struct wined3d_cs_set_color_key *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_COLOR_KEY;
     op->texture = texture;
     op->flags = flags;
@@ -1314,22 +2105,33 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
     }
     else
         op->set = 0;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_material *op = data;
 
     cs->state.material = op->material;
     device_invalidate_state(cs->device, STATE_MATERIAL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
 {
     struct wined3d_cs_set_material *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_SET_MATERIAL;
     op->material = *material;
@@ -1340,17 +2142,37 @@ void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_ma
 static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_adapter *adapter = cs->device->adapter;
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     state_cleanup(&cs->state);
     memset(&cs->state, 0, sizeof(cs->state));
+#if !defined(STAGING_CSMT)
     state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+    if (FAILED(hr = state_init(&cs->state, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+
+    return sizeof(struct wined3d_cs_reset_state);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 {
     struct wined3d_cs_reset_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_RESET_STATE;
 
@@ -1358,17 +2180,32 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 }
 
 static void wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+}
+
+static UINT wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_destroy_object *op = data;
 
     op->callback(op->object);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void *object), void *object)
 {
     struct wined3d_cs_destroy_object *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DESTROY_OBJECT;
     op->callback = callback;
     op->object = object;
@@ -1376,40 +2213,96 @@ void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_query_issue *op = data;
     struct wined3d_query *query = op->query;
 
     query->query_ops->query_issue(query, op->flags);
+#if defined(STAGING_CSMT)
+
+    InterlockedDecrement(&query->pending);
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_cs_query_issue *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
     op->query = query;
     op->flags = flags;
 
+#if defined(STAGING_CSMT)
+    InterlockedIncrement(&query->pending);
+
+#endif /* STAGING_CSMT */
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_preload_resource(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_query_poll(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_poll *op = data;
+    struct wined3d_query *query = op->query;
+
+    *op->ret = query->query_ops->query_poll(query, op->flags);
+
+    return sizeof(*op);
+}
+
+BOOL wined3d_cs_emit_query_poll(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_cs_query_poll *op;
+    BOOL ret;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_QUERY_POLL;
+    op->query = query;
+    op->flags = flags;
+    op->ret = &ret;
+
+    cs->ops->submit_and_wait(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_preload_resource(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_preload_resource *op = data;
     struct wined3d_resource *resource = op->resource;
 
     resource->resource_ops->resource_preload(resource);
     wined3d_resource_release(resource);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
     struct wined3d_cs_preload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRELOAD_RESOURCE;
     op->resource = resource;
 
@@ -1418,20 +2311,32 @@ void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_reso
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_unload_resource(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_unload_resource(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_unload_resource *op = data;
     struct wined3d_resource *resource = op->resource;
 
     resource->resource_ops->resource_unload(resource);
     wined3d_resource_release(resource);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
     struct wined3d_cs_unload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNLOAD_RESOURCE;
     op->resource = resource;
 
@@ -1440,13 +2345,21 @@ void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resou
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_map(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_map(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_map *op = data;
     struct wined3d_resource *resource = op->resource;
 
     *op->hr = resource->resource_ops->resource_sub_resource_map(resource,
             op->sub_resource_idx, op->map_desc, op->box, op->flags);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
@@ -1455,7 +2368,11 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     struct wined3d_cs_map *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_MAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
@@ -1464,17 +2381,29 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     op->flags = flags;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_unmap(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_unmap(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_unmap *op = data;
     struct wined3d_resource *resource = op->resource;
 
     *op->hr = resource->resource_ops->resource_sub_resource_unmap(resource, op->sub_resource_idx);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx)
@@ -1482,19 +2411,805 @@ HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resourc
     struct wined3d_cs_unmap *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNMAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
 
     return hr;
 }
 
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_context *context = context_get_current();
+
+    if (context)
+        context->gl_info->gl_ops.gl.p_glFinish();
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs);
+}
+
+static const struct
+{
+    size_t offset;
+    size_t size;
+    DWORD mask;
+}
+push_constant_info[] =
+{
+    /* WINED3D_PUSH_CONSTANTS_VS_F */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
+    /* WINED3D_PUSH_CONSTANTS_PS_F */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
+    /* WINED3D_PUSH_CONSTANTS_VS_I */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
+    /* WINED3D_PUSH_CONSTANTS_PS_I */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
+    /* WINED3D_PUSH_CONSTANTS_VS_B */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
+    /* WINED3D_PUSH_CONSTANTS_PS_B */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
+};
+
+static UINT wined3d_cs_exec_push_constants(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_push_constants *op = data;
+    size_t size = FIELD_OFFSET(struct wined3d_cs_push_constants, constants[op->count * push_constant_info[op->p].size]);
+    struct wined3d_device *device = cs->device;
+    unsigned int context_count;
+    unsigned int i;
+    size_t offset;
+
+    if (op->p == WINED3D_PUSH_CONSTANTS_VS_F)
+        device->shader_backend->shader_update_float_vertex_constants(device, op->start_idx, op->count);
+    else if (op->p == WINED3D_PUSH_CONSTANTS_PS_F)
+        device->shader_backend->shader_update_float_pixel_constants(device, op->start_idx, op->count);
+
+    offset = push_constant_info[op->p].offset + op->start_idx * push_constant_info[op->p].size;
+    memcpy((BYTE *)&cs->state + offset, op->constants, op->count * push_constant_info[op->p].size);
+    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= push_constant_info[op->p].mask;
+    }
+
+    return size;
+}
+
+void wined3d_cs_emit_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_cs_push_constants *op;
+
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_push_constants, constants[count * push_constant_info[p].size]), 0);
+    op->opcode = WINED3D_CS_OP_PUSH_CONSTANTS;
+    op->p = p;
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, count * push_constant_info[p].size);
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+        {
+            ERR("Out of memory!\n");
+            return sizeof(*op);
+        }
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    object->position = op->light.position;
+    object->direction = op->light.direction;
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int light_count = device->adapter->d3d_info.limits.active_light_count;
+            unsigned int i;
+
+            /* Find a free GL light. */
+            for (i = 0; i < light_count; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_resource_release(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_release(&op->src_surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_acquire(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_acquire(&src_surface->container->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_device *device = cs->device;
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+        op->blitter->color_fill(device, op->view, &op->rect, &op->color);
+    else
+        op->blitter->depth_fill(device, op->view, &op->rect, op->flags, op->depth, op->stencil);
+
+    wined3d_resource_release(op->view->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter)
+{
+    struct wined3d_cs_clear_rtv *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->flags = flags;
+    if (flags & WINED3DCLEAR_TARGET)
+        op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+    op->blitter = blitter;
+
+    wined3d_resource_acquire(view->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_release(&op->src->resource);
+    wined3d_resource_release(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_acquire(&op->src->resource);
+    wined3d_resource_acquire(&op->dst->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_sub_resource *op = data;
+    struct wined3d_const_bo_address addr;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture;
+    unsigned int width, height, depth, level;
+
+    if (op->resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        struct wined3d_buffer *buffer = buffer_from_resource(op->resource);
+        HRESULT hr;
+
+        if (FAILED(hr = wined3d_buffer_upload_data(buffer, op->box, op->data)))
+            WARN("Failed to update buffer data, hr %#x.\n", hr);
+
+        return sizeof(*op);
+    }
+
+    texture = wined3d_texture_from_resource(op->resource);
+
+    level = op->sub_resource_idx % texture->level_count;
+    width = wined3d_texture_get_level_width(texture, level);
+    height = wined3d_texture_get_level_height(texture, level);
+    depth = wined3d_texture_get_level_depth(texture, level);
+
+    addr.buffer_object = 0;
+    addr.addr = op->data;
+
+    context = context_acquire(texture->resource.device, NULL);
+
+    /* Only load the sub-resource for partial updates. */
+    if (!op->box || (!op->box->left && !op->box->top && !op->box->front
+            && op->box->right == width && op->box->bottom == height && op->box->back == depth))
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+    else
+        wined3d_texture_load_location(texture, op->sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
+
+    wined3d_texture_upload_data(texture, op->sub_resource_idx, context, op->box, &addr, op->row_pitch, op->depth_pitch);
+
+    context_release(context);
+
+    wined3d_texture_validate_location(texture, op->sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_invalidate_location(texture, op->sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int depth_pitch)
+{
+    struct wined3d_cs_update_sub_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->resource = resource;
+    op->sub_resource_idx = sub_resource_idx;
+    op->box = box;
+    op->data = data;
+    op->row_pitch = row_pitch;
+    op->depth_pitch = depth_pitch;
+
+    /* The data pointer may go away, need to wait until the data is read. Copying the data may be faster.
+     * Don't forget to copy box as well in this case. */
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_get_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    *op->hr = wined3d_texture_get_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+    HRESULT hr;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_GET_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->hr = &hr;
+
+    cs->ops->submit_and_wait(cs);
+
+    return hr;
+}
+
+static UINT wined3d_cs_exec_release_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    *op->hr = wined3d_texture_release_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+    HRESULT hr;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_RELEASE_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->hr = &hr;
+
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
+
+    return hr;
+}
+
+#if !defined(STAGING_CSMT)
 static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_create_dummy_textures *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_swapchain_context *op = data;
+
+    *op->hr = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_create_swapchain_context *op;
+    HRESULT hr;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->hr = &hr;
+
+    cs->ops->submit_and_wait(cs);
+
+    return hr;
+}
+
+static UINT wined3d_cs_exec_update_swap_interval(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_swap_interval *op = data;
+
+    swapchain_update_swap_interval(op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_update_swap_interval *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_SWAP_INTERVAL;
+    op->swapchain = swapchain;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_sampler_init(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_sampler_init *op = data;
+
+    wined3d_sampler_init(op->sampler);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_sampler_init *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SAMPLER_INIT;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_texture_add_dirty_region(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_add_dirty_region *op = data;
+    struct wined3d_texture *texture = op->texture;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    if (!wined3d_texture_load_location(texture, op->sub_resource_idx, context, texture->resource.map_binding))
+    {
+        ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
+    }
+    else
+    {
+        wined3d_texture_invalidate_location(texture, op->sub_resource_idx, ~texture->resource.map_binding);
+    }
+    context_release(context);
+
+    wined3d_resource_release(&texture->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_add_dirty_region(struct wined3d_cs *cs,
+        struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        const struct wined3d_box *dirty_region)
+{
+    struct wined3d_cs_texture_add_dirty_region *op;
+
+    if (dirty_region)
+        WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    wined3d_resource_acquire(&texture->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_buffer_copy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_copy *op = data;
+    HRESULT hr;
+
+    if (FAILED(hr = wined3d_buffer_copy(op->dst_buffer, op->dst_offset, op->src_buffer, op->src_offset, op->size)))
+        ERR("Failed to copy buffer, hr %#x.\n", hr);
+
+    wined3d_resource_release(&op->dst_buffer->resource);
+    wined3d_resource_release(&op->src_buffer->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_copy(struct wined3d_cs *cs, struct wined3d_buffer *dst_buffer,
+        unsigned int dst_offset, struct wined3d_buffer *src_buffer, unsigned int src_offset,
+        unsigned int size)
+{
+    struct wined3d_cs_buffer_copy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_BUFFER_COPY;
+    op->dst_buffer = dst_buffer;
+    op->dst_offset = dst_offset;
+    op->src_buffer = src_buffer;
+    op->src_offset = src_offset;
+    op->size = size;
+
+    wined3d_resource_acquire(&dst_buffer->resource);
+    wined3d_resource_acquire(&src_buffer->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_create_buffer_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_buffer_texture *op = data;
+
+    create_buffer_texture(op->view, op->buffer, op->view_format);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_buffer_texture(struct wined3d_cs *cs, struct wined3d_gl_view *view,
+        struct wined3d_buffer *buffer, const struct wined3d_format *view_format)
+{
+    struct wined3d_cs_create_buffer_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CREATE_BUFFER_TEXTURE;
+    op->view = view;
+    op->buffer = buffer;
+    op->view_format = view_format;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_create_texture_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_texture_view *op = data;
+
+    create_texture_view(op->view, op->view_target, op->desc, op->texture, op->view_format);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_texture_view(struct wined3d_cs *cs, struct wined3d_gl_view *view,
+        GLenum view_target, const struct wined3d_view_desc *desc, struct wined3d_texture *texture,
+        const struct wined3d_format *view_format)
+{
+    struct wined3d_cs_create_texture_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CREATE_TEXTURE_VIEW;
+    op->view = view;
+    op->view_target = view_target;
+    op->desc = desc;
+    op->texture = texture;
+    op->view_format = view_format;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_delete_gl_contexts *op = data;
+
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_delete_gl_contexts *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_map_vertex_buffers(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_map_vertex_buffers *op = data;
+    struct wined3d_state *state = &cs->device->state;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_shader *vs;
+    unsigned int i;
+    WORD map;
+
+    /* Need any context to write to the vbo. */
+    context = context_acquire(cs->device, NULL);
+    gl_info = context->gl_info;
+
+    vs = state->shader[WINED3D_SHADER_TYPE_VERTEX];
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    context_stream_info_from_declaration(context, state, op->stream_info);
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = vs;
+
+    /* We can't convert FROM a VBO, and vertex buffers used to source into
+     * process_vertices() are unlikely to ever be used for drawing. Release
+     * VBOs in those buffers and fix up the stream_info structure.
+     *
+     * Also apply the start index. */
+    for (i = 0, map = op->stream_info->use_map; map; map >>= 1, ++i)
+    {
+        struct wined3d_stream_info_element *e;
+        struct wined3d_buffer *buffer;
+
+        if (!(map & 1))
+            continue;
+
+        e = &op->stream_info->elements[i];
+        buffer = state->streams[e->stream_idx].buffer;
+        e->data.buffer_object = 0;
+        e->data.addr += (ULONG_PTR)wined3d_buffer_load_sysmem(buffer, context);
+        if (buffer->buffer_object)
+        {
+            GL_EXTCALL(glDeleteBuffers(1, &buffer->buffer_object));
+            buffer->buffer_object = 0;
+            wined3d_buffer_invalidate_location(buffer, WINED3D_LOCATION_BUFFER);
+        }
+        if (e->data.addr)
+            e->data.addr += e->stride * op->src_start_idx;
+    }
+
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_map_vertex_buffers(struct wined3d_cs *cs, UINT src_start_idx,
+        struct wined3d_stream_info *stream_info)
+{
+    struct wined3d_cs_map_vertex_buffers *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_MAP_vertex_buffers;
+    op->src_start_idx = src_start_idx;
+    op->stream_info = stream_info;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+    /* WINED3D_CS_OP_SYNC                       */ wined3d_cs_exec_sync,
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DISPATCH                   */ wined3d_cs_exec_dispatch,
@@ -1526,13 +3241,43 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
     /* WINED3D_CS_OP_DESTROY_OBJECT             */ wined3d_cs_exec_destroy_object,
     /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+#if defined(STAGING_CSMT)
+    /* WINED3D_CS_OP_QUERY_POLL                 */ wined3d_cs_exec_query_poll,
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_PRELOAD_RESOURCE           */ wined3d_cs_exec_preload_resource,
     /* WINED3D_CS_OP_UNLOAD_RESOURCE            */ wined3d_cs_exec_unload_resource,
     /* WINED3D_CS_OP_MAP                        */ wined3d_cs_exec_map,
     /* WINED3D_CS_OP_UNMAP                      */ wined3d_cs_exec_unmap,
+#if !defined(STAGING_CSMT)
 };
 
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+#else  /* STAGING_CSMT */
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_PUSH_CONSTANTS             */ wined3d_cs_exec_push_constants,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
+    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
+    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
+    /* WINED3D_CS_OP_SAMPLER_INIT               */ wined3d_cs_exec_sampler_init,
+    /* WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION   */ wined3d_cs_exec_texture_add_dirty_region,
+    /* WINED3D_CS_OP_BUFFER_COPY                */ wined3d_cs_exec_buffer_copy,
+    /* WINED3D_CS_OP_CREATE_BUFFER_TEXTURE      */ wined3d_cs_exec_create_buffer_texture,
+    /* WINED3D_CS_OP_CREATE_TEXTURE_VIEW        */ wined3d_cs_exec_create_texture_view,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_MAP_vertex_buffers         */ wined3d_cs_exec_map_vertex_buffers,
+};
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size, int priority)
+#endif /* STAGING_CSMT */
 {
     if (size > cs->data_size)
     {
@@ -1556,6 +3301,7 @@ static void wined3d_cs_st_submit(struct wined3d_cs *cs)
     wined3d_cs_op_handlers[opcode](cs, cs->data);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
@@ -1596,15 +3342,161 @@ static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_pus
     for (i = 0, context_count = device->context_count; i < context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= push_constant_info[p].mask;
+#else  /* STAGING_CSMT */
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+};
+
+static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, int priority)
+{
+    struct wined3d_cs_block *block;
+    struct wined3d_cs_list *list = priority ? &cs->exec_prio_list : &cs->exec_list;
+    void *data;
+
+    assert(size <= sizeof(block->data));
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        block = cs->block_worker;
+        if (!block || block->pos + size > sizeof(block->data) || block->list != list)
+        {
+            if (block) wined3d_cs_mt_submit(cs);
+            block = wined3d_cs_get_block(cs, list);
+            cs->block_worker = block;
+        }
     }
+    else
+    {
+        block = cs->block_main;
+        if (!block || block->pos + size > sizeof(block->data) || block->list != list)
+        {
+            if (block) wined3d_cs_mt_submit(cs);
+            block = wined3d_cs_get_block(cs, list);
+            cs->block_main = block;
+        }
+    }
+
+    data = &block->data[block->pos];
+    block->pos += size;
+
+    return data;
 }
 
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        block = cs->block_worker;
+        cs->block_worker = NULL;
+
+        wined3d_cs_process_block(cs, block);
+    }
+    else
+    {
+        block = cs->block_main;
+        cs->block_main = NULL;
+
+        wined3d_cs_list_enqueue(block->list, block);
+
+        if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+            SetEvent(cs->event);
+#endif /* STAGING_CSMT */
+    }
+}
+
+#if !defined(STAGING_CSMT)
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
     wined3d_cs_st_require_space,
     wined3d_cs_st_submit,
     wined3d_cs_st_push_constants,
 };
+#else  /* STAGING_CSMT */
+static void wined3d_cs_mt_submit_and_wait(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+    BOOL fence = FALSE;
+
+    block = (cs->thread_id == GetCurrentThreadId()) ? cs->block_worker : cs->block_main;
+    block->fence = &fence;
+    wined3d_cs_mt_submit(cs);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_and_wait,
+};
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    assert(cs->thread_id != GetCurrentThreadId());
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs);
+}
+
+static inline BOOL wined3d_cs_process_block(struct wined3d_cs *cs, struct wined3d_cs_block *block)
+{
+    UINT pos = 0;
+    BOOL ret = TRUE;
+
+    while (pos < block->pos)
+    {
+        enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&block->data[pos];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            ret = FALSE;
+            break;
+        }
+
+        pos += wined3d_cs_op_handlers[opcode](cs, &block->data[pos]);
+    }
+
+    if (block->fence)
+        InterlockedExchange(block->fence, TRUE);
+
+    wined3d_cs_list_enqueue(&cs->free_list, block);
+    return ret;
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+
+    TRACE("Started.\n");
+
+    for (;;)
+    {
+        struct wined3d_cs_block *block;
+        block = wined3d_cs_dequeue_block(cs);
+        if (!wined3d_cs_process_block(cs, block))
+            break;
+    }
+
+    TRACE("Stopped.\n");
+    return 0;
+}
+#endif /* STAGING_CSMT */
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
@@ -1614,34 +3506,97 @@ struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
     if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
         return NULL;
 
+#if !defined(STAGING_CSMT)
     if (!(cs->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*cs->fb.render_targets))))
+#else  /* STAGING_CSMT */
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+#endif /* STAGING_CSMT */
     {
         HeapFree(GetProcessHeap(), 0, cs);
         return NULL;
     }
 
+#if !defined(STAGING_CSMT)
     state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
 
+#endif /* STAGING_CSMT */
     cs->ops = &wined3d_cs_st_ops;
     cs->device = device;
 
     cs->data_size = WINED3D_INITIAL_CS_SIZE;
     if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+#if !defined(STAGING_CSMT)
     {
         state_cleanup(&cs->state);
         HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
         HeapFree(GetProcessHeap(), 0, cs);
         return NULL;
+#else  /* STAGING_CSMT */
+        goto err;
+
+    if (!(cs->event = CreateEventW(NULL, FALSE, FALSE, NULL)))
+    {
+        ERR("Failed to allocate event, err %#x.\n", GetLastError());
+        goto err;
+    }
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        cs->ops = &wined3d_cs_mt_ops;
+
+        wined3d_cs_list_init(&cs->free_list);
+        wined3d_cs_list_init(&cs->exec_list);
+        wined3d_cs_list_init(&cs->exec_prio_list);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, &cs->thread_id)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
+#endif /* STAGING_CSMT */
     }
 
     return cs;
+#if defined(STAGING_CSMT)
+
+err:
+    state_cleanup(&cs->state);
+    if (cs->event) CloseHandle(cs->event);
+    HeapFree(GetProcessHeap(), 0, cs->data);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+#if !defined(STAGING_CSMT)
     state_cleanup(&cs->state);
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+#else  /* STAGING_CSMT */
+    DWORD ret;
+
+    state_cleanup(&cs->state);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+
+        wined3d_cs_list_cleanup(&cs->exec_prio_list);
+        wined3d_cs_list_cleanup(&cs->exec_list);
+        wined3d_cs_list_cleanup(&cs->free_list);
+    }
+
+    HeapFree(GetProcessHeap(), 0, cs->block_main);
+    HeapFree(GetProcessHeap(), 0, cs->block_worker);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs->data);
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -223,7 +223,9 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     struct wined3d_surface *target = rtv ? wined3d_rendertarget_view_get_surface(rtv) : NULL;
     struct wined3d_rendertarget_view *dsv = fb->depth_stencil;
     struct wined3d_surface *depth_stencil = dsv ? wined3d_rendertarget_view_get_surface(dsv) : NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     UINT drawable_width, drawable_height;
     struct wined3d_color corrected_color;
@@ -286,10 +288,18 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? dsv->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
+#if !defined(STAGING_CSMT)
         surface_load_location(depth_stencil, context, location);
     }
 
     if (!context_apply_clear_state(context, state, rt_count, fb))
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(depth_stencil->container, dsv->sub_resource_idx,
+                context, location);
+    }
+
+    if (!context_apply_clear_state(context, rt_count, fb))
+#endif /* STAGING_CSMT */
     {
         context_release(context);
         WARN("Failed to apply clear state, skipping clear.\n");
@@ -346,7 +356,11 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
             wined3d_texture_invalidate_location(texture, rtv->sub_resource_idx, ~rtv->resource->draw_binding);
         }
 
+#if !defined(STAGING_CSMT)
         if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, fb))
+#else  /* STAGING_CSMT */
+        if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, &device->cs->state, fb))
+#endif /* STAGING_CSMT */
         {
             if (rt_count > 1)
                 WARN("Clearing multiple sRGB render targets with no GL_ARB_framebuffer_sRGB "
@@ -606,7 +620,44 @@ out:
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void create_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+
+    if (gl_info->supported[ARB_SAMPLER_OBJECTS])
+    {
+        /* In SM4+ shaders there is a separation between resources and samplers. Some shader
+         * instructions allow access to resources without using samplers.
+         * In GLSL, resources are always accessed through sampler or image variables. The default
+         * sampler object is used to emulate the direct resource access when there is no sampler state
+         * to use.
+         */
+        GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
+        checkGLcall("Create default sampler");
+
+        /* In D3D10+, a NULL sampler maps to the default sampler state. */
+        GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
+        checkGLcall("Create null sampler");
+    }
+    else
+    {
+        device->default_sampler = 0;
+        device->null_sampler = 0;
+    }
+}
+
+/* Context activation is done by the caller. */
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -740,6 +791,9 @@ static void create_dummy_textures(struct wined3d_device *device, struct wined3d_
     }
 
     context_bind_dummy_textures(device, context);
+#if defined(STAGING_CSMT)
+    create_default_samplers(device, context);
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -774,6 +828,7 @@ static void destroy_dummy_textures(struct wined3d_device *device, struct wined3d
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 static void create_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
@@ -807,6 +862,7 @@ static void create_default_samplers(struct wined3d_device *device, struct wined3
 }
 
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void destroy_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
@@ -953,7 +1009,11 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     if (device->fb.render_targets)
+#else  /* STAGING_CSMT */
+    if (device->state.fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -971,9 +1031,13 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
     struct wined3d_context *context;
+#else  /* STAGING_CSMT */
+    struct wined3d_swapchain *swapchain = NULL;
+#endif /* STAGING_CSMT */
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -984,9 +1048,11 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     if (!(device->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*device->fb.render_targets))))
         return E_OUTOFMEMORY;
 
+#endif /* STAGING_CSMT */
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -1037,17 +1103,23 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL);
 
     create_dummy_textures(device, context);
     create_default_samplers(device, context);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#endif /* STAGING_CSMT */
 
     device->contexts[0]->last_was_rhw = 0;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
+#if !defined(STAGING_CSMT)
     context_release(context);
 
+#endif /* STAGING_CSMT */
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -1063,7 +1135,9 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1120,8 +1194,10 @@ static void device_free_sampler(struct wine_rb_entry *entry, void *context)
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     UINT i;
 
     TRACE("device %p.\n", device);
@@ -1129,11 +1205,16 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     /* I don't think that the interface guarantees that the device is destroyed from the same thread
      * it was created. Thus make sure a context is active for the glDelete* calls
      */
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
 
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
@@ -1142,6 +1223,14 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 
     state_unbind_resources(&device->state);
 
+#if defined(STAGING_CSMT)
+    if (device->auto_depth_stencil_view)
+    {
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
+        device->auto_depth_stencil_view = NULL;
+    }
+
+#endif /* STAGING_CSMT */
     /* Unload resources */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
@@ -1151,6 +1240,7 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 
     wine_rb_clear(&device->samplers, device_free_sampler, NULL);
 
+#if !defined(STAGING_CSMT)
     /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
      * private data, it might contain opengl pointers
      */
@@ -1191,6 +1281,11 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     {
         wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
     }
+#else  /* STAGING_CSMT */
+    /* FIXME: Is this in the right place??? */
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
+
+#endif /* STAGING_CSMT */
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
@@ -1208,9 +1303,11 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     device->fb.render_targets = NULL;
 
+#endif /* STAGING_CSMT */
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1255,7 +1352,11 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     /* We can not acquire the context unless there is a swapchain. */
     if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+#if !defined(STAGING_CSMT)
             !wined3d_settings.emulated_textureram)
+#else  /* STAGING_CSMT */
+            !wined3d_settings.emulated_textureram && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
     {
         GLint vram_free_kb;
         UINT64 vram_free;
@@ -1596,6 +1697,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             light->direction.x, light->direction.y, light->direction.z,
             light->range, light->falloff, light->theta, light->phi);
 
+#if !defined(STAGING_CSMT)
     /* Update the live definitions if the light is currently assigned a glIndex. */
     if (object->glIndex != -1 && !device->recording)
     {
@@ -1604,6 +1706,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
         device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
     }
 
+#endif /* STAGING_CSMT */
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1683,6 +1786,11 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+#if defined(STAGING_CSMT)
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1755,12 +1863,14 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
+#if !defined(STAGING_CSMT)
             if (!device->recording)
             {
                 device_invalidate_state(device, STATE_LIGHT_TYPE);
                 device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
             }
 
+#endif /* STAGING_CSMT */
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1803,6 +1913,7 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
+#if !defined(STAGING_CSMT)
 
             /* i == light_info->glIndex */
             if (!device->recording)
@@ -1810,9 +1921,15 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 device_invalidate_state(device, STATE_LIGHT_TYPE);
                 device_invalidate_state(device, STATE_ACTIVELIGHT(i));
             }
+#endif /* STAGING_CSMT */
         }
     }
 
+#if defined(STAGING_CSMT)
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -2028,7 +2145,11 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(dst_texture->resource.format_flags & WINED3DFMT_FLAG_DEPTH))
         return;
 
+#if !defined(STAGING_CSMT)
     if (!(src_view = state->fb->depth_stencil))
+#else  /* STAGING_CSMT */
+    if (!(src_view = state->fb.depth_stencil))
+#endif /* STAGING_CSMT */
         return;
     if (src_view->resource->type == WINED3D_RTYPE_BUFFER)
     {
@@ -2416,7 +2537,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2465,7 +2590,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2510,7 +2639,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.vs_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.vs_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2649,7 +2782,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2698,7 +2835,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2744,7 +2885,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.ps_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.ps_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2901,7 +3046,9 @@ void CDECL wined3d_device_set_unordered_access_view(struct wined3d_device *devic
         wined3d_unordered_access_view_decref(prev);
 }
 
+#if !defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 #define copy_and_next(dest, src, size) memcpy(dest, src, size); dest += (size)
 static HRESULT process_vertices_strided(const struct wined3d_device *device, DWORD dwDestIndex, DWORD dwCount,
         const struct wined3d_stream_info *stream_info, struct wined3d_buffer *dest, DWORD flags,
@@ -3177,6 +3324,7 @@ HRESULT CDECL wined3d_device_process_vertices(struct wined3d_device *device,
         UINT src_start_idx, UINT dst_idx, UINT vertex_count, struct wined3d_buffer *dst_buffer,
         const struct wined3d_vertex_declaration *declaration, DWORD flags, DWORD dst_fvf)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_state *state = &device->state;
     struct wined3d_stream_info stream_info;
     const struct wined3d_gl_info *gl_info;
@@ -3185,6 +3333,10 @@ HRESULT CDECL wined3d_device_process_vertices(struct wined3d_device *device,
     unsigned int i;
     HRESULT hr;
     WORD map;
+#else  /* STAGING_CSMT */
+    struct wined3d_stream_info stream_info;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_start_idx %u, dst_idx %u, vertex_count %u, "
             "dst_buffer %p, declaration %p, flags %#x, dst_fvf %#x.\n",
@@ -3194,6 +3346,7 @@ HRESULT CDECL wined3d_device_process_vertices(struct wined3d_device *device,
     if (declaration)
         FIXME("Output vertex declaration not implemented yet.\n");
 
+#if !defined(STAGING_CSMT)
     /* Need any context to write to the vbo. */
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
@@ -3229,12 +3382,17 @@ HRESULT CDECL wined3d_device_process_vertices(struct wined3d_device *device,
         if (e->data.addr)
             e->data.addr += e->stride * src_start_idx;
     }
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_map_vertex_buffers(device->cs, src_start_idx, &stream_info);
+#endif /* STAGING_CSMT */
 
     hr = process_vertices_strided(device, dst_idx, vertex_count,
             &stream_info, dst_buffer, flags, dst_fvf);
 
+#if !defined(STAGING_CSMT)
     context_release(context);
 
+#endif /* STAGING_CSMT */
     return hr;
 }
 
@@ -3521,8 +3679,10 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3531,6 +3691,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL);
     /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
     context->gl_info->gl_ops.gl.p_glFlush();
@@ -3538,6 +3699,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
      * fails. */
     context_release(context);
 
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3545,6 +3707,10 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, debug_color(color), depth, stencil);
 
@@ -3556,7 +3722,11 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *ds = fb->depth_stencil;
+#endif /* STAGING_CSMT */
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3565,8 +3735,13 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
+#if !defined(STAGING_CSMT)
             if (ds->width < device->fb.render_targets[0]->width
                     || ds->height < device->fb.render_targets[0]->height)
+#else  /* STAGING_CSMT */
+            if (ds->width < fb->render_targets[0]->width
+                    || ds->height < fb->render_targets[0]->height)
+#endif /* STAGING_CSMT */
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3629,8 +3804,13 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
+#if !defined(STAGING_CSMT)
     else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
         device_invalidate_state(device, STATE_POINT_ENABLE);
+#else  /* STAGING_CSMT */
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3690,11 +3870,17 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+#else  /* STAGING_CSMT */
+/* Context activation is done by the caller. */
+static void wined3d_device_update_texture_3d(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         struct wined3d_texture *src_texture, unsigned int src_level,
         struct wined3d_texture *dst_texture, unsigned int level_count)
 {
     struct wined3d_const_bo_address data;
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     struct wined3d_map_desc src;
     HRESULT hr = WINED3D_OK;
@@ -3718,6 +3904,13 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
     }
 
     context = context_acquire(device, NULL);
+#else  /* STAGING_CSMT */
+    struct wined3d_map_desc src;
+    unsigned int i;
+
+    TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            context, src_texture, src_level, dst_texture, level_count);
+#endif /* STAGING_CSMT */
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3725,15 +3918,22 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 
     for (i = 0; i < level_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
                 src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
             goto done;
+#else  /* STAGING_CSMT */
+        if (FAILED(wined3d_resource_map(&src_texture->resource,
+                src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
+            return;
+#endif /* STAGING_CSMT */
 
         data.buffer_object = 0;
         data.addr = src.data;
         wined3d_texture_upload_data(dst_texture, i, context, NULL, &data, src.row_pitch, src.slice_pitch);
         wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
 
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
             goto done;
     }
@@ -3741,16 +3941,89 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 done:
     context_release(context);
     return hr;
+#else  /* STAGING_CSMT */
+        if (FAILED(wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            return;
+    }
+}
+
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int level_count, i, j;
+
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (dst_texture->resource.type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    wined3d_texture_load(dst_texture, context, FALSE);
+
+    /* Update every surface level of the texture. */
+    switch (dst_texture->resource.type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < src_texture->layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    HRESULT hr;
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return;
+                    }
+                }
+            }
+            break;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            wined3d_device_update_texture_3d(context,
+                    src_texture, src_skip_levels, dst_texture, level_count);
+            break;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", dst_texture->resource.type);
+    }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
 {
     unsigned int src_size, dst_size, src_skip_levels = 0;
+#if !defined(STAGING_CSMT)
     unsigned int layer_count, level_count, i, j;
     enum wined3d_resource_type type;
     HRESULT hr;
     struct wined3d_context *context;
+#else  /* STAGING_CSMT */
+    unsigned int layer_count;
+    enum wined3d_resource_type type;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3787,6 +4060,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     level_count = min(wined3d_texture_get_level_count(src_texture),
             wined3d_texture_get_level_count(dst_texture));
 
@@ -3809,9 +4083,21 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     context_release(context);
 
     /* Update every surface level of the texture. */
+#else  /* STAGING_CSMT */
+    /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
+     * rejects mismatching formats, and we can't report the error back after dispatching the
+     * call. */
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+#endif /* STAGING_CSMT */
     switch (type)
     {
         case WINED3D_RTYPE_TEXTURE_2D:
+#if !defined(STAGING_CSMT)
         {
             unsigned int src_levels = src_texture->level_count;
             unsigned int dst_levels = dst_texture->level_count;
@@ -3844,6 +4130,38 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             FIXME("Unsupported texture type %#x.\n", type);
             return WINED3DERR_INVALIDCALL;
     }
+#else  /* STAGING_CSMT */
+            break;
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            src_size = max(src_texture->resource.width, src_texture->resource.height);
+            src_size = max(src_size, src_texture->resource.depth);
+            dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+            dst_size = max(dst_size, dst_texture->resource.depth);
+
+            while (src_size > dst_size)
+            {
+                src_size >>= 1;
+                ++src_skip_levels;
+            }
+
+            if (wined3d_texture_get_level_width(src_texture, src_skip_levels) != dst_texture->resource.width
+                    || wined3d_texture_get_level_height(src_texture, src_skip_levels) != dst_texture->resource.height
+                    || wined3d_texture_get_level_depth(src_texture, src_skip_levels) != dst_texture->resource.depth)
+            {
+                WARN("Source and destination dimensions do not match.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+            break;
+
+        default:
+            break;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3891,8 +4209,13 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
+#endif /* STAGING_CSMT */
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -4029,10 +4352,16 @@ void CDECL wined3d_device_copy_resource(struct wined3d_device *device,
 
     if (dst_resource->type == WINED3D_RTYPE_BUFFER)
     {
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_buffer_copy(buffer_from_resource(dst_resource), 0,
                 buffer_from_resource(src_resource), 0,
                 dst_resource->size)))
             ERR("Failed to copy buffer, hr %#x.\n", hr);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_buffer_copy(device->cs, buffer_from_resource(dst_resource), 0,
+                buffer_from_resource(src_resource), 0,
+                dst_resource->size);
+#endif /* STAGING_CSMT */
         return;
     }
 
@@ -4081,6 +4410,9 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     struct wined3d_texture *dst_texture, *src_texture;
     RECT dst_rect, src_rect;
     HRESULT hr;
+#if defined(STAGING_CSMT)
+    struct wined3d_box dst_box;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, dst_resource %p, dst_sub_resource_idx %u, dst_x %u, dst_y %u, dst_z %u, "
             "src_resource %p, src_sub_resource_idx %u, src_box %s.\n",
@@ -4153,8 +4485,14 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
             return WINED3DERR_INVALIDCALL;
         }
 
+#if !defined(STAGING_CSMT)
         return wined3d_buffer_copy(buffer_from_resource(dst_resource), dst_x,
                 buffer_from_resource(src_resource), src_offset, size);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_buffer_copy(device->cs, buffer_from_resource(dst_resource), dst_x,
+                buffer_from_resource(src_resource), src_offset, size);
+        return WINED3D_OK;
+#endif /* STAGING_CSMT */
     }
 
     if (dst_resource->type != WINED3D_RTYPE_TEXTURE_2D)
@@ -4168,6 +4506,16 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
 
     if (src_box)
     {
+#if defined(STAGING_CSMT)
+        if ((src_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+                && !wined3d_texture_check_block_align(src_texture,
+                src_sub_resource_idx % src_texture->level_count, src_box))
+        {
+            WARN("Source box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+#endif /* STAGING_CSMT */
         SetRect(&src_rect, src_box->left, src_box->top, src_box->right, src_box->bottom);
     }
     else
@@ -4181,6 +4529,25 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     SetRect(&dst_rect, dst_x, dst_y, dst_x + (src_rect.right - src_rect.left),
             dst_y + (src_rect.bottom - src_rect.top));
 
+#if defined(STAGING_CSMT)
+    if (dst_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        dst_box.left = dst_rect.left;
+        dst_box.top = dst_rect.top;
+        dst_box.front = 0;
+        dst_box.right = dst_rect.right;
+        dst_box.bottom = dst_rect.bottom;
+        dst_box.back = 1;
+
+        if(!wined3d_texture_check_block_align(dst_texture,
+                dst_sub_resource_idx % dst_texture->level_count, &dst_box))
+        {
+            WARN("Destination box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+    }
+
+#endif /* STAGING_CSMT */
     if (FAILED(hr = wined3d_texture_blt(dst_texture, dst_sub_resource_idx, &dst_rect,
             src_texture, src_sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_POINT)))
         WARN("Failed to blit, hr %#x.\n", hr);
@@ -4193,8 +4560,10 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         unsigned int depth_pitch)
 {
     unsigned int width, height, depth, level;
+#if !defined(STAGING_CSMT)
     struct wined3d_const_bo_address addr;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     struct wined3d_texture *texture;
 
     TRACE("device %p, resource %p, sub_resource_idx %u, box %s, data %p, row_pitch %u, depth_pitch %u.\n",
@@ -4202,18 +4571,24 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
 
     if (resource->type == WINED3D_RTYPE_BUFFER)
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_buffer *buffer = buffer_from_resource(resource);
         HRESULT hr;
 
+#endif /* STAGING_CSMT */
         if (sub_resource_idx > 0)
         {
             WARN("Invalid sub_resource_idx %u.\n", sub_resource_idx);
             return;
         }
 
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_buffer_upload_data(buffer, box, data)))
             WARN("Failed to update buffer data, hr %#x.\n", hr);
 
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
+#endif /* STAGING_CSMT */
         return;
     }
 
@@ -4244,6 +4619,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         return;
     }
 
+#if !defined(STAGING_CSMT)
     addr.buffer_object = 0;
     addr.addr = data;
 
@@ -4263,6 +4639,9 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
 
     wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_invalidate_location(texture, sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -4311,10 +4690,15 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
         return blitter->color_fill(device, view, rect, color);
     else
         return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4328,20 +4712,31 @@ struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(co
         return NULL;
     }
 
+#if !defined(STAGING_CSMT)
     return device->fb.render_targets[view_idx];
+#else  /* STAGING_CSMT */
+    return device->state.fb.render_targets[view_idx];
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
+#if !defined(STAGING_CSMT)
     return device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+    return device->state.fb.depth_stencil;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
         unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
 {
     struct wined3d_rendertarget_view *prev;
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state *fb = &device->state.fb;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -4378,13 +4773,21 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     }
 
 
+#if !defined(STAGING_CSMT)
     prev = device->fb.render_targets[view_idx];
+#else  /* STAGING_CSMT */
+    prev = fb->render_targets[view_idx];
+#endif /* STAGING_CSMT */
     if (view == prev)
         return WINED3D_OK;
 
     if (view)
         wined3d_rendertarget_view_incref(view);
+#if !defined(STAGING_CSMT)
     device->fb.render_targets[view_idx] = view;
+#else  /* STAGING_CSMT */
+    fb->render_targets[view_idx] = view;
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -4396,18 +4799,29 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state *fb = &device->state.fb;
+#endif /* STAGING_CSMT */
     struct wined3d_rendertarget_view *prev;
 
     TRACE("device %p, view %p.\n", device, view);
 
+#if !defined(STAGING_CSMT)
     prev = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+    prev = fb->depth_stencil;
+#endif /* STAGING_CSMT */
     if (prev == view)
     {
         TRACE("Trying to do a NOP SetRenderTarget operation.\n");
         return;
     }
 
+#if !defined(STAGING_CSMT)
     if ((device->fb.depth_stencil = view))
+#else  /* STAGING_CSMT */
+    if ((fb->depth_stencil = view))
+#endif /* STAGING_CSMT */
         wined3d_rendertarget_view_incref(view);
     wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
     if (prev)
@@ -4641,19 +5055,26 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
     }
 }
 
+#if !defined(STAGING_CSMT)
 static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
     struct wined3d_resource *resource, *cursor;
+#else  /* STAGING_CSMT */
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
+#if !defined(STAGING_CSMT)
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Unloading resource %p.\n", resource);
         wined3d_cs_emit_unload_resource(device->cs, resource);
     }
 
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
@@ -4685,12 +5106,30 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+#if defined(STAGING_CSMT)
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_unload_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     struct wined3d_texture *target;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4707,6 +5146,7 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
+#if !defined(STAGING_CSMT)
     /* Recreate the primary swapchain's context */
     swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
     if (!swapchain->context)
@@ -4719,10 +5159,15 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
 
     target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
     if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+#else  /* STAGING_CSMT */
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
+#endif /* STAGING_CSMT */
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
+#if !defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, swapchain->context);
         return E_FAIL;
     }
@@ -4732,6 +5177,12 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
     create_dummy_textures(device, context);
     create_default_samplers(device, context);
     context_release(context);
+#else  /* STAGING_CSMT */
+        return hr;
+    }
+
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4768,10 +5219,16 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->cursor_texture);
             device->cursor_texture = NULL;
         }
+#if !defined(STAGING_CSMT)
         state_unbind_resources(&device->state);
     }
 
     if (device->fb.render_targets)
+#else  /* STAGING_CSMT */
+    }
+
+    if (device->state.fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4782,6 +5239,13 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
 
     if (reset_state)
     {
+#if defined(STAGING_CSMT)
+        state_unbind_resources(&device->state);
+    }
+
+    if (reset_state)
+    {
+#endif /* STAGING_CSMT */
         LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
         {
             TRACE("Enumerating resource %p.\n", resource);
@@ -4946,27 +5410,48 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
+#if !defined(STAGING_CSMT)
         state_init(&device->state, &device->fb, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
+                &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
+            ERR("Failed to initialize device state, hr %#x.\n", hr);
+#endif /* STAGING_CSMT */
         device->update_state = &device->state;
 
         device_init_swapchain_state(device, swapchain);
     }
     else if (device->back_buffer_view)
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *view = device->back_buffer_view;
         struct wined3d_state *state = &device->state;
 
         wined3d_device_set_rendertarget_view(device, 0, view, FALSE);
+#else  /* STAGING_CSMT */
+        struct wined3d_state *state = &device->state;
+
+        wined3d_device_set_rendertarget_view(device, 0, device->back_buffer_view, FALSE);
+#endif /* STAGING_CSMT */
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
+#if !defined(STAGING_CSMT)
         state->viewport.width = view->width;
         state->viewport.height = view->height;
         wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
 
         SetRect(&state->scissor_rect, 0, 0, view->width, view->height);
+#else  /* STAGING_CSMT */
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
+        wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
+
+        SetRect(&state->scissor_rect, 0, 0,
+                swapchain->desc.backbuffer_width, swapchain->desc.backbuffer_height);
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4974,7 +5459,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     {
         if (reset_state)
             hr = create_primary_opengl_context(device, swapchain);
+#if !defined(STAGING_CSMT)
         swapchain_update_swap_interval(swapchain);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
+#endif /* STAGING_CSMT */
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -5058,11 +5547,19 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
+#if !defined(STAGING_CSMT)
             if ((rtv = device->fb.render_targets[i]) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+            if ((rtv = device->state.fb.render_targets[i]) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
                 ERR("Resource %p is still in use as render target %u.\n", resource, i);
         }
 
+#if !defined(STAGING_CSMT)
         if ((rtv = device->fb.depth_stencil) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+        if ((rtv = device->state.fb.depth_stencil) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
             ERR("Resource %p is still in use as depth/stencil buffer.\n", resource);
     }
 
@@ -5188,8 +5685,17 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
+#if !defined(STAGING_CSMT)
     state_init(&device->state, &device->fb, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
+            &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
+    {
+        ERR("Failed to initialize device state, hr %#x.\n", hr);
+        goto err;
+    }
+#endif /* STAGING_CSMT */
     device->update_state = &device->state;
 
     if (!(device->cs = wined3d_cs_create(device)))
@@ -5283,3 +5789,58 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -411,7 +411,11 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         int base_vertex_idx, unsigned int start_idx, unsigned int index_count,
         unsigned int start_instance, unsigned int instance_count, BOOL indexed)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_rendertarget_view *dsv, *rtv;
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1612,7 +1612,11 @@ static void shader_glsl_load_constants(void *shader_priv, struct wined3d_context
         const struct wined3d_vec4 correction_params =
         {
             /* Position is relative to the framebuffer, not the viewport. */
+#if !defined(STAGING_CSMT)
             context->render_offscreen ? 0.0f : (float)state->fb->render_targets[0]->height,
+#else  /* STAGING_CSMT */
+            context->render_offscreen ? 0.0f : (float)state->fb.render_targets[0]->height,
+#endif /* STAGING_CSMT */
             context->render_offscreen ? 1.0f : -1.0f,
             0.0f,
             0.0f,
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -37,6 +37,9 @@ static void wined3d_query_init(struct wined3d_query *query, struct wined3d_devic
     query->data = data;
     query->data_size = data_size;
     query->query_ops = query_ops;
+#if defined(STAGING_CSMT)
+    query->pending = 0;
+#endif /* STAGING_CSMT */
 }
 
 static struct wined3d_event_query *wined3d_event_query_from_query(struct wined3d_query *query)
@@ -347,7 +350,13 @@ HRESULT CDECL wined3d_query_get_data(struct wined3d_query *query,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!query->query_ops->query_poll(query, flags))
+#else  /* STAGING_CSMT */
+    while (InterlockedCompareExchange(&query->pending, 0, 0));
+
+    if (!wined3d_cs_emit_query_poll(query->device->cs, query, flags))
+#endif /* STAGING_CSMT */
         return S_FALSE;
 
     if (data)
@@ -500,7 +509,11 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
      * restart. */
     if (flags & WINED3DISSUE_BEGIN)
     {
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -530,13 +543,20 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
         checkGLcall("glBeginQuery()");
 
         context_release(context);
+#if defined(STAGING_CSMT)
+        oq->started = TRUE;
+#endif /* STAGING_CSMT */
     }
     if (flags & WINED3DISSUE_END)
     {
         /* MSDN says END on a non-building occlusion query returns an error,
          * but our tests show that it returns OK. But OpenGL doesn't like it,
          * so avoid generating an error. */
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -552,6 +572,9 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
                 context_release(context);
             }
         }
+#if defined(STAGING_CSMT)
+        oq->started = FALSE;
+#endif /* STAGING_CSMT */
     }
 }
 
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -356,6 +356,10 @@ HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned i
 
     flags = wined3d_resource_sanitise_map_flags(resource, flags);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
 }
 
@@ -371,6 +375,10 @@ HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned
 {
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
 }
 
diff --git a/dlls/wined3d/sampler.c b/dlls/wined3d/sampler.c
--- a/dlls/wined3d/sampler.c
+++ b/dlls/wined3d/sampler.c
@@ -66,22 +66,31 @@ void * CDECL wined3d_sampler_get_parent(const struct wined3d_sampler *sampler)
     return sampler->parent;
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d_device *device,
         const struct wined3d_sampler_desc *desc, void *parent)
+#else  /* STAGING_CSMT */
+void wined3d_sampler_init(struct wined3d_sampler *sampler)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
 
+#if !defined(STAGING_CSMT)
     sampler->refcount = 1;
     sampler->device = device;
     sampler->parent = parent;
     sampler->desc = *desc;
 
     context = context_acquire(device, NULL);
+#else  /* STAGING_CSMT */
+    context = context_acquire(sampler->device, NULL);
+#endif /* STAGING_CSMT */
     gl_info = context->gl_info;
 
     GL_EXTCALL(glGenSamplers(1, &sampler->name));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_S,
+#if !defined(STAGING_CSMT)
             gl_info->wrap_lookup[desc->address_u - WINED3D_TADDRESS_WRAP]));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
             gl_info->wrap_lookup[desc->address_v - WINED3D_TADDRESS_WRAP]));
@@ -103,6 +112,29 @@ static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d
             wined3d_gl_compare_func(desc->comparison_func)));
     if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
             && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !desc->srgb_decode)
+#else  /* STAGING_CSMT */
+            gl_info->wrap_lookup[sampler->desc.address_u - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
+            gl_info->wrap_lookup[sampler->desc.address_v - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_R,
+            gl_info->wrap_lookup[sampler->desc.address_w - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &sampler->desc.border_color[0]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAG_FILTER,
+            wined3d_gl_mag_filter(sampler->desc.mag_filter)));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MIN_FILTER,
+            wined3d_gl_min_mip_filter(sampler->desc.min_filter, sampler->desc.mip_filter)));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, sampler->desc.lod_bias));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, sampler->desc.min_lod));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, sampler->desc.max_lod));
+    if (gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC])
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, sampler->desc.max_anisotropy));
+    if (sampler->desc.compare)
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_FUNC,
+            wined3d_gl_compare_func(sampler->desc.comparison_func)));
+    if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
+            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !sampler->desc.srgb_decode)
+#endif /* STAGING_CSMT */
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_SRGB_DECODE_EXT, GL_SKIP_DECODE_EXT));
     checkGLcall("sampler creation");
 
@@ -134,7 +166,15 @@ HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
+#if !defined(STAGING_CSMT)
     wined3d_sampler_init(object, device, desc, parent);
+#else  /* STAGING_CSMT */
+    object->refcount = 1;
+    object->device = device;
+    object->parent = parent;
+    object->desc = *desc;
+    wined3d_cs_emit_sampler_init(device->cs, object);
+#endif /* STAGING_CSMT */
 
     TRACE("Created sampler %p.\n", object);
     *sampler = object;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -3218,7 +3218,11 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     UINT i;
 
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
+#if !defined(STAGING_CSMT)
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb))
+#else  /* STAGING_CSMT */
+    if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb))
+#endif /* STAGING_CSMT */
     {
         static unsigned int warned = 0;
 
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -152,7 +152,11 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     /* No z test without depth stencil buffers */
+#if !defined(STAGING_CSMT)
     if (!state->fb->depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb.depth_stencil)
+#endif /* STAGING_CSMT */
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -474,11 +478,19 @@ static void state_blend(struct wined3d_context *context, const struct wined3d_st
         checkGLcall("glDisable(GL_LINE_SMOOTH)");
     }
 
+#if !defined(STAGING_CSMT)
     enable_blend = state->fb->render_targets[0] && state->render_states[WINED3D_RS_ALPHABLENDENABLE];
     if (enable_blend)
     {
         rt_format = state->fb->render_targets[0]->format;
         rt_fmt_flags = state->fb->render_targets[0]->format_flags;
+#else  /* STAGING_CSMT */
+    enable_blend = state->fb.render_targets[0] && state->render_states[WINED3D_RS_ALPHABLENDENABLE];
+    if (enable_blend)
+    {
+        rt_format = state->fb.render_targets[0]->format;
+        rt_fmt_flags = state->fb.render_targets[0]->format_flags;
+#endif /* STAGING_CSMT */
 
         /* Disable blending in all cases even without pixelshaders.
          * With blending on we could face a big performance penalty.
@@ -869,7 +881,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_back;
 
     /* No stencil test without a stencil buffer. */
+#if !defined(STAGING_CSMT)
     if (!state->fb->depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb.depth_stencil)
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -965,7 +981,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -979,7 +999,11 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1717,7 +1741,11 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
+#if !defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
+#endif /* STAGING_CSMT */
         float scale;
 
         union
@@ -4632,8 +4660,13 @@ static void vertexdeclaration(struct wined3d_context *context, const struct wine
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_rendertarget_view *depth_stencil = state->fb->depth_stencil;
     const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#else  /* STAGING_CSMT */
+    const struct wined3d_rendertarget_view *depth_stencil = state->fb.depth_stencil;
+    const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
     unsigned int width, height;
@@ -4672,8 +4705,13 @@ static void viewport_miscpart(struct wined3d_context *context, const struct wine
 static void viewport_miscpart_cc(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_rendertarget_view *depth_stencil = state->fb->depth_stencil;
     const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#else  /* STAGING_CSMT */
+    const struct wined3d_rendertarget_view *depth_stencil = state->fb.depth_stencil;
+    const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#endif /* STAGING_CSMT */
     float pixel_center_offset = context->d3d_info->wined3d_creation_flags
             & WINED3D_PIXEL_CENTER_INTEGER ? 0.5f : 0.0f;
     const struct wined3d_gl_info *gl_info = context->gl_info;
@@ -4868,7 +4906,11 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
+#if !defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#endif /* STAGING_CSMT */
         UINT height;
         UINT width;
 
@@ -4944,7 +4986,11 @@ void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
+#if !defined(STAGING_CSMT)
     if (needs_srgb_write(context, state, state->fb))
+#else  /* STAGING_CSMT */
+    if (needs_srgb_write(context, state, &state->fb))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
     else
         gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -431,6 +431,9 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -516,6 +519,33 @@ void state_unbind_resources(struct wined3d_state *state)
             wined3d_unordered_access_view_decref(uav);
         }
     }
+#if defined(STAGING_CSMT)
+
+    if (state->fb.depth_stencil)
+    {
+        view = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", view);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            view = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (view)
+            {
+                TRACE("Releasing the rendertarget view at %p\n", view);
+                wined3d_rendertarget_view_decref(view);
+            }
+        }
+    }
+#endif /* STAGING_CSMT */
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -540,6 +570,10 @@ void state_cleanup(struct wined3d_state *state)
             HeapFree(GetProcessHeap(), 0, light);
         }
     }
+#if defined(STAGING_CSMT)
+
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
+#endif /* STAGING_CSMT */
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -991,8 +1025,13 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
+#if !defined(STAGING_CSMT)
         if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
             device_invalidate_state(device, STATE_POINT_ENABLE);
+#else  /* STAGING_CSMT */
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#endif /* STAGING_CSMT */
     }
 
     if (stateblock->changed.indices)
@@ -1251,35 +1290,77 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+#if !defined(STAGING_CSMT)
     }
 }
 
 void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
         DWORD flags)
+#else  /* STAGING_CSMT */
+        state->textures[i] = NULL;
+    }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
+}
+
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     unsigned int i;
 
     state->flags = flags;
+#if !defined(STAGING_CSMT)
     state->fb = fb;
+#endif /* STAGING_CSMT */
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
         list_init(&state->light_map[i]);
     }
 
+#if !defined(STAGING_CSMT)
+    if (flags & WINED3D_STATE_INIT_DEFAULT)
+        state_init_default(state, gl_info);
+#else  /* STAGING_CSMT */
+    state->fb.rt_size = gl_info->limits.buffers;
+    if (!(state->fb.render_targets = wined3d_calloc(state->fb.rt_size,
+            sizeof(*state->fb.render_targets))))
+        return E_OUTOFMEMORY;
+
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
+#if !defined(STAGING_CSMT)
+    const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     stateblock->ref = 1;
     stateblock->device = device;
+#if !defined(STAGING_CSMT)
     state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0);
+#else  /* STAGING_CSMT */
+
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
+        return hr;
+#endif /* STAGING_CSMT */
 
     if (type == WINED3D_SBT_RECORDED)
         return WINED3D_OK;
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -675,8 +675,12 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
     struct wined3d_view_desc view_desc;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -687,6 +691,7 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.flags = 0;
     view_desc.u.texture.level_idx = surface->texture_level;
@@ -702,6 +707,19 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 
     hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(surface->container, surface->texture_level);
+    view.height = wined3d_texture_get_level_height(surface->container, surface->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
+
+    hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2476,8 +2494,12 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
     struct wined3d_view_desc view_desc;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2488,6 +2510,7 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.flags = 0;
     view_desc.u.texture.level_idx = s->texture_level;
@@ -2503,6 +2526,19 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 
     hr = blitter->color_fill(device, view, rect, color);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(s->container, s->texture_level);
+    view.height = wined3d_texture_get_level_height(s->container, s->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
+
+    hr = blitter->color_fill(device, &view, rect, color);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2513,7 +2549,11 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
 {
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
+#if !defined(STAGING_CSMT)
     const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
+#else  /* STAGING_CSMT */
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
+#endif /* STAGING_CSMT */
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_texture *src_texture;
 
@@ -2871,7 +2911,11 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if !defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
+#endif /* STAGING_CSMT */
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
@@ -3886,7 +3930,11 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_blit_surface,
 };
 
+#if !defined(STAGING_CSMT)
 HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#else  /* STAGING_CSMT */
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#endif /* STAGING_CSMT */
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -3896,9 +3944,14 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#if !defined(STAGING_CSMT)
     struct wined3d_texture *src_texture = NULL;
     unsigned int dst_w, dst_h, src_w, src_h;
     unsigned int src_sub_resource_idx = 0;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *src_texture;
+    unsigned int src_sub_resource_idx;
+#endif /* STAGING_CSMT */
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
 
@@ -3911,6 +3964,7 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
+#if !defined(STAGING_CSMT)
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
@@ -3928,10 +3982,12 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 fx->src_color_key.color_space_high_value);
     }
 
+#endif /* STAGING_CSMT */
     if (src_surface)
     {
         src_texture = src_surface->container;
         src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+#if !defined(STAGING_CSMT)
     }
 
     if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
@@ -3989,6 +4045,15 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         if (!once++)
             FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
         flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+#else  /* STAGING_CSMT */
+        src_swapchain = src_texture->swapchain;
+    }
+    else
+    {
+        src_texture = NULL;
+        src_sub_resource_idx = 0;
+        src_swapchain = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (!device->d3d_initialized)
@@ -4013,11 +4078,13 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         goto fallback;
     }
 
+#if !defined(STAGING_CSMT)
     if (src_texture)
         src_swapchain = src_texture->swapchain;
     else
         src_swapchain = NULL;
 
+#endif /* STAGING_CSMT */
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -4053,13 +4120,21 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->fill_color, &depth))
+#if !defined(STAGING_CSMT)
                 return WINED3DERR_INVALIDCALL;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
+#if !defined(STAGING_CSMT)
             if (src_ds_flags != dst_ds_flags)
             {
                 WARN("Rejecting depth / stencil blit between incompatible formats.\n");
@@ -4069,6 +4144,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
+                    src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
+                return;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -4104,7 +4184,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -4147,7 +4231,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                                     context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
+#if !defined(STAGING_CSMT)
                         return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                        return;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4171,7 +4259,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4192,7 +4284,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4202,7 +4298,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -4210,9 +4310,151 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+#if !defined(STAGING_CSMT)
         return WINED3D_OK;
 
 cpu:
     return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
             src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+#else  /* STAGING_CSMT */
+        return;
+
+cpu:
+    surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+            src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+}
+
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_texture *dst_texture = dst_surface->container;
+    struct wined3d_device *device = dst_texture->resource.device;
+    unsigned int dst_sub_resource_idx = surface_get_sub_resource_idx(dst_surface), src_sub_resource_idx;
+    struct wined3d_texture_sub_resource *dst_sub_resource =
+            &dst_texture->sub_resources[dst_sub_resource_idx];
+    struct wined3d_texture_sub_resource *src_sub_resource = NULL;
+    unsigned int dst_w, dst_h, src_w, src_h;
+    DWORD src_ds_flags, dst_ds_flags;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+        src_sub_resource = &src_surface->container->sub_resources[src_sub_resource_idx];
+    }
+
+    if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_settings.cs_multithreaded)
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(device->cs);
+        wined3d_cs_emit_sync(device->cs);
+
+        if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
+    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
+    if (IsRectEmpty(dst_rect) || dst_rect->left > dst_w || dst_rect->left < 0
+            || dst_rect->top > dst_h || dst_rect->top < 0
+            || dst_rect->right > dst_w || dst_rect->right < 0
+            || dst_rect->bottom > dst_h || dst_rect->bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        src_w = wined3d_texture_get_level_width(src_surface->container, src_surface->texture_level);
+        src_h = wined3d_texture_get_level_height(src_surface->container, src_surface->texture_level);
+        if (IsRectEmpty(src_rect) || src_rect->left > src_w || src_rect->left < 0
+                || src_rect->top > src_h || src_rect->top < 0
+                || src_rect->right > src_w || src_rect->right < 0
+                || src_rect->bottom > src_h || src_rect->bottom < 0)
+        {
+            WARN("The application gave us a bad source rectangle.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+    }
+
+    dst_ds_flags = dst_texture->resource.format_flags
+            & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+    if (src_surface)
+        src_ds_flags = src_surface->container->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+    else
+        src_ds_flags = 0;
+
+    if (!(flags & WINED3D_BLT_DEPTH_FILL) && (src_ds_flags != dst_ds_flags))
+    {
+        WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* FIXME: We should select the blitter in the main thread, that way we can return an error if the blit
+     * is unsupported without duplicating all the checks... */
+    if (flags & WINED3D_BLT_COLOR_FILL && (dst_surface->container->resource.format_flags & WINED3DFMT_FLAG_BLOCKS))
+    {
+        WARN("Block color fill, returning WINED3DERR_INVALIDCALL\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, dst_rect, src_surface, src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -112,6 +112,13 @@ ULONG CDECL wined3d_swapchain_decref(struct wined3d_swapchain *swapchain)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_device *device = swapchain->device;
+
+        if (wined3d_settings.cs_multithreaded)
+            wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -485,10 +492,17 @@ static void wined3d_swapchain_rotate(struct wined3d_swapchain *swapchain, struct
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags)
 {
     struct wined3d_texture *back_buffer = swapchain->back_buffers[0];
     const struct wined3d_fb_state *fb = &swapchain->device->fb;
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+        struct wined3d_rendertarget_view *depth_stencil)
+{
+    struct wined3d_texture *back_buffer = swapchain->back_buffers[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_texture *logo_texture;
     struct wined3d_context *context;
@@ -581,7 +595,11 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if !defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1)
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFinish();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
@@ -619,14 +637,24 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         wined3d_texture_validate_location(swapchain->back_buffers[swapchain->desc.backbuffer_count - 1],
                 0, WINED3D_LOCATION_DISCARDED);
 
+#if !defined(STAGING_CSMT)
     if (fb->depth_stencil)
     {
         struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(fb->depth_stencil);
+#else  /* STAGING_CSMT */
+    if (depth_stencil)
+    {
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(depth_stencil);
+#endif /* STAGING_CSMT */
 
         if (ds && (swapchain->desc.flags & WINED3D_SWAPCHAIN_DISCARD_DEPTHSTENCIL
                 || ds->container->flags & WINED3D_TEXTURE_DISCARD))
             wined3d_texture_validate_location(ds->container,
+#if !defined(STAGING_CSMT)
                     fb->depth_stencil->sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+#else  /* STAGING_CSMT */
+                    depth_stencil->sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+#endif /* STAGING_CSMT */
     }
 
     context_release(context);
@@ -692,7 +720,12 @@ static void swapchain_gdi_frontbuffer_updated(struct wined3d_swapchain *swapchai
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+        struct wined3d_rendertarget_view *depth_stencil)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_surface *front, *back;
     HBITMAP bitmap;
@@ -782,6 +815,71 @@ static void wined3d_swapchain_apply_sample_count_override(const struct wined3d_s
     *quality = 0;
 }
 
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+    UINT i;
+
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i], WINED3DUSAGE_DEPTHSTENCIL);
+        swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+    swapchain_update_swap_interval(swapchain);
+
+    return WINED3D_OK;
+}
+
+#endif /* STAGING_CSMT */
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -904,6 +1002,7 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if !defined(STAGING_CSMT)
         static const enum wined3d_format_id formats[] =
         {
             WINED3DFMT_D24_UNORM_S8_UINT,
@@ -959,6 +1058,11 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
         }
         context_release(swapchain->context[0]);
         swapchain_update_swap_interval(swapchain);
+#else  /* STAGING_CSMT */
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
+            goto err;
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1286,6 +1390,9 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1297,6 +1404,11 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -240,7 +240,11 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if !defined(STAGING_CSMT)
         data->buffer_object = sub_resource->buffer_object;
+#else  /* STAGING_CSMT */
+        data->buffer_object = sub_resource->buffer->name;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -341,6 +345,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
 {
     GLuint *buffer_object;
@@ -353,6 +358,19 @@ static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
             *buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
+    GLuint name = buffer->name;
+
+    wined3d_device_release_bo(texture->resource.device, buffer, context);
+    texture->sub_resources[sub_resource_idx].buffer = NULL;
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -372,7 +390,11 @@ static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+#if !defined(STAGING_CSMT)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -529,28 +551,46 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     GLuint buffer_object;
+#else  /* STAGING_CSMT */
+    struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     unsigned int i;
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (!(buffer_object = texture->sub_resources[i].buffer_object))
             continue;
 
         TRACE("Deleting buffer object %u.\n", buffer_object);
+#else  /* STAGING_CSMT */
+        if (!(buffer = texture->sub_resources[i].buffer))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer->name);
+#endif /* STAGING_CSMT */
 
         /* We may not be able to get a context in wined3d_texture_cleanup() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
+#if !defined(STAGING_CSMT)
         {
             context = context_acquire(device, NULL);
             gl_info = context->gl_info;
         }
 
         GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+#else  /* STAGING_CSMT */
+            context = context_acquire(device, NULL);
+
+        wined3d_device_release_bo(device, buffer, context);
+        texture->sub_resources[i].buffer = NULL;
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -1217,18 +1257,31 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if !defined(STAGING_CSMT)
         wined3d_surface_create_dc(surface);
+#else  /* STAGING_CSMT */
+    {
+        HDC dc;
+        wined3d_texture_get_dc(texture, 0, &dc);
+        wined3d_texture_release_dc(texture, 0, dc);
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if !defined(STAGING_CSMT)
     if (sub_resource->buffer_object)
         return;
 
@@ -1240,6 +1293,16 @@ static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *textur
 
     TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
             sub_resource->buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+    if (sub_resource->buffer)
+        return;
+
+    sub_resource->buffer = wined3d_device_get_bo(texture->resource.device,
+            sub_resource->size, GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer->name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1365,7 +1428,11 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if !defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1401,7 +1468,11 @@ void CDECL wined3d_texture_generate_mipmaps(struct wined3d_texture *texture)
     FIXME("texture %p stub!\n", texture);
 }
 
+#if !defined(STAGING_CSMT)
 static struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
+#else  /* STAGING_CSMT */
+struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
+#endif /* STAGING_CSMT */
         unsigned int sub_resource_idx)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
@@ -1420,7 +1491,9 @@ static struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(str
 HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
         UINT layer, const struct wined3d_box *dirty_region)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     unsigned int sub_resource_idx;
 
     TRACE("texture %p, layer %u, dirty_region %s.\n", texture, layer, debug_box(dirty_region));
@@ -1432,6 +1505,7 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
     }
     sub_resource_idx = layer * texture->level_count;
 
+#if !defined(STAGING_CSMT)
     if (dirty_region)
         WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
 
@@ -1445,6 +1519,9 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
     wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
     context_release(context);
 
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_texture_add_dirty_region(texture->resource.device->cs, texture, sub_resource_idx, dirty_region);
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1678,7 +1755,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context, location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
                 texture1d_upload_data(texture, sub_resource_idx, context, NULL, &data, row_pitch, slice_pitch);
@@ -1723,7 +1804,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -2017,8 +2102,13 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if !defined(STAGING_CSMT)
         if (sub_resource->buffer_object)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer)
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -2631,11 +2721,23 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
+#if !defined(STAGING_CSMT)
             if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
                     && FAILED(hr = wined3d_surface_create_dc(surface)))
             {
                 wined3d_texture_cleanup_sync(texture);
                 return hr;
+#else  /* STAGING_CSMT */
+            if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
+            {
+                HDC dc;
+                if (FAILED(hr = wined3d_texture_get_dc(texture, idx, &dc)))
+                {
+                    wined3d_texture_cleanup_sync(texture);
+                    return hr;
+                }
+                wined3d_texture_release_dc(texture, idx, dc);
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -2838,7 +2940,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
@@ -2884,7 +2990,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -3421,13 +3531,49 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+    HRESULT hr = WINED3D_OK;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        hr = wined3d_surface_create_dc(surface);
+    if (context)
+        context_release(context);
+    if (FAILED(hr))
+        return hr;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+
+    return hr;
+}
+
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
 {
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context = NULL;
     struct wined3d_surface *surface;
     HRESULT hr = WINED3D_OK;
+#else  /* STAGING_CSMT */
+    struct wined3d_surface *surface;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -3452,6 +3598,7 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     if (device->d3d_initialized)
         context = context_acquire(device, NULL);
 
@@ -3469,11 +3616,40 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
         texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
     ++texture->resource.map_count;
     ++sub_resource->map_count;
+#else  /* STAGING_CSMT */
+    wined3d_resource_wait_idle(&texture->resource);
+
+    hr = wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
+    if (FAILED(hr))
+        return hr;
+#endif /* STAGING_CSMT */
 
     *dc = surface->dc;
     TRACE("Returning dc %p.\n", *dc);
 
+#if !defined(STAGING_CSMT)
     return hr;
+#else  /* STAGING_CSMT */
+    return WINED3D_OK;
+}
+
+HRESULT wined3d_texture_release_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
+
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -3504,6 +3680,7 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
         wined3d_surface_destroy_dc(surface);
 
@@ -3514,4 +3691,9 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    wined3d_resource_wait_idle(&texture->resource);
+
+    return wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -4645,7 +4645,11 @@ void get_projection_matrix(const struct wined3d_context *context, const struct w
         float y_offset = flip
                 ? (center_offset - (2.0f * y) - h) / h
                 : (center_offset - (2.0f * y) - h) / -h;
+#if !defined(STAGING_CSMT)
         enum wined3d_depth_buffer_type zenable = state->fb->depth_stencil ?
+#else  /* STAGING_CSMT */
+        enum wined3d_depth_buffer_type zenable = state->fb.depth_stencil ?
+#endif /* STAGING_CSMT */
                 state->render_states[WINED3D_RS_ZENABLE] : WINED3D_ZB_FALSE;
         float z_scale = zenable ? clip_control ? 1.0f : 2.0f : 0.0f;
         float z_offset = zenable ? clip_control ? 0.0f : -1.0f : 0.0f;
@@ -5444,7 +5448,11 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
                 break;
         }
     }
+#if !defined(STAGING_CSMT)
     settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb);
+#else  /* STAGING_CSMT */
+    settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb);
+#endif /* STAGING_CSMT */
     if (d3d_info->vs_clipping || !use_vs(state) || !state->render_states[WINED3D_RS_CLIPPING]
             || !state->render_states[WINED3D_RS_CLIPPLANEENABLE])
     {
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -64,7 +64,11 @@ static GLenum get_texture_view_target(const struct wined3d_view_desc *desc,
     return texture->target;
 }
 
+#if !defined(STAGING_CSMT)
 static void create_texture_view(struct wined3d_gl_view *view, GLenum view_target,
+#else  /* STAGING_CSMT */
+void create_texture_view(struct wined3d_gl_view *view, GLenum view_target,
+#endif /* STAGING_CSMT */
         const struct wined3d_view_desc *desc, struct wined3d_texture *texture,
         const struct wined3d_format *view_format)
 {
@@ -125,7 +129,11 @@ static void create_texture_view(struct wined3d_gl_view *view, GLenum view_target
     context_release(context);
 }
 
+#if !defined(STAGING_CSMT)
 static void create_buffer_texture(struct wined3d_gl_view *view,
+#else  /* STAGING_CSMT */
+void create_buffer_texture(struct wined3d_gl_view *view,
+#endif /* STAGING_CSMT */
         struct wined3d_buffer *buffer, const struct wined3d_format *view_format)
 {
     const struct wined3d_gl_info *gl_info;
@@ -467,7 +475,11 @@ static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_
                 FIXME("Ignoring buffer range %u-%u.\n", desc->u.buffer.start_idx, desc->u.buffer.count);
             }
 
+#if !defined(STAGING_CSMT)
             create_buffer_texture(&view->gl_view, buffer, view_format);
+#else  /* STAGING_CSMT */
+            wined3d_cs_emit_create_buffer_texture(resource->device->cs, &view->gl_view, buffer, view_format);
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -498,7 +510,12 @@ static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_
         else if (resource->format->typeless_id == view_format->typeless_id
                 && resource->format->gl_view_class == view_format->gl_view_class)
         {
+#if !defined(STAGING_CSMT)
             create_texture_view(&view->gl_view, view_target, desc, texture, view_format);
+#else  /* STAGING_CSMT */
+            wined3d_cs_emit_create_texture_view(resource->device->cs, &view->gl_view, view_target,
+                    desc, texture, view_format);
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -663,8 +680,13 @@ static HRESULT wined3d_unordered_access_view_init(struct wined3d_unordered_acces
 
         if (desc->u.texture.layer_idx || desc->u.texture.layer_count != depth_or_layer_count)
         {
+#if !defined(STAGING_CSMT)
             create_texture_view(&view->gl_view, get_texture_view_target(desc, texture),
                     desc, texture, view->format);
+#else  /* STAGING_CSMT */
+            wined3d_cs_emit_create_texture_view(resource->device->cs, &view->gl_view,
+                    get_texture_view_target(desc, texture), desc, texture, view->format);
+#endif /* STAGING_CSMT */
         }
 
         view->layer_idx = desc->u.texture.layer_idx;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -90,6 +90,9 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No PS shader model limit by default. */
     ~0u,            /* No CS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
+    TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -327,7 +330,22 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if !defined(STAGING_CSMT)
     }
+#else  /* STAGING_CSMT */
+        /*
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
+        */
+    }
+
+    FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
+        wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -306,6 +306,9 @@ struct wined3d_settings
     unsigned int max_sm_ps;
     unsigned int max_sm_cs;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
+    BOOL cs_multithreaded;
+#endif /* STAGING_CSMT */
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1459,6 +1462,9 @@ struct wined3d_query
     const void *data;
     DWORD data_size;
     const struct wined3d_query_ops *query_ops;
+#if defined(STAGING_CSMT)
+    LONG pending;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1500,6 +1506,9 @@ struct wined3d_occlusion_query
     GLuint id;
     struct wined3d_context *context;
     UINT64 samples;
+#if defined(STAGING_CSMT)
+    BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_timestamp_query
@@ -1515,6 +1524,38 @@ struct wined3d_timestamp_query
 void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 
+#if defined(STAGING_CSMT)
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
+#endif /* STAGING_CSMT */
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1529,6 +1570,9 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state current_fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_device *device;
     struct wined3d_swapchain *swapchain;
@@ -1641,12 +1685,14 @@ struct wined3d_context
     GLuint                  dummy_arbfp_prog;
 };
 
+#if !defined(STAGING_CSMT)
 struct wined3d_fb_state
 {
     struct wined3d_rendertarget_view **render_targets;
     struct wined3d_rendertarget_view *depth_stencil;
 };
 
+#endif /* STAGING_CSMT */
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
 
 struct StateEntry
@@ -1785,7 +1831,11 @@ void context_alloc_event_query(struct wined3d_context *context,
 void context_alloc_occlusion_query(struct wined3d_context *context,
         struct wined3d_occlusion_query *query) DECLSPEC_HIDDEN;
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
 void context_apply_compute_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -2468,7 +2518,11 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb;
+#else  /* STAGING_CSMT */
+    struct wined3d_fb_state fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -2516,6 +2570,16 @@ struct wined3d_state
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2574,7 +2638,9 @@ struct wined3d_device
     struct wine_rb_tree samplers;
 
     /* Render Target Support */
+#if !defined(STAGING_CSMT)
     struct wined3d_fb_state fb;
+#endif /* STAGING_CSMT */
     struct wined3d_rendertarget_view *auto_depth_stencil_view;
 
     /* For rendering to a texture using glCopyTexImage */
@@ -2630,6 +2696,17 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2705,11 +2782,13 @@ static inline void wined3d_resource_release(struct wined3d_resource *resource)
     InterlockedDecrement(&resource->access_count);
 }
 
+#if !defined(STAGING_CSMT)
 static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
 {
     while (InterlockedCompareExchange(&resource->access_count, 0, 0));
 }
 
+#endif /* STAGING_CSMT */
 void resource_cleanup(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *device,
         enum wined3d_resource_type type, const struct wined3d_format *format,
@@ -2820,7 +2899,11 @@ struct wined3d_texture
 
         unsigned int map_count;
         DWORD locations;
+#if !defined(STAGING_CSMT)
         GLuint buffer_object;
+#else  /* STAGING_CSMT */
+        struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -2873,9 +2956,16 @@ void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
         unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_invalidate_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_texture_load(struct wined3d_texture *texture,
@@ -2888,6 +2978,10 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_release_dc_cs(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
@@ -2995,6 +3089,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -3009,6 +3108,10 @@ struct wined3d_sampler
     GLuint name;
 };
 
+#if defined(STAGING_CSMT)
+void wined3d_sampler_init(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
+
+#endif /* STAGING_CSMT */
 struct wined3d_vertex_declaration_element
 {
     const struct wined3d_format *format;
@@ -3104,9 +3207,14 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
         DWORD flags) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
 
 enum wined3d_push_constants
@@ -3119,6 +3227,7 @@ enum wined3d_push_constants
     WINED3D_PUSH_CONSTANTS_PS_B,
 };
 
+#if !defined(STAGING_CSMT)
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
@@ -3126,34 +3235,128 @@ struct wined3d_cs_ops
     void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
             unsigned int start_idx, unsigned int count, const void *constants);
 };
+#else  /* STAGING_CSMT */
+struct wined3d_cs_list
+{
+    struct list blocks;
+    LONG count;
+};
+
+struct wined3d_cs_block
+{
+    struct list entry;
+    UINT pos;
+    struct wined3d_cs_list *list;
+    BOOL *fence;
+    BYTE data[0x4000]; /* FIXME? The size is somewhat arbitrary. */
+};
+
+struct wined3d_cs_ops
+{
+    void *(*require_space)(struct wined3d_cs *cs, size_t size, int priority);
+    void (*submit)(struct wined3d_cs *cs);
+    void (*submit_and_wait)(struct wined3d_cs *cs);
+};
+
+#define WINED3D_CS_SPIN_COUNT 10000000
+#endif /* STAGING_CSMT */
 
 struct wined3d_cs
 {
     const struct wined3d_cs_ops *ops;
     struct wined3d_device *device;
+#if !defined(STAGING_CSMT)
     struct wined3d_fb_state fb;
     struct wined3d_state state;
 
     size_t data_size;
     void *data;
 };
+#else  /* STAGING_CSMT */
+    struct wined3d_state state;
+    HANDLE thread;
+    struct wined3d_cs_block *block_main;
+    struct wined3d_cs_block *block_worker;
+    DWORD thread_id;
+    size_t data_size;
+    void *data;
+
+    struct wined3d_cs_list free_list;
+    struct wined3d_cs_list exec_list;
+    struct wined3d_cs_list exec_prio_list;
+
+    LONG pending_presents;
+
+    HANDLE event;
+    BOOL waiting_for_event;
+};
+
+static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
+{
+    if (resource->device->cs->thread_id == GetCurrentThreadId()) return;
+    while (InterlockedCompareExchange(&resource->access_count, 0, 0));
+}
+
+struct wined3d_gl_view;
+#endif /* STAGING_CSMT */
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 
+#if !defined(STAGING_CSMT)
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_copy(struct wined3d_cs *cs, struct wined3d_buffer *dst_buffer,
+        unsigned int dst_offset, struct wined3d_buffer *src_buffer, unsigned int src_offset,
+        unsigned int size) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_buffer_texture(struct wined3d_cs *cs, struct wined3d_gl_view *view,
+        struct wined3d_buffer *buffer, const struct wined3d_format *view_format) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_texture_view(struct wined3d_cs *cs, struct wined3d_gl_view *view,
+        GLenum view_target, const struct wined3d_view_desc *desc, struct wined3d_texture *texture,
+        const struct wined3d_format *view_format) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
         unsigned int group_count_x, unsigned int group_count_y, unsigned int group_count_z) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned int start_idx, unsigned int index_count,
         unsigned int start_instance, unsigned int instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override, DWORD flags) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+BOOL wined3d_cs_emit_query_poll(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx,
         const struct wined3d_vec4 *plane) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -3164,9 +3367,17 @@ void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs,
         struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
         enum wined3d_format_id format_id, unsigned int offset) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs,
         struct wined3d_query *predicate, BOOL value) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
         struct wined3d_rasterizer_state *rasterizer_state) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs,
@@ -3198,17 +3409,35 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, unsigned i
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
+void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_sync(struct wined3d_cs *cs);
+void wined3d_cs_emit_texture_add_dirty_region(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, const struct wined3d_box *dirty_region) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int depth_pitch) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, unsigned int flags) DECLSPEC_HIDDEN;
 HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 
 static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
     cs->ops->push_constants(cs, p, start_idx, count, constants);
 }
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_map_vertex_buffers(struct wined3d_cs *cs, UINT src_start_idx,
+        struct wined3d_stream_info *stream_info) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
@@ -3309,6 +3538,14 @@ struct wined3d_gl_view
     GLuint name;
 };
 
+#if defined(STAGING_CSMT)
+void create_buffer_texture(struct wined3d_gl_view *view,
+        struct wined3d_buffer *buffer, const struct wined3d_format *view_format) DECLSPEC_HIDDEN;
+void create_texture_view(struct wined3d_gl_view *view, GLenum view_target,
+        const struct wined3d_view_desc *desc, struct wined3d_texture *texture,
+        const struct wined3d_format *view_format) DECLSPEC_HIDDEN;
+
+#endif /* STAGING_CSMT */
 struct wined3d_shader_resource_view
 {
     LONG refcount;
@@ -3344,7 +3581,12 @@ void wined3d_unordered_access_view_invalidate_location(struct wined3d_unordered_
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
             const RECT *src_rect, const RECT *dst_rect, DWORD flags);
+#else  /* STAGING_CSMT */
+            const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+            struct wined3d_rendertarget_view *depth_stencil);
+#endif /* STAGING_CSMT */
     void (*swapchain_frontbuffer_updated)(struct wined3d_swapchain *swapchain);
 };
 
@@ -3381,6 +3623,10 @@ struct wined3d_swapchain
 
 void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
