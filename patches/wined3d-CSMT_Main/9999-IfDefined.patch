From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

Based on patches by:
    Michael Müller <michael@fds-team.de>
    Nils Kuhnhenn <nils@volafile.io>
    Sebastian Lackner <sebastian@fds-team.de>
    Stefan Dösinger <stefan@codeweavers.com>
    Stefan Dösinger <stefandoesinger@gmx.at>

diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1337,7 +1337,11 @@ static void color_fill_test(void)
          * result on Wine.
          * {D3DFMT_YUY2,     "D3DFMT_YUY2",     BLOCKS,                              0},
          * {D3DFMT_UYVY,     "D3DFMT_UYVY",     BLOCKS,                              0}, */
+#if !defined(STAGING_CSMT)
         {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS | TODO_FILL_RETURN,           0},
+#else  /* STAGING_CSMT */
+        {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS,                              0},
+#endif /* STAGING_CSMT */
         /* Vendor-specific formats like ATI2N are a non-issue here since they're not
          * supported as offscreen plain surfaces and do not support D3DUSAGE_RENDERTARGET
          * when created as texture. */
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -1265,6 +1265,9 @@ HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
         const struct wined3d_box *box, const void *data)
 {
     UINT offset, size;
+#if defined(STAGING_CSMT)
+    DWORD flags = 0;
+#endif /* STAGING_CSMT */
     HRESULT hr;
     BYTE *ptr;
 
@@ -1279,7 +1282,14 @@ HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
         size = buffer->resource.size;
     }
 
+#if !defined(STAGING_CSMT)
     if (FAILED(hr = wined3d_buffer_map(buffer, offset, size, &ptr, 0)))
+#else  /* STAGING_CSMT */
+    if (offset == 0 && size == buffer->resource.size)
+        flags = WINED3D_MAP_DISCARD;
+
+    if (FAILED(hr = wined3d_buffer_map(buffer, offset, size, &ptr, flags)))
+#endif /* STAGING_CSMT */
         return hr;
 
     memcpy(ptr, data, size);
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -3721,6 +3721,11 @@ struct wined3d_context *context_acquire(const struct wined3d_device *device,
 
     TRACE("device %p, texture %p, sub_resource_idx %u.\n", device, texture, sub_resource_idx);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded && device->cs->thread_id != GetCurrentThreadId())
+        FIXME("Acquiring a GL context from outside the CS thread.\n");
+
+#endif /* STAGING_CSMT */
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -18,6 +18,9 @@
 
 #include "config.h"
 #include "wine/port.h"
+#if defined(STAGING_CSMT)
+#include <assert.h>
+#endif /* STAGING_CSMT */
 #include "wined3d_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
@@ -26,6 +29,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
 enum wined3d_cs_op
 {
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_SYNC,
+    WINED3D_CS_OP_GLFINISH,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DISPATCH,
@@ -59,11 +66,36 @@ enum wined3d_cs_op
     WINED3D_CS_OP_RESET_STATE,
     WINED3D_CS_OP_CALLBACK,
     WINED3D_CS_OP_QUERY_ISSUE,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_QUERY_POLL,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRELOAD_RESOURCE,
     WINED3D_CS_OP_UNLOAD_RESOURCE,
     WINED3D_CS_OP_MAP,
     WINED3D_CS_OP_UNMAP,
     WINED3D_CS_OP_UPDATE_SUB_RESOURCE,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_PUSH_CONSTANTS,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_GET_DC,
+    WINED3D_CS_OP_RELEASE_DC,
+    WINED3D_CS_OP_UPDATE_SWAP_INTERVAL,
+    WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION,
+    WINED3D_CS_OP_BUFFER_COPY,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_sync
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_glfinish
+{
+    enum wined3d_cs_op opcode;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -314,6 +346,16 @@ struct wined3d_cs_query_issue
     DWORD flags;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_cs_query_poll
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+    BOOL *ret;
+};
+
+#endif /* STAGING_CSMT */
 struct wined3d_cs_preload_resource
 {
     enum wined3d_cs_op opcode;
@@ -348,13 +390,133 @@ struct wined3d_cs_unmap
 struct wined3d_cs_update_sub_resource
 {
     enum wined3d_cs_op opcode;
+#if defined(STAGING_CSMT)
+    unsigned int size;
+#endif /* STAGING_CSMT */
     struct wined3d_resource *resource;
     unsigned int sub_resource_idx;
     struct wined3d_box box;
     struct wined3d_sub_resource_data data;
+#if !defined(STAGING_CSMT)
 };
 
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    BYTE copy_data[1];
+};
+
+struct wined3d_cs_push_constants
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_push_constants p;
+    unsigned int start_idx;
+    unsigned int count;
+    BYTE constants[1];
+};
+
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    struct wined3d_blt_fx fx;
+    enum wined3d_texture_filter_type filter;
+};
+
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    DWORD flags;
+    struct wined3d_color color;
+    float depth;
+    DWORD stencil;
+    const struct blit_shader *blitter;
+};
+
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
+struct wined3d_cs_get_release_dc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+    HRESULT *hr;
+};
+
+struct wined3d_cs_update_swap_interval
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_texture_add_dirty_region
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+};
+
+struct wined3d_cs_buffer_copy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *dst_buffer;
+    unsigned int dst_offset;
+    struct wined3d_buffer *src_buffer;
+    unsigned int src_offset;
+    unsigned int size;
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+static UINT wined3d_cs_exec_sync(struct wined3d_cs *cs, const void *data)
+{
+    return sizeof(struct wined3d_cs_sync);
+}
+
+void wined3d_cs_emit_sync(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_sync *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_SYNC;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_context *context = context_get_current();
+
+    if (context)
+        context->gl_info->gl_ops.gl.p_glFinish();
+
+    return sizeof(struct wined3d_cs_glfinish);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_glfinish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_present *op = data;
     struct wined3d_swapchain *swapchain;
@@ -365,11 +527,19 @@ static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 
     swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
 
+#if defined(STAGING_CSMT)
+    InterlockedDecrement(&cs->pending_presents);
+
+#endif /* STAGING_CSMT */
     wined3d_resource_release(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
     {
         wined3d_resource_release(&swapchain->back_buffers[i]->resource);
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
@@ -377,8 +547,14 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
 {
     struct wined3d_cs_present *op;
     unsigned int i;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    LONG pending;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRESENT;
     op->dst_window_override = dst_window_override;
     op->swapchain = swapchain;
@@ -392,16 +568,39 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
         wined3d_resource_acquire(&swapchain->back_buffers[i]->resource);
     }
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs);
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_state *state = &cs->state;
     const struct wined3d_cs_clear *op = data;
     struct wined3d_device *device;
     unsigned int i;
     RECT draw_rect;
+#if defined(STAGING_CSMT)
+    size_t size = FIELD_OFFSET(struct wined3d_cs_clear, rects[op->rect_count]);
+#endif /* STAGING_CSMT */
 
     device = cs->device;
     wined3d_get_draw_rect(state, &draw_rect);
@@ -419,6 +618,10 @@ static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
     }
     if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
         wined3d_resource_release(state->fb->depth_stencil->resource);
+#if defined(STAGING_CSMT)
+
+    return size;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
@@ -428,7 +631,11 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     struct wined3d_cs_clear *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CLEAR;
     op->flags = flags;
     op->color = *color;
@@ -557,7 +764,11 @@ static void release_unordered_access_resources(const struct wined3d_shader *shad
     }
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_dispatch(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_dispatch(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_dispatch *op = data;
     struct wined3d_state *state = &cs->state;
@@ -568,6 +779,10 @@ static void wined3d_cs_exec_dispatch(struct wined3d_cs *cs, const void *data)
     release_shader_resources(state, 1u << WINED3D_SHADER_TYPE_COMPUTE);
     release_unordered_access_resources(state->shader[WINED3D_SHADER_TYPE_COMPUTE],
             state->unordered_access_view[WINED3D_PIPELINE_COMPUTE]);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
@@ -576,7 +791,11 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
     const struct wined3d_state *state = &cs->device->state;
     struct wined3d_cs_dispatch *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DISPATCH;
     op->group_count_x = group_count_x;
     op->group_count_y = group_count_y;
@@ -589,7 +808,11 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_state *state = &cs->state;
     const struct wined3d_cs_draw *op = data;
@@ -634,6 +857,10 @@ static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
     release_shader_resources(state, ~(1u << WINED3D_SHADER_TYPE_COMPUTE));
     release_unordered_access_resources(state->shader[WINED3D_SHADER_TYPE_PIXEL],
             state->unordered_access_view[WINED3D_PIPELINE_GRAPHICS]);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base_vertex_idx, unsigned int start_idx,
@@ -643,7 +870,11 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base
     struct wined3d_cs_draw *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DRAW;
     op->primitive_type = primitive_type;
     op->base_vertex_idx = base_vertex_idx;
@@ -679,70 +910,123 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_predication *op = data;
 
     cs->state.predicate = op->predicate;
     cs->state.predicate_value = op->value;
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
 {
     struct wined3d_cs_set_predication *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_PREDICATION;
     op->predicate = predicate;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_viewport *op = data;
 
     cs->state.viewport = op->viewport;
     device_invalidate_state(cs->device, STATE_VIEWPORT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
 {
     struct wined3d_cs_set_viewport *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
     op->viewport = *viewport;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_scissor_rect *op = data;
 
     cs->state.scissor_rect = op->rect;
     device_invalidate_state(cs->device, STATE_SCISSORRECT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
 {
     struct wined3d_cs_set_scissor_rect *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
     op->rect = *rect;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_rendertarget_view *op = data;
 
     cs->state.fb->render_targets[op->view_idx] = op->view;
     device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
@@ -750,15 +1034,26 @@ void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int v
 {
     struct wined3d_cs_set_rendertarget_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
     op->view_idx = view_idx;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_depth_stencil_view *op = data;
     struct wined3d_device *device = cs->device;
@@ -793,39 +1088,69 @@ static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     }
 
     device_invalidate_state(device, STATE_FRAMEBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
 {
     struct wined3d_cs_set_depth_stencil_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_vertex_declaration *op = data;
 
     cs->state.vertex_declaration = op->declaration;
     device_invalidate_state(cs->device, STATE_VDECL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
 {
     struct wined3d_cs_set_vertex_declaration *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
     op->declaration = declaration;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source *op = data;
     struct wined3d_stream_state *stream;
@@ -843,6 +1168,10 @@ static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
@@ -850,17 +1179,28 @@ void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_source *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
     op->offset = offset;
     op->stride = stride;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source_freq *op = data;
     struct wined3d_stream_state *stream;
@@ -870,22 +1210,37 @@ static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const
     stream->flags = op->flags;
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
 {
     struct wined3d_cs_set_stream_source_freq *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
     op->stream_idx = stream_idx;
     op->frequency = frequency;
     op->flags = flags;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_output *op = data;
     struct wined3d_stream_output *stream;
@@ -900,6 +1255,10 @@ static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void
         InterlockedIncrement(&op->buffer->resource.bind_count);
     if (prev)
         InterlockedDecrement(&prev->resource.bind_count);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
@@ -907,16 +1266,27 @@ void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_output *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
     op->offset = offset;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_index_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -932,6 +1302,10 @@ static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
@@ -939,16 +1313,27 @@ void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buff
 {
     struct wined3d_cs_set_index_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
     op->buffer = buffer;
     op->format_id = format_id;
     op->offset = offset;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_constant_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -962,6 +1347,9 @@ static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const voi
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+#if defined(STAGING_CSMT)
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -969,16 +1357,27 @@ void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_sha
 {
     struct wined3d_cs_set_constant_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
     op->type = type;
     op->cb_idx = cb_idx;
     op->buffer = buffer;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
@@ -1055,21 +1454,36 @@ static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
 
     if (new_use_color_key)
         device_invalidate_state(cs->device, STATE_COLOR_KEY);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
 {
     struct wined3d_cs_set_texture *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE;
     op->stage = stage;
     op->texture = texture;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader_resource_view *op = data;
     struct wined3d_shader_resource_view *prev;
@@ -1086,6 +1500,10 @@ static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, cons
         device_invalidate_state(cs->device, STATE_GRAPHICS_SHADER_RESOURCE_BINDING);
     else
         device_invalidate_state(cs->device, STATE_COMPUTE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1093,16 +1511,27 @@ void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3
 {
     struct wined3d_cs_set_shader_resource_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
     op->type = type;
     op->view_idx = view_idx;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_unordered_access_view *op = data;
     struct wined3d_unordered_access_view *prev;
@@ -1116,6 +1545,10 @@ static void wined3d_cs_exec_set_unordered_access_view(struct wined3d_cs *cs, con
         InterlockedDecrement(&prev->resource->bind_count);
 
     device_invalidate_state(cs->device, STATE_UNORDERED_ACCESS_VIEW_BINDING(op->pipeline));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, enum wined3d_pipeline pipeline,
@@ -1123,16 +1556,27 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, enum wined
 {
     struct wined3d_cs_set_unordered_access_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_UNORDERED_ACCESS_VIEW;
     op->pipeline = pipeline;
     op->view_idx = view_idx;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler *op = data;
 
@@ -1141,6 +1585,10 @@ static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
         device_invalidate_state(cs->device, STATE_GRAPHICS_SHADER_RESOURCE_BINDING);
     else
         device_invalidate_state(cs->device, STATE_COMPUTE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -1148,16 +1596,27 @@ void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type
 {
     struct wined3d_cs_set_sampler *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER;
     op->type = type;
     op->sampler_idx = sampler_idx;
     op->sampler = sampler;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader *op = data;
 
@@ -1167,26 +1626,45 @@ static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
         device_invalidate_state(cs->device, STATE_GRAPHICS_SHADER_RESOURCE_BINDING);
     else
         device_invalidate_state(cs->device, STATE_COMPUTE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
 {
     struct wined3d_cs_set_shader *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER;
     op->type = type;
     op->shader = shader;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_rasterizer_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_rasterizer_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_rasterizer_state *op = data;
 
     cs->state.rasterizer_state = op->state;
     device_invalidate_state(cs->device, STATE_FRONTFACE);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
@@ -1194,39 +1672,69 @@ void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
 {
     struct wined3d_cs_set_rasterizer_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RASTERIZER_STATE;
     op->state = rasterizer_state;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_render_state *op = data;
 
     cs->state.render_states[op->state] = op->value;
     device_invalidate_state(cs->device, STATE_RENDER(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
 {
     struct wined3d_cs_set_render_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_texture_state *op = data;
 
     cs->state.texture_states[op->stage][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
@@ -1234,21 +1742,36 @@ void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
 {
     struct wined3d_cs_set_texture_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
     op->stage = stage;
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler_state *op = data;
 
     cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
@@ -1256,22 +1779,37 @@ void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
 {
     struct wined3d_cs_set_sampler_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
     op->sampler_idx = sampler_idx;
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_transform *op = data;
 
     cs->state.transforms[op->state] = op->matrix;
     if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->d3d_info.limits.ffp_vertex_blend_matrices))
         device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
@@ -1279,35 +1817,61 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 {
     struct wined3d_cs_set_transform *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
     op->state = state;
     op->matrix = *matrix;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_clip_plane *op = data;
 
     cs->state.clip_planes[op->plane_idx] = op->plane;
     device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
 {
     struct wined3d_cs_set_clip_plane *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
     op->plane_idx = plane_idx;
     op->plane = *plane;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_color_key *op = data;
     struct wined3d_texture *texture = op->texture;
@@ -1368,6 +1932,10 @@ static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *dat
                 break;
         }
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -1375,7 +1943,11 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
 {
     struct wined3d_cs_set_color_key *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_COLOR_KEY;
     op->texture = texture;
     op->flags = flags;
@@ -1387,29 +1959,51 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
     else
         op->set = 0;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_material *op = data;
 
     cs->state.material = op->material;
     device_invalidate_state(cs->device, STATE_MATERIAL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
 {
     struct wined3d_cs_set_material *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_MATERIAL;
     op->material = *material;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_light *op = data;
     struct wined3d_light_info *light_info;
@@ -1423,7 +2017,11 @@ static void wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
         if (!(light_info = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*light_info))))
         {
             ERR("Failed to allocate light info.\n");
+#if !defined(STAGING_CSMT)
             return;
+#else  /* STAGING_CSMT */
+            return sizeof(*op);;
+#endif /* STAGING_CSMT */
         }
 
         hash_idx = LIGHTMAP_HASHFUNC(light_idx);
@@ -1444,20 +2042,35 @@ static void wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
     light_info->direction = op->light.direction;
     light_info->exponent = op->light.exponent;
     light_info->cutoff = op->light.cutoff;
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
 {
     struct wined3d_cs_set_light *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_LIGHT;
     op->light = *light;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_light_enable *op = data;
     struct wined3d_device *device = cs->device;
@@ -1467,7 +2080,11 @@ static void wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *
     if (!(light_info = wined3d_state_get_light(&cs->state, op->idx)))
     {
         ERR("Light doesn't exist.\n");
+#if !defined(STAGING_CSMT)
         return;
+#else  /* STAGING_CSMT */
+        return sizeof(*op);
+#endif /* STAGING_CSMT */
     }
 
     prev_idx = light_info->glIndex;
@@ -1477,21 +2094,36 @@ static void wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *
         device_invalidate_state(device, STATE_LIGHT_TYPE);
         device_invalidate_state(device, STATE_ACTIVELIGHT(op->enable ? light_info->glIndex : prev_idx));
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, unsigned int idx, BOOL enable)
 {
     struct wined3d_cs_set_light_enable *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
     op->idx = idx;
     op->enable = enable;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_adapter *adapter = cs->device->adapter;
 
@@ -1499,12 +2131,17 @@ static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
     memset(&cs->state, 0, sizeof(cs->state));
     state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(struct wined3d_cs_reset_state);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 {
     struct wined3d_cs_reset_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_RESET_STATE;
 
@@ -1512,17 +2149,34 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 }
 
 static void wined3d_cs_exec_callback(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_callback(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_callback *op = data;
 
     op->callback(op->object);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_cs_emit_callback(struct wined3d_cs *cs, void (*callback)(void *object), void *object)
 {
     struct wined3d_cs_callback *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CALLBACK;
     op->callback = callback;
     op->object = object;
@@ -1540,40 +2194,103 @@ void wined3d_cs_init_object(struct wined3d_cs *cs, void (*callback)(void *object
     wined3d_cs_emit_callback(cs, callback, object);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_query_issue *op = data;
     struct wined3d_query *query = op->query;
+#if !defined(STAGING_CSMT)
+
+    query->query_ops->query_issue(query, op->flags);
+#else  /* STAGING_CSMT */
+    struct wined3d_context *context;
 
     query->query_ops->query_issue(query, op->flags);
+
+    InterlockedDecrement(&query->pending);
+
+    if (query->flush && (context = context_get_current()))
+        context->gl_info->gl_ops.gl.p_glFlush();
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_cs_query_issue *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
     op->query = query;
     op->flags = flags;
 
+#if defined(STAGING_CSMT)
+    InterlockedIncrement(&query->pending);
+
+#endif /* STAGING_CSMT */
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_preload_resource(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_query_poll(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_poll *op = data;
+    struct wined3d_query *query = op->query;
+
+    *op->ret = query->query_ops->query_poll(query, op->flags);
+
+    return sizeof(*op);
+}
+
+BOOL wined3d_cs_emit_query_poll(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_cs_query_poll *op;
+    BOOL ret;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_QUERY_POLL;
+    op->query = query;
+    op->flags = flags;
+    op->ret = &ret;
+
+    cs->ops->submit_and_wait(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_preload_resource(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_preload_resource *op = data;
     struct wined3d_resource *resource = op->resource;
 
     resource->resource_ops->resource_preload(resource);
     wined3d_resource_release(resource);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
     struct wined3d_cs_preload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRELOAD_RESOURCE;
     op->resource = resource;
 
@@ -1582,20 +2299,32 @@ void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_reso
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_unload_resource(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_unload_resource(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_unload_resource *op = data;
     struct wined3d_resource *resource = op->resource;
 
     resource->resource_ops->resource_unload(resource);
     wined3d_resource_release(resource);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
     struct wined3d_cs_unload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNLOAD_RESOURCE;
     op->resource = resource;
 
@@ -1604,13 +2333,21 @@ void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resou
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_map(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_map(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_map *op = data;
     struct wined3d_resource *resource = op->resource;
 
     *op->hr = resource->resource_ops->resource_sub_resource_map(resource,
             op->sub_resource_idx, op->map_desc, op->box, op->flags);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
@@ -1619,7 +2356,11 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     struct wined3d_cs_map *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_MAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
@@ -1628,17 +2369,29 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     op->flags = flags;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_unmap(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_unmap(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_unmap *op = data;
     struct wined3d_resource *resource = op->resource;
 
     *op->hr = resource->resource_ops->resource_sub_resource_unmap(resource, op->sub_resource_idx);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx)
@@ -1646,18 +2399,30 @@ HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resourc
     struct wined3d_cs_unmap *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNMAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_update_sub_resource *op = data;
     const struct wined3d_box *box = &op->box;
@@ -1707,6 +2472,9 @@ static void wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const voi
 
 done:
     wined3d_resource_release(op->resource);
+#if defined(STAGING_CSMT)
+    return op->size;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
@@ -1714,9 +2482,60 @@ void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_r
         unsigned int slice_pitch)
 {
     struct wined3d_cs_update_sub_resource *op;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+#else  /* STAGING_CSMT */
+    size_t data_size, size;
+
+    if (resource->type != WINED3D_RTYPE_BUFFER && resource->format_flags & WINED3DFMT_FLAG_BLOCKS)
+        goto no_async;
+
+    data_size = 0;
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_TEXTURE_3D:
+            data_size += (box->back - box->front - 1) * slice_pitch;
+            /* fall-through */
+        case WINED3D_RTYPE_TEXTURE_2D:
+            data_size += (box->bottom - box->top - 1) * row_pitch;
+            /* fall-through */
+        case WINED3D_RTYPE_TEXTURE_1D:
+            data_size += (box->right - box->left) * resource->format->byte_count;
+            break;
+        case WINED3D_RTYPE_BUFFER:
+            data_size = box->right - box->left;
+            break;
+    }
+
+    size = FIELD_OFFSET(struct wined3d_cs_update_sub_resource, copy_data[data_size]);
+    if (size > sizeof(cs->current_block->data))
+        goto no_async;
+
+    op = cs->ops->require_space(cs, size, 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->size = size;
+    op->resource = resource;
+    op->sub_resource_idx = sub_resource_idx;
+    op->box = *box;
+    op->data.row_pitch = row_pitch;
+    op->data.slice_pitch = slice_pitch;
+    op->data.data = op->copy_data;
+    memcpy(op->copy_data, data, data_size);
+
+    wined3d_resource_acquire(resource);
+
+    cs->ops->submit(cs);
+    return;
+
+no_async:
+    wined3d_resource_wait_idle(resource);
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->size = sizeof(*op);
+#endif /* STAGING_CSMT */
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->box = *box;
@@ -1726,11 +2545,336 @@ void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_r
 
     wined3d_resource_acquire(resource);
 
+#if defined(STAGING_CSMT)
+    cs->ops->submit_and_wait(cs);
+}
+
+static const struct
+{
+    size_t offset;
+    size_t size;
+    DWORD mask;
+}
+push_constant_info[] =
+{
+    /* WINED3D_PUSH_CONSTANTS_VS_F */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
+    /* WINED3D_PUSH_CONSTANTS_PS_F */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
+    /* WINED3D_PUSH_CONSTANTS_VS_I */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
+    /* WINED3D_PUSH_CONSTANTS_PS_I */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
+    /* WINED3D_PUSH_CONSTANTS_VS_B */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
+    /* WINED3D_PUSH_CONSTANTS_PS_B */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
+};
+
+static UINT wined3d_cs_exec_push_constants(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_push_constants *op = data;
+    struct wined3d_device *device = cs->device;
+    size_t size = FIELD_OFFSET(struct wined3d_cs_push_constants, constants[op->count * push_constant_info[op->p].size]);
+    unsigned int context_count;
+    unsigned int i;
+    size_t offset;
+
+    if (op->p == WINED3D_PUSH_CONSTANTS_VS_F)
+        device->shader_backend->shader_update_float_vertex_constants(device, op->start_idx, op->count);
+    else if (op->p == WINED3D_PUSH_CONSTANTS_PS_F)
+        device->shader_backend->shader_update_float_pixel_constants(device, op->start_idx, op->count);
+
+    offset = push_constant_info[op->p].offset + op->start_idx * push_constant_info[op->p].size;
+    memcpy((BYTE *)&cs->state + offset, op->constants, op->count * push_constant_info[op->p].size);
+    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= push_constant_info[op->p].mask;
+    }
+
+    return size;
+}
+
+void wined3d_cs_emit_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_cs_push_constants *op;
+
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_push_constants, constants[count * push_constant_info[p].size]), 0);
+    op->opcode = WINED3D_CS_OP_PUSH_CONSTANTS;
+    op->p = p;
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, count * push_constant_info[p].size);
+
+    cs->ops->submit_delayed(cs);
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_resource_release(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_release(&op->src_surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_acquire(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_acquire(&src_surface->container->resource);
+
+#endif /* STAGING_CSMT */
     cs->ops->submit(cs);
 }
 
+#if !defined(STAGING_CSMT)
 static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+#else  /* STAGING_CSMT */
+static UINT wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_device *device = cs->device;
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+        op->blitter->color_fill(device, op->view, &op->rect, &op->color);
+    else
+        op->blitter->depth_fill(device, op->view, &op->rect, op->flags, op->depth, op->stencil);
+
+    wined3d_resource_release(op->view->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter)
+{
+    struct wined3d_cs_clear_rtv *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->flags = flags;
+    if (flags & WINED3DCLEAR_TARGET)
+        op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+    op->blitter = blitter;
+
+    wined3d_resource_acquire(view->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL, 0);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_release(&op->src->resource);
+    wined3d_resource_release(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_acquire(&op->src->resource);
+    wined3d_resource_acquire(&op->dst->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_get_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    *op->hr = wined3d_texture_get_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+    HRESULT hr;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_GET_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->hr = &hr;
+
+    cs->ops->submit_and_wait(cs);
+
+    return hr;
+}
+
+static UINT wined3d_cs_exec_release_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    *op->hr = wined3d_texture_release_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+    HRESULT hr;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_RELEASE_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->hr = &hr;
+
+    cs->ops->submit_and_wait(cs);
+
+    return hr;
+}
+
+static UINT wined3d_cs_exec_update_swap_interval(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_swap_interval *op = data;
+
+    swapchain_update_swap_interval(op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_update_swap_interval *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_UPDATE_SWAP_INTERVAL;
+    op->swapchain = swapchain;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+static UINT wined3d_cs_exec_texture_add_dirty_region(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_add_dirty_region *op = data;
+    struct wined3d_texture *texture = op->texture;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL, 0);
+    if (!wined3d_texture_load_location(texture, op->sub_resource_idx, context, texture->resource.map_binding))
+    {
+        ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
+    }
+    else
+    {
+        wined3d_texture_invalidate_location(texture, op->sub_resource_idx, ~texture->resource.map_binding);
+    }
+    context_release(context);
+
+    wined3d_resource_release(&texture->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_add_dirty_region(struct wined3d_cs *cs,
+        struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        const struct wined3d_box *dirty_region)
+{
+    struct wined3d_cs_texture_add_dirty_region *op;
+
+    if (dirty_region)
+        WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    wined3d_resource_acquire(&texture->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT wined3d_cs_exec_buffer_copy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_copy *op = data;
+    HRESULT hr;
+
+    if (FAILED(hr = wined3d_buffer_copy(op->dst_buffer, op->dst_offset, op->src_buffer, op->src_offset, op->size)))
+        ERR("Failed to copy buffer, hr %#x.\n", hr);
+
+    wined3d_resource_release(&op->dst_buffer->resource);
+    wined3d_resource_release(&op->src_buffer->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_copy(struct wined3d_cs *cs, struct wined3d_buffer *dst_buffer,
+        unsigned int dst_offset, struct wined3d_buffer *src_buffer, unsigned int src_offset,
+        unsigned int size)
+{
+    struct wined3d_cs_buffer_copy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_BUFFER_COPY;
+    op->dst_buffer = dst_buffer;
+    op->dst_offset = dst_offset;
+    op->src_buffer = src_buffer;
+    op->src_offset = src_offset;
+    op->size = size;
+
+    wined3d_resource_acquire(&dst_buffer->resource);
+    wined3d_resource_acquire(&src_buffer->resource);
+
+    cs->ops->submit(cs);
+}
+
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+    /* WINED3D_CS_OP_SYNC                       */ wined3d_cs_exec_sync,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DISPATCH                   */ wined3d_cs_exec_dispatch,
@@ -1764,14 +2908,32 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
     /* WINED3D_CS_OP_CALLBACK                   */ wined3d_cs_exec_callback,
     /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+#if defined(STAGING_CSMT)
+    /* WINED3D_CS_OP_QUERY_POLL                 */ wined3d_cs_exec_query_poll,
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_PRELOAD_RESOURCE           */ wined3d_cs_exec_preload_resource,
     /* WINED3D_CS_OP_UNLOAD_RESOURCE            */ wined3d_cs_exec_unload_resource,
     /* WINED3D_CS_OP_MAP                        */ wined3d_cs_exec_map,
     /* WINED3D_CS_OP_UNMAP                      */ wined3d_cs_exec_unmap,
     /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
+#if !defined(STAGING_CSMT)
 };
 
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+#else  /* STAGING_CSMT */
+    /* WINED3D_CS_OP_PUSH_CONSTANTS             */ wined3d_cs_exec_push_constants,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
+    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
+    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
+    /* WINED3D_CS_OP_TEXTURE_ADD_DIRTY_REGION   */ wined3d_cs_exec_texture_add_dirty_region,
+    /* WINED3D_CS_OP_BUFFER_COPY                */ wined3d_cs_exec_buffer_copy,
+};
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size, int priority)
+#endif /* STAGING_CSMT */
 {
     if (size > (cs->data_size - cs->end))
     {
@@ -1815,6 +2977,7 @@ static void wined3d_cs_st_submit(struct wined3d_cs *cs)
         HeapFree(GetProcessHeap(), 0, data);
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
@@ -1855,15 +3018,271 @@ static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_pus
     for (i = 0, context_count = device->context_count; i < context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= push_constant_info[p].mask;
+#else  /* STAGING_CSMT */
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+};
+
+static void wined3d_cs_list_enqueue(struct wined3d_cs_list *list, struct wined3d_cs_block *block)
+{
+    EnterCriticalSection(&list->lock);
+    list_add_tail(&list->blocks, &block->entry);
+    LeaveCriticalSection(&list->lock);
+    InterlockedIncrement(&list->count);
+}
+
+static struct wined3d_cs_block *wined3d_cs_list_dequeue(struct wined3d_cs_list *list)
+{
+    struct list *head;
+
+    if (!list->count) return NULL;
+    EnterCriticalSection(&list->lock);
+    if (!(head = list_head(&list->blocks)))
+    {
+        LeaveCriticalSection(&list->lock);
+        return NULL;
+    }
+    list_remove(head);
+    LeaveCriticalSection(&list->lock);
+    InterlockedDecrement(&list->count);
+
+    return LIST_ENTRY(head, struct wined3d_cs_block, entry);
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (cs->exec_list.count || cs->exec_prio_list.count)
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+#endif /* STAGING_CSMT */
     }
 }
 
+#if !defined(STAGING_CSMT)
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
     wined3d_cs_st_require_space,
     wined3d_cs_st_submit,
     wined3d_cs_st_push_constants,
 };
+#else  /* STAGING_CSMT */
+static struct wined3d_cs_block *wined3d_cs_dequeue_command(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+    DWORD spin_count = 0;
+
+    /* FIXME: Use an event to wait after a couple of spins. */
+    for (;;)
+    {
+        if ((block = wined3d_cs_list_dequeue(&cs->exec_prio_list)))
+            return block;
+        if ((block = wined3d_cs_list_dequeue(&cs->exec_list)))
+            return block;
+
+        spin_count++;
+        if (spin_count >= WINED3D_CS_SPIN_COUNT)
+        {
+            wined3d_cs_wait_event(cs);
+            spin_count = 0;
+        }
+    }
+}
+
+static void wined3d_cs_list_init(struct wined3d_cs_list *list)
+{
+    InitializeCriticalSectionAndSpinCount(&list->lock, WINED3D_CS_SPIN_COUNT);
+    list->lock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wined3d_cs_list_lock");
+
+    list_init(&list->blocks);
+}
+
+static void wined3d_cs_list_cleanup(struct wined3d_cs_list *list)
+{
+    struct wined3d_cs_block *block, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(block, next, &list->blocks, struct wined3d_cs_block, entry)
+    {
+        list_remove(&block->entry);
+        HeapFree(GetProcessHeap(), 0, block);
+    }
+
+    list->lock.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&list->lock);
+}
+
+static struct wined3d_cs_block *wined3d_cs_get_block(struct wined3d_cs *cs, struct wined3d_cs_list *list)
+{
+    struct wined3d_cs_block *block;
+
+    while (!(block = wined3d_cs_list_dequeue(&cs->free_list)))
+    {
+        if (cs->num_blocks < 1024 &&  /* limit memory usage to about 16 MB */
+            (block = HeapAlloc(GetProcessHeap(), 0, sizeof(*block))))
+        {
+            cs->num_blocks++;
+            break;
+        }
+        while (!InterlockedCompareExchange(&cs->free_list.count, 0, 0));
+    }
+
+    block->pos = 0;
+    block->list = list;
+    block->fence = NULL;
+
+    return block;
+}
+
+static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, int priority)
+{
+    struct wined3d_cs_list *list = priority ? &cs->exec_prio_list : &cs->exec_list;
+    struct wined3d_cs_block *block;
+    void *data;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_require_space(cs, size, priority);
+
+    assert(size <= sizeof(block->data));
+
+    block = cs->current_block;
+    if (!block || block->pos + size > sizeof(block->data) || block->list != list)
+    {
+        if (block) cs->ops->submit(cs);
+        block = wined3d_cs_get_block(cs, list);
+        cs->current_block = block;
+    }
+
+    data = &block->data[block->pos];
+    block->pos += size;
+
+    return data;
+}
+
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_submit(cs);
+
+    block = cs->current_block;
+    wined3d_cs_list_enqueue(block->list, block);
+    cs->current_block = NULL;
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static void wined3d_cs_mt_submit_and_wait(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_block *block;
+    BOOL fence = FALSE;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_submit(cs);
+
+    block = cs->current_block;
+    block->fence = &fence;
+    wined3d_cs_list_enqueue(block->list, block);
+    cs->current_block = NULL;
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_submit_delayed(struct wined3d_cs *cs)
+{
+    assert(cs->thread_id != GetCurrentThreadId());
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_and_wait,
+    wined3d_cs_mt_submit_delayed,
+};
+
+static void wined3d_cs_mt_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    assert(cs->thread_id != GetCurrentThreadId());
+    assert(cs->ops == &wined3d_cs_mt_ops);
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    cs->ops->submit(cs);
+}
+
+static inline BOOL wined3d_cs_process_command(struct wined3d_cs *cs, struct wined3d_cs_block *block)
+{
+    UINT pos = 0;
+    BOOL ret = TRUE;
+
+    while (pos < block->pos)
+    {
+        enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&block->data[pos];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            ret = FALSE;
+            break;
+        }
+
+        pos += wined3d_cs_op_handlers[opcode](cs, &block->data[pos]);
+    }
+
+    if (block->fence)
+        InterlockedExchange(block->fence, TRUE);
+
+    wined3d_cs_list_enqueue(&cs->free_list, block);
+    return ret;
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+
+    TRACE("Started.\n");
+
+    for (;;)
+    {
+        struct wined3d_cs_block *block;
+        block = wined3d_cs_dequeue_command(cs);
+        if (!wined3d_cs_process_command(cs, block))
+            break;
+    }
+
+    TRACE("Stopped.\n");
+    return 0;
+}
+#endif /* STAGING_CSMT */
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
@@ -1894,12 +3313,57 @@ struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
+    if (!(cs->event = CreateEventW(NULL, FALSE, FALSE, NULL)))
+    {
+        state_cleanup(&cs->state);
+        HeapFree(GetProcessHeap(), 0, cs->data);
+        HeapFree(GetProcessHeap(), 0, cs);
+        return NULL;
+    }
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        cs->ops = &wined3d_cs_mt_ops;
+
+        wined3d_cs_list_init(&cs->free_list);
+        wined3d_cs_list_init(&cs->exec_list);
+        wined3d_cs_list_init(&cs->exec_prio_list);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, &cs->thread_id)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            state_cleanup(&cs->state);
+            CloseHandle(cs->event);
+            HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+            HeapFree(GetProcessHeap(), 0, cs->data);
+            HeapFree(GetProcessHeap(), 0, cs);
+            return NULL;
+        }
+    }
+
+#endif /* STAGING_CSMT */
     return cs;
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
     state_cleanup(&cs->state);
+#if defined(STAGING_CSMT)
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_mt_emit_stop(cs);
+        WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+
+        wined3d_cs_list_cleanup(&cs->exec_prio_list);
+        wined3d_cs_list_cleanup(&cs->exec_list);
+        wined3d_cs_list_cleanup(&cs->free_list);
+    }
+
+    CloseHandle(cs->event);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, cs->data);
     HeapFree(GetProcessHeap(), 0, cs);
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -1008,6 +1008,9 @@ static void wined3d_device_delete_opengl_contexts_cs(void *object)
 static void wined3d_device_delete_opengl_contexts(struct wined3d_device *device)
 {
     wined3d_cs_destroy_object(device->cs, wined3d_device_delete_opengl_contexts_cs, device);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_device_create_primary_opengl_context_cs(void *object)
@@ -1043,6 +1046,9 @@ static void wined3d_device_create_primary_opengl_context_cs(void *object)
 static HRESULT wined3d_device_create_primary_opengl_context(struct wined3d_device *device)
 {
     wined3d_cs_init_object(device->cs, wined3d_device_create_primary_opengl_context_cs, device);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
     if (!device->swapchains[0]->num_contexts)
         return E_FAIL;
 
@@ -1187,6 +1193,10 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
     if (device->cursor_texture)
@@ -1196,6 +1206,9 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 
     wine_rb_clear(&device->samplers, device_free_sampler, NULL);
 
+#if defined(STAGING_CSMT)
+    context_set_current(NULL);
+#endif /* STAGING_CSMT */
     wined3d_device_delete_opengl_contexts(device);
 
     if (device->fb.depth_stencil)
@@ -1285,7 +1298,11 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     /* We can not acquire the context unless there is a swapchain. */
     if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+#if !defined(STAGING_CSMT)
             !wined3d_settings.emulated_textureram)
+#else  /* STAGING_CSMT */
+            !wined3d_settings.emulated_textureram && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
     {
         GLint vram_free_kb;
         UINT64 vram_free;
@@ -2335,7 +2352,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2384,7 +2405,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2429,7 +2454,11 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.vs_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.vs_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2568,7 +2597,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2617,7 +2650,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2663,7 +2700,11 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.ps_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.ps_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -3470,8 +3511,10 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3480,6 +3523,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL, 0);
     /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
     context->gl_info->gl_ops.gl.p_glFlush();
@@ -3487,6 +3531,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
      * fails. */
     context_release(context);
 
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3634,11 +3679,17 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+#else  /* STAGING_CSMT */
+/* Context activation is done by the caller. */
+static void wined3d_device_update_texture_3d(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         struct wined3d_texture *src_texture, unsigned int src_level,
         struct wined3d_texture *dst_texture, unsigned int level_count)
 {
     struct wined3d_const_bo_address data;
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     struct wined3d_map_desc src;
     HRESULT hr = WINED3D_OK;
@@ -3662,6 +3713,13 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
     }
 
     context = context_acquire(device, NULL, 0);
+#else  /* STAGING_CSMT */
+    struct wined3d_map_desc src;
+    unsigned int i;
+
+    TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            context, src_texture, src_level, dst_texture, level_count);
+#endif /* STAGING_CSMT */
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3669,15 +3727,22 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 
     for (i = 0; i < level_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
                 src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
             goto done;
+#else  /* STAGING_CSMT */
+        if (FAILED(wined3d_resource_map(&src_texture->resource,
+                src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
+            return;
+#endif /* STAGING_CSMT */
 
         data.buffer_object = 0;
         data.addr = src.data;
         wined3d_texture_upload_data(dst_texture, i, context, NULL, &data, src.row_pitch, src.slice_pitch);
         wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
 
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
             goto done;
     }
@@ -3685,16 +3750,89 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 done:
     context_release(context);
     return hr;
+#else  /* STAGING_CSMT */
+        if (FAILED(wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            return;
+    }
+}
+
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int level_count, i, j;
+
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (dst_texture->resource.type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    wined3d_texture_load(dst_texture, context, FALSE);
+
+    /* Update every surface level of the texture. */
+    switch (dst_texture->resource.type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < src_texture->layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    HRESULT hr;
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return;
+                    }
+                }
+            }
+            break;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            wined3d_device_update_texture_3d(context,
+                    src_texture, src_skip_levels, dst_texture, level_count);
+            break;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", dst_texture->resource.type);
+    }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
 {
     unsigned int src_size, dst_size, src_skip_levels = 0;
+#if !defined(STAGING_CSMT)
     unsigned int layer_count, level_count, i, j;
     enum wined3d_resource_type type;
     HRESULT hr;
     struct wined3d_context *context;
+#else  /* STAGING_CSMT */
+    unsigned int layer_count;
+    enum wined3d_resource_type type;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3731,6 +3869,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     level_count = min(wined3d_texture_get_level_count(src_texture),
             wined3d_texture_get_level_count(dst_texture));
 
@@ -3753,9 +3892,21 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     context_release(context);
 
     /* Update every surface level of the texture. */
+#else  /* STAGING_CSMT */
+    /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
+     * rejects mismatching formats, and we can't report the error back after dispatching the
+     * call. */
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+#endif /* STAGING_CSMT */
     switch (type)
     {
         case WINED3D_RTYPE_TEXTURE_2D:
+#if !defined(STAGING_CSMT)
         {
             unsigned int src_levels = src_texture->level_count;
             unsigned int dst_levels = dst_texture->level_count;
@@ -3788,6 +3939,38 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             FIXME("Unsupported texture type %#x.\n", type);
             return WINED3DERR_INVALIDCALL;
     }
+#else  /* STAGING_CSMT */
+            break;
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            src_size = max(src_texture->resource.width, src_texture->resource.height);
+            src_size = max(src_size, src_texture->resource.depth);
+            dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+            dst_size = max(dst_size, dst_texture->resource.depth);
+
+            while (src_size > dst_size)
+            {
+                src_size >>= 1;
+                ++src_skip_levels;
+            }
+
+            if (wined3d_texture_get_level_width(src_texture, src_skip_levels) != dst_texture->resource.width
+                    || wined3d_texture_get_level_height(src_texture, src_skip_levels) != dst_texture->resource.height
+                    || wined3d_texture_get_level_depth(src_texture, src_skip_levels) != dst_texture->resource.depth)
+            {
+                WARN("Source and destination dimensions do not match.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+            break;
+
+        default:
+            break;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3973,10 +4156,16 @@ void CDECL wined3d_device_copy_resource(struct wined3d_device *device,
 
     if (dst_resource->type == WINED3D_RTYPE_BUFFER)
     {
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_buffer_copy(buffer_from_resource(dst_resource), 0,
                 buffer_from_resource(src_resource), 0,
                 dst_resource->size)))
             ERR("Failed to copy buffer, hr %#x.\n", hr);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_buffer_copy(device->cs, buffer_from_resource(dst_resource), 0,
+                buffer_from_resource(src_resource), 0,
+                dst_resource->size);
+#endif /* STAGING_CSMT */
         return;
     }
 
@@ -4097,8 +4286,14 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
             return WINED3DERR_INVALIDCALL;
         }
 
+#if !defined(STAGING_CSMT)
         return wined3d_buffer_copy(buffer_from_resource(dst_resource), dst_x,
                 buffer_from_resource(src_resource), src_offset, size);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_buffer_copy(device->cs, buffer_from_resource(dst_resource), dst_x,
+                buffer_from_resource(src_resource), src_offset, size);
+        return WINED3D_OK;
+#endif /* STAGING_CSMT */
     }
 
     if (dst_resource->type != WINED3D_RTYPE_TEXTURE_2D)
@@ -4244,10 +4439,15 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
         return blitter->color_fill(device, view, rect, color);
     else
         return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4817,7 +5017,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     {
         if (reset_state)
             hr = wined3d_device_create_primary_opengl_context(device);
+#if !defined(STAGING_CSMT)
         swapchain_update_swap_interval(swapchain);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
+#endif /* STAGING_CSMT */
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -5132,3 +5336,58 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -37,6 +37,9 @@ static void wined3d_query_init(struct wined3d_query *query, struct wined3d_devic
     query->data = data;
     query->data_size = data_size;
     query->query_ops = query_ops;
+#if defined(STAGING_CSMT)
+    query->pending = 0;
+#endif /* STAGING_CSMT */
 }
 
 static struct wined3d_event_query *wined3d_event_query_from_query(struct wined3d_query *query)
@@ -350,7 +353,17 @@ HRESULT CDECL wined3d_query_get_data(struct wined3d_query *query,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!query->query_ops->query_poll(query, flags))
+#else  /* STAGING_CSMT */
+    if (flags & WINED3DGETDATA_FLUSH)
+        query->flush = TRUE;
+    if (InterlockedCompareExchange(&query->pending, 0, 0))
+        return S_FALSE;
+
+    query->flush = FALSE;
+    if (!wined3d_cs_emit_query_poll(query->device->cs, query, flags))
+#endif /* STAGING_CSMT */
         return S_FALSE;
 
     if (data)
@@ -504,7 +517,11 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
      * restart. */
     if (flags & WINED3DISSUE_BEGIN)
     {
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -535,13 +552,20 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
         checkGLcall("glBeginQuery()");
 
         context_release(context);
+#if defined(STAGING_CSMT)
+        oq->started = TRUE;
+#endif /* STAGING_CSMT */
     }
     if (flags & WINED3DISSUE_END)
     {
         /* MSDN says END on a non-building occlusion query returns an error,
          * but our tests show that it returns OK. But OpenGL doesn't like it,
          * so avoid generating an error. */
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -558,6 +582,9 @@ static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD
                 context_release(context);
             }
         }
+#if defined(STAGING_CSMT)
+        oq->started = FALSE;
+#endif /* STAGING_CSMT */
     }
 }
 
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -356,6 +356,11 @@ HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned i
 
     flags = wined3d_resource_sanitise_map_flags(resource, flags);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
 }
 
@@ -371,6 +376,11 @@ HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned
 {
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
 }
 
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -645,8 +645,12 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
     struct wined3d_view_desc view_desc;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -657,6 +661,7 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.flags = 0;
     view_desc.u.texture.level_idx = surface->texture_level;
@@ -672,6 +677,19 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 
     hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(surface->container, surface->texture_level);
+    view.height = wined3d_texture_get_level_height(surface->container, surface->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
+
+    hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2431,8 +2449,12 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
     struct wined3d_view_desc view_desc;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2443,6 +2465,7 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.flags = 0;
     view_desc.u.texture.level_idx = s->texture_level;
@@ -2458,6 +2481,19 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 
     hr = blitter->color_fill(device, view, rect, color);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(s->container, s->texture_level);
+    view.height = wined3d_texture_get_level_height(s->container, s->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
+
+    hr = blitter->color_fill(device, &view, rect, color);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2772,7 +2808,11 @@ static BOOL surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if !defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
+#endif /* STAGING_CSMT */
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
@@ -3737,7 +3777,11 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_blit_surface,
 };
 
+#if !defined(STAGING_CSMT)
 HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#else  /* STAGING_CSMT */
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#endif /* STAGING_CSMT */
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -3747,11 +3791,18 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#if !defined(STAGING_CSMT)
     struct wined3d_texture *src_texture = NULL;
     unsigned int src_sub_resource_idx = 0;
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
     HRESULT hr;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *src_texture;
+    unsigned int src_sub_resource_idx;
+    DWORD src_ds_flags, dst_ds_flags;
+    BOOL scale, convert;
+#endif /* STAGING_CSMT */
 
     static const DWORD simple_blit = WINED3D_BLT_ASYNC
             | WINED3D_BLT_COLOR_FILL
@@ -3762,6 +3813,7 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
+#if !defined(STAGING_CSMT)
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
@@ -3779,10 +3831,12 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 fx->src_color_key.color_space_high_value);
     }
 
+#endif /* STAGING_CSMT */
     if (src_surface)
     {
         src_texture = src_surface->container;
         src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+#if !defined(STAGING_CSMT)
     }
 
     if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
@@ -3822,6 +3876,15 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         if (!once++)
             FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
         flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+#else  /* STAGING_CSMT */
+        src_swapchain = src_texture->swapchain;
+    }
+    else
+    {
+        src_texture = NULL;
+        src_sub_resource_idx = 0;
+        src_swapchain = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (!device->d3d_initialized)
@@ -3846,11 +3909,13 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         goto fallback;
     }
 
+#if !defined(STAGING_CSMT)
     if (src_texture)
         src_swapchain = src_texture->swapchain;
     else
         src_swapchain = NULL;
 
+#endif /* STAGING_CSMT */
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -3886,13 +3951,21 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             TRACE("Depth fill.\n");
 
             if (!wined3d_format_convert_color_to_float(dst_texture->resource.format, NULL, fx->fill_color, &color))
+#if !defined(STAGING_CSMT)
                 return WINED3DERR_INVALIDCALL;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, color.r)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, color.r)))
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
+#if !defined(STAGING_CSMT)
             if (src_ds_flags != dst_ds_flags)
             {
                 WARN("Rejecting depth / stencil blit between incompatible formats.\n");
@@ -3902,6 +3975,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
+                    src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
+                return;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -3937,7 +4015,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -3981,7 +4063,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                                     context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
+#if !defined(STAGING_CSMT)
                         return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                        return;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4005,7 +4091,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4026,7 +4116,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4036,7 +4130,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -4044,9 +4142,128 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+#if !defined(STAGING_CSMT)
         return WINED3D_OK;
 
 cpu:
     return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
             src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+#else  /* STAGING_CSMT */
+        return;
+
+cpu:
+    surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+            src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+}
+
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_box dst_box = {dst_rect->left, dst_rect->top, dst_rect->right, dst_rect->bottom, 0, 1};
+    struct wined3d_box src_box = {src_rect->left, src_rect->top, src_rect->right, src_rect->bottom, 0, 1};
+    struct wined3d_texture *dst_texture = dst_surface->container;
+    struct wined3d_texture *src_texture = NULL;
+    struct wined3d_device *device = dst_texture->resource.device;
+    unsigned int dst_sub_resource_idx = surface_get_sub_resource_idx(dst_surface), src_sub_resource_idx;
+    struct wined3d_texture_sub_resource *dst_sub_resource =
+            &dst_texture->sub_resources[dst_sub_resource_idx];
+    struct wined3d_texture_sub_resource *src_sub_resource = NULL;
+    DWORD src_ds_flags, dst_ds_flags;
+    HRESULT hr;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_texture = src_surface->container;
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+        src_sub_resource = &src_surface->container->sub_resources[src_sub_resource_idx];
+    }
+
+    if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+    {
+        wined3d_cs_emit_sync(device->cs);
+        if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    if (FAILED(hr = wined3d_texture_check_box_dimensions(dst_texture, dst_surface->texture_level, &dst_box)))
+        return hr;
+
+    if (src_texture && FAILED(hr = wined3d_texture_check_box_dimensions(src_texture,
+            src_surface->texture_level, &src_box)))
+        return hr;
+
+    dst_ds_flags = dst_texture->resource.format_flags
+            & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+    if (src_surface)
+        src_ds_flags = src_surface->container->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+    else
+        src_ds_flags = 0;
+
+    if (!(flags & WINED3D_BLT_DEPTH_FILL) && (src_ds_flags != dst_ds_flags))
+    {
+        WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* FIXME: We should select the blitter in the main thread, that way we can return an error if the blit
+     * is unsupported without duplicating all the checks... */
+    if (flags & WINED3D_BLT_COLOR_FILL && (dst_surface->container->resource.format_flags & WINED3DFMT_FLAG_BLOCKS))
+    {
+        WARN("Block color fill, returning WINED3DERR_INVALIDCALL\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, dst_rect, src_surface, src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -66,6 +66,9 @@ static void swapchain_cleanup(struct wined3d_swapchain *swapchain)
     }
 
     wined3d_cs_destroy_object(swapchain->device->cs, wined3d_swapchain_destroy_object, swapchain);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(swapchain->device->cs);
+#endif /* STAGING_CSMT */
 
     /* Restore the screen resolution if we rendered in fullscreen.
      * This will restore the screen resolution to what it was before creating
@@ -113,6 +116,12 @@ ULONG CDECL wined3d_swapchain_decref(struct wined3d_swapchain *swapchain)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_device *device = swapchain->device;
+
+        wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -585,7 +594,11 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if !defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1)
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFinish();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
@@ -965,6 +978,9 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
         }
 
         wined3d_cs_init_object(device->cs, wined3d_swapchain_cs_init, swapchain);
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
 
         if (!swapchain->context[0])
         {
@@ -1105,6 +1121,10 @@ static struct wined3d_context *swapchain_create_context(struct wined3d_swapchain
 
     TRACE("Creating a new context for swapchain %p, thread %u.\n", swapchain, GetCurrentThreadId());
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(swapchain->device->cs);
+
+#endif /* STAGING_CSMT */
     if (!(ctx = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format)))
     {
         ERR("Failed to create a new context for the swapchain\n");
@@ -1291,6 +1311,9 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1302,6 +1325,10 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -337,7 +337,11 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if !defined(STAGING_CSMT)
         data->buffer_object = sub_resource->buffer_object;
+#else  /* STAGING_CSMT */
+        data->buffer_object = sub_resource->buffer->name;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -438,6 +442,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
 {
     GLuint *buffer_object;
@@ -450,6 +455,19 @@ static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
             *buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
+    GLuint name = buffer->name;
+
+    wined3d_device_release_bo(texture->resource.device, buffer, context);
+    texture->sub_resources[sub_resource_idx].buffer = NULL;
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -469,7 +487,11 @@ static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+#if !defined(STAGING_CSMT)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -626,28 +648,46 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     GLuint buffer_object;
+#else  /* STAGING_CSMT */
+    struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     unsigned int i;
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (!(buffer_object = texture->sub_resources[i].buffer_object))
             continue;
 
         TRACE("Deleting buffer object %u.\n", buffer_object);
+#else  /* STAGING_CSMT */
+        if (!(buffer = texture->sub_resources[i].buffer))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer->name);
+#endif /* STAGING_CSMT */
 
         /* We may not be able to get a context in wined3d_texture_cleanup() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
+#if !defined(STAGING_CSMT)
         {
             context = context_acquire(device, NULL, 0);
             gl_info = context->gl_info;
         }
 
         GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+#else  /* STAGING_CSMT */
+            context = context_acquire(device, NULL, 0);
+
+        wined3d_device_release_bo(device, buffer, context);
+        texture->sub_resources[i].buffer = NULL;
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -1340,18 +1380,31 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if !defined(STAGING_CSMT)
         wined3d_surface_create_dc(surface);
+#else  /* STAGING_CSMT */
+    {
+        HDC dc;
+        wined3d_texture_get_dc(texture, 0, &dc);
+        wined3d_texture_release_dc(texture, 0, dc);
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if !defined(STAGING_CSMT)
     if (sub_resource->buffer_object)
         return;
 
@@ -1363,6 +1416,16 @@ static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *textur
 
     TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
             sub_resource->buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+    if (sub_resource->buffer)
+        return;
+
+    sub_resource->buffer = wined3d_device_get_bo(texture->resource.device,
+            sub_resource->size, GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer->name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1488,7 +1551,11 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if !defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1543,7 +1610,9 @@ static struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(str
 HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
         UINT layer, const struct wined3d_box *dirty_region)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     unsigned int sub_resource_idx;
 
     TRACE("texture %p, layer %u, dirty_region %s.\n", texture, layer, debug_box(dirty_region));
@@ -1555,6 +1624,7 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
     }
     sub_resource_idx = layer * texture->level_count;
 
+#if !defined(STAGING_CSMT)
     if (dirty_region)
         WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
 
@@ -1568,6 +1638,9 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
     wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
     context_release(context);
 
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_texture_add_dirty_region(texture->resource.device->cs, texture, sub_resource_idx, dirty_region);
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1801,7 +1874,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context, location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
                 texture1d_upload_data(texture, sub_resource_idx, context, NULL, &data, row_pitch, slice_pitch);
@@ -1846,7 +1923,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -2140,8 +2221,13 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if !defined(STAGING_CSMT)
         if (sub_resource->buffer_object)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer)
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -2742,11 +2828,23 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
+#if !defined(STAGING_CSMT)
             if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
                     && FAILED(hr = wined3d_surface_create_dc(surface)))
             {
                 wined3d_texture_cleanup_sync(texture);
                 return hr;
+#else  /* STAGING_CSMT */
+            if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
+            {
+                HDC dc;
+                if (FAILED(hr = wined3d_texture_get_dc(texture, idx, &dc)))
+                {
+                    wined3d_texture_cleanup_sync(texture);
+                    return hr;
+                }
+                wined3d_texture_release_dc(texture, idx, dc);
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -2922,7 +3020,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
@@ -2968,7 +3070,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -3473,13 +3579,49 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+    HRESULT hr = WINED3D_OK;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL, 0);
+
+    wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        hr = wined3d_surface_create_dc(surface);
+    if (context)
+        context_release(context);
+    if (FAILED(hr))
+        return hr;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+
+    return hr;
+}
+
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
 {
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context = NULL;
     struct wined3d_surface *surface;
     HRESULT hr = WINED3D_OK;
+#else  /* STAGING_CSMT */
+    struct wined3d_surface *surface;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -3504,6 +3646,7 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     if (device->d3d_initialized)
         context = context_acquire(device, NULL, 0);
 
@@ -3521,11 +3664,40 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
         texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
     ++texture->resource.map_count;
     ++sub_resource->map_count;
+#else  /* STAGING_CSMT */
+    wined3d_resource_wait_idle(&texture->resource);
+
+    hr = wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
+    if (FAILED(hr))
+        return hr;
+#endif /* STAGING_CSMT */
 
     *dc = surface->dc;
     TRACE("Returning dc %p.\n", *dc);
 
+#if !defined(STAGING_CSMT)
     return hr;
+#else  /* STAGING_CSMT */
+    return WINED3D_OK;
+}
+
+HRESULT wined3d_texture_release_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
+
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -3556,6 +3728,7 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
         wined3d_surface_destroy_dc(surface);
 
@@ -3566,4 +3739,9 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    wined3d_resource_wait_idle(&texture->resource);
+
+    return wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -594,6 +594,10 @@ static void wined3d_shader_resource_view_cs_init(void *object)
                     debug_d3dformat(resource->format->id), debug_d3dformat(view_format->id));
         }
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_resource_release(resource);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_view *view,
@@ -610,6 +614,9 @@ static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_
 
     wined3d_resource_incref(view->resource = resource);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_acquire(resource);
+#endif /* STAGING_CSMT */
     wined3d_cs_init_object(resource->device->cs, wined3d_shader_resource_view_cs_init, view);
 
     return WINED3D_OK;
@@ -786,6 +793,10 @@ static void wined3d_unordered_access_view_cs_init(void *object)
                     desc, texture, view->format);
         }
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_resource_release(resource);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_unordered_access_view_init(struct wined3d_unordered_access_view *view,
@@ -805,6 +816,9 @@ static HRESULT wined3d_unordered_access_view_init(struct wined3d_unordered_acces
 
     wined3d_resource_incref(view->resource = resource);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_acquire(resource);
+#endif /* STAGING_CSMT */
     wined3d_cs_init_object(resource->device->cs, wined3d_unordered_access_view_cs_init, view);
 
     return WINED3D_OK;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -90,6 +90,9 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No PS shader model limit by default. */
     ~0u,            /* No CS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
+    TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -327,7 +330,20 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if !defined(STAGING_CSMT)
     }
+#else  /* STAGING_CSMT */
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
+    }
+
+    FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
+        wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -391,6 +391,9 @@ struct wined3d_settings
     unsigned int max_sm_ps;
     unsigned int max_sm_cs;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
+    BOOL cs_multithreaded;
+#endif /* STAGING_CSMT */
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1564,6 +1567,10 @@ struct wined3d_query
     const void *data;
     DWORD data_size;
     const struct wined3d_query_ops *query_ops;
+#if defined(STAGING_CSMT)
+    LONG pending;
+    BOOL flush;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1605,6 +1612,9 @@ struct wined3d_occlusion_query
     GLuint id;
     struct wined3d_context *context;
     UINT64 samples;
+#if defined(STAGING_CSMT)
+    BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_timestamp_query
@@ -2591,6 +2601,16 @@ struct wined3d_state
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0u
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2702,6 +2722,14 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2777,11 +2805,13 @@ static inline void wined3d_resource_release(struct wined3d_resource *resource)
     InterlockedDecrement(&resource->access_count);
 }
 
+#if !defined(STAGING_CSMT)
 static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
 {
     while (InterlockedCompareExchange(&resource->access_count, 0, 0));
 }
 
+#endif /* STAGING_CSMT */
 void resource_cleanup(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *device,
         enum wined3d_resource_type type, const struct wined3d_format *format,
@@ -2892,7 +2922,11 @@ struct wined3d_texture
 
         unsigned int map_count;
         DWORD locations;
+#if !defined(STAGING_CSMT)
         GLuint buffer_object;
+#else  /* STAGING_CSMT */
+        struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -2945,6 +2979,9 @@ void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 HRESULT wined3d_texture_check_box_dimensions(const struct wined3d_texture *texture,
         unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
@@ -2960,6 +2997,10 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_texture_release_dc_cs(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
@@ -3067,6 +3108,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -3194,6 +3240,7 @@ enum wined3d_push_constants
     WINED3D_PUSH_CONSTANTS_PS_B,
 };
 
+#if !defined(STAGING_CSMT)
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
@@ -3201,6 +3248,33 @@ struct wined3d_cs_ops
     void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
             unsigned int start_idx, unsigned int count, const void *constants);
 };
+#else  /* STAGING_CSMT */
+struct wined3d_cs_list
+{
+    CRITICAL_SECTION lock;
+    struct list blocks;
+    LONG count;
+};
+
+struct wined3d_cs_block
+{
+    struct list entry;
+    UINT pos;
+    struct wined3d_cs_list *list;
+    BOOL *fence;
+    BYTE data[0x4000]; /* FIXME? The size is somewhat arbitrary. */
+};
+
+struct wined3d_cs_ops
+{
+    void *(*require_space)(struct wined3d_cs *cs, size_t size, int priority);
+    void (*submit)(struct wined3d_cs *cs);
+    void (*submit_and_wait)(struct wined3d_cs *cs);
+    void (*submit_delayed)(struct wined3d_cs *cs);
+};
+
+#define WINED3D_CS_SPIN_COUNT 10000000
+#endif /* STAGING_CSMT */
 
 struct wined3d_cs
 {
@@ -3211,23 +3285,75 @@ struct wined3d_cs
 
     size_t data_size, start, end;
     void *data;
+#if !defined(STAGING_CSMT)
+};
+#else  /* STAGING_CSMT */
+
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_cs_block *current_block;
+    struct wined3d_cs_list free_list;
+    struct wined3d_cs_list exec_list;
+    struct wined3d_cs_list exec_prio_list;
+    LONG num_blocks;
+
+    LONG pending_presents;
+
+    HANDLE event;
+    BOOL waiting_for_event;
 };
 
+static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
+{
+    if (resource->device->cs->thread_id == GetCurrentThreadId()) return;
+    while (InterlockedCompareExchange(&resource->access_count, 0, 0));
+}
+#endif /* STAGING_CSMT */
+
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_copy(struct wined3d_cs *cs, struct wined3d_buffer *dst_buffer,
+        unsigned int dst_offset, struct wined3d_buffer *src_buffer, unsigned int src_offset,
+        unsigned int size) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
         unsigned int group_count_x, unsigned int group_count_y, unsigned int group_count_z) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base_vertex_idx,
         unsigned int start_idx, unsigned int index_count, unsigned int start_instance,
         unsigned int instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override, DWORD flags) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+BOOL wined3d_cs_emit_query_poll(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx,
         const struct wined3d_vec4 *plane) DECLSPEC_HIDDEN;
@@ -3275,10 +3401,20 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, enum wined
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_texture_add_dirty_region(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, const struct wined3d_box *dirty_region) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_sync(struct wined3d_cs *cs);
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
         unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
         unsigned int slice_pitch) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_init_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
@@ -3286,12 +3422,14 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
 HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 
+#if !defined(STAGING_CSMT)
 static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
     cs->ops->push_constants(cs, p, start_idx, count, constants);
 }
 
+#endif /* STAGING_CSMT */
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
