From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

Based on patches by:
    Michael Müller <michael@fds-team.de>
    Sebastian Lackner <sebastian@fds-team.de>
    Stefan Dösinger <stefan@codeweavers.com>

diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -1265,6 +1265,9 @@ HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
         const struct wined3d_box *box, const void *data)
 {
     UINT offset, size;
+#if defined(STAGING_CSMT)
+    DWORD flags = 0;
+#endif /* STAGING_CSMT */
     HRESULT hr;
     BYTE *ptr;
 
@@ -1279,7 +1282,14 @@ HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
         size = buffer->resource.size;
     }
 
+#if !defined(STAGING_CSMT)
     if (FAILED(hr = wined3d_buffer_map(buffer, offset, size, &ptr, 0)))
+#else  /* STAGING_CSMT */
+    if (offset == 0 && size == buffer->resource.size)
+        flags = WINED3D_MAP_DISCARD;
+
+    if (FAILED(hr = wined3d_buffer_map(buffer, offset, size, &ptr, flags)))
+#endif /* STAGING_CSMT */
         return hr;
 
     memcpy(ptr, data, size);
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -31,6 +31,9 @@ enum wined3d_cs_op
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DISPATCH,
     WINED3D_CS_OP_DRAW,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_FINISH,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_FLUSH,
     WINED3D_CS_OP_SET_PREDICATION,
     WINED3D_CS_OP_SET_VIEWPORT,
@@ -127,6 +130,13 @@ struct wined3d_cs_draw
     BOOL indexed;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
+
+#endif /* STAGING_CSMT */
 struct wined3d_cs_flush
 {
     enum wined3d_cs_op opcode;
@@ -400,6 +410,9 @@ struct wined3d_cs_update_sub_resource
     unsigned int sub_resource_idx;
     struct wined3d_box box;
     struct wined3d_sub_resource_data data;
+#if defined(STAGING_CSMT)
+    BYTE copy_data[1];
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_add_dirty_texture_region
@@ -418,6 +431,18 @@ static void wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
 {
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_sync(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_nop *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_NOP;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+#endif /* STAGING_CSMT */
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 {
     const struct wined3d_cs_present *op = data;
@@ -429,6 +454,10 @@ static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 
     swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
 
+#if defined(STAGING_CSMT)
+    InterlockedDecrement(&cs->pending_presents);
+
+#endif /* STAGING_CSMT */
     wined3d_resource_release(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
     {
@@ -441,8 +470,14 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
 {
     struct wined3d_cs_present *op;
     unsigned int i;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    LONG pending;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRESENT;
     op->dst_window_override = dst_window_override;
     op->swapchain = swapchain;
@@ -456,7 +491,24 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
         wined3d_resource_acquire(&swapchain->back_buffers[i]->resource);
     }
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs);
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
@@ -492,7 +544,11 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     struct wined3d_cs_clear *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CLEAR;
     op->flags = flags;
     op->rt_count = rt_count;
@@ -528,7 +584,11 @@ void wined3d_cs_emit_clear_rendertarget_view(struct wined3d_cs *cs, struct wined
         struct wined3d_fb_state fb;
     } *extra;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[1]) + sizeof(*extra));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[1]) + sizeof(*extra), 0);
+#endif /* STAGING_CSMT */
     extra = (void *)&op->rects[1];
     extra->fb.render_targets = &extra->rt;
     op->fb = &extra->fb;
@@ -684,7 +744,11 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
     const struct wined3d_state *state = &cs->device->state;
     struct wined3d_cs_dispatch *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DISPATCH;
     op->group_count_x = group_count_x;
     op->group_count_y = group_count_y;
@@ -756,7 +820,11 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base
     struct wined3d_cs_draw *op;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_DRAW;
     op->primitive_type = primitive_type;
     op->base_vertex_idx = base_vertex_idx;
@@ -797,6 +865,26 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base
     cs->ops->submit(cs);
 }
 
+#if defined(STAGING_CSMT)
+static void wined3d_cs_exec_finish(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_context *context = context_get_current();
+
+    if (context)
+        context->gl_info->gl_ops.gl.p_glFinish();
+}
+
+void wined3d_cs_emit_finish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+    op->opcode = WINED3D_CS_OP_FINISH;
+
+    cs->ops->submit_and_wait(cs);
+}
+
+#endif /* STAGING_CSMT */
 static void wined3d_cs_exec_flush(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_context *context;
@@ -810,7 +898,11 @@ void wined3d_cs_emit_flush(struct wined3d_cs *cs)
 {
     struct wined3d_cs_flush *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_FLUSH;
 
     cs->ops->submit(cs);
@@ -828,7 +920,11 @@ void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query
 {
     struct wined3d_cs_set_predication *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_PREDICATION;
     op->predicate = predicate;
     op->value = value;
@@ -848,7 +944,11 @@ void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_vi
 {
     struct wined3d_cs_set_viewport *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
     op->viewport = *viewport;
 
@@ -867,7 +967,11 @@ void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
 {
     struct wined3d_cs_set_scissor_rect *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
     op->rect = *rect;
 
@@ -887,7 +991,11 @@ void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int v
 {
     struct wined3d_cs_set_rendertarget_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
     op->view_idx = view_idx;
     op->view = view;
@@ -936,7 +1044,11 @@ void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3
 {
     struct wined3d_cs_set_depth_stencil_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
     op->view = view;
 
@@ -955,7 +1067,11 @@ void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3
 {
     struct wined3d_cs_set_vertex_declaration *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
     op->declaration = declaration;
 
@@ -987,7 +1103,11 @@ void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_source *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
@@ -1013,7 +1133,11 @@ void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_i
 {
     struct wined3d_cs_set_stream_source_freq *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
     op->stream_idx = stream_idx;
     op->frequency = frequency;
@@ -1046,7 +1170,11 @@ void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
 {
     struct wined3d_cs_set_stream_output *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
     op->stream_idx = stream_idx;
     op->buffer = buffer;
@@ -1078,7 +1206,11 @@ void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buff
 {
     struct wined3d_cs_set_index_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
     op->buffer = buffer;
     op->format_id = format_id;
@@ -1108,7 +1240,11 @@ void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_sha
 {
     struct wined3d_cs_set_constant_buffer *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
     op->type = type;
     op->cb_idx = cb_idx;
@@ -1200,7 +1336,11 @@ void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined
 {
     struct wined3d_cs_set_texture *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE;
     op->stage = stage;
     op->texture = texture;
@@ -1232,7 +1372,11 @@ void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3
 {
     struct wined3d_cs_set_shader_resource_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
     op->type = type;
     op->view_idx = view_idx;
@@ -1262,7 +1406,11 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, enum wined
 {
     struct wined3d_cs_set_unordered_access_view *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_UNORDERED_ACCESS_VIEW;
     op->pipeline = pipeline;
     op->view_idx = view_idx;
@@ -1287,7 +1435,11 @@ void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type
 {
     struct wined3d_cs_set_sampler *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER;
     op->type = type;
     op->sampler_idx = sampler_idx;
@@ -1312,7 +1464,11 @@ void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type
 {
     struct wined3d_cs_set_shader *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SHADER;
     op->type = type;
     op->shader = shader;
@@ -1333,7 +1489,11 @@ void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
 {
     struct wined3d_cs_set_rasterizer_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RASTERIZER_STATE;
     op->state = rasterizer_state;
 
@@ -1352,7 +1512,11 @@ void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render
 {
     struct wined3d_cs_set_render_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
     op->state = state;
     op->value = value;
@@ -1373,7 +1537,11 @@ void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
 {
     struct wined3d_cs_set_texture_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
     op->stage = stage;
     op->state = state;
@@ -1395,7 +1563,11 @@ void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
 {
     struct wined3d_cs_set_sampler_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
     op->sampler_idx = sampler_idx;
     op->state = state;
@@ -1418,7 +1590,11 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 {
     struct wined3d_cs_set_transform *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
     op->state = state;
     op->matrix = *matrix;
@@ -1438,7 +1614,11 @@ void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const
 {
     struct wined3d_cs_set_clip_plane *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
     op->plane_idx = plane_idx;
     op->plane = *plane;
@@ -1514,7 +1694,11 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
 {
     struct wined3d_cs_set_color_key *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_COLOR_KEY;
     op->texture = texture;
     op->flags = flags;
@@ -1541,7 +1725,11 @@ void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_ma
 {
     struct wined3d_cs_set_material *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_MATERIAL;
     op->material = *material;
 
@@ -1589,7 +1777,11 @@ void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light
 {
     struct wined3d_cs_set_light *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_LIGHT;
     op->light = *light;
 
@@ -1622,7 +1814,11 @@ void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, unsigned int idx, B
 {
     struct wined3d_cs_set_light_enable *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
     op->idx = idx;
     op->enable = enable;
@@ -1687,7 +1883,11 @@ static void wined3d_cs_mt_push_constants(struct wined3d_cs *cs, enum wined3d_pus
     size_t size;
 
     size = count * wined3d_cs_push_constant_info[p].size;
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_push_constants, constants[size]));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_push_constants, constants[size]), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PUSH_CONSTANTS;
     op->type = p;
     op->start_idx = start_idx;
@@ -1711,7 +1911,11 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 {
     struct wined3d_cs_reset_state *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_RESET_STATE;
 
     cs->ops->submit(cs);
@@ -1728,7 +1932,11 @@ static void wined3d_cs_emit_callback(struct wined3d_cs *cs, void (*callback)(voi
 {
     struct wined3d_cs_callback *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CALLBACK;
     op->callback = callback;
     op->object = object;
@@ -1789,7 +1997,11 @@ void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *qu
 {
     struct wined3d_cs_query_issue *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
     op->query = query;
     op->flags = flags;
@@ -1810,7 +2022,11 @@ void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_reso
 {
     struct wined3d_cs_preload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_PRELOAD_RESOURCE;
     op->resource = resource;
 
@@ -1832,7 +2048,11 @@ void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resou
 {
     struct wined3d_cs_unload_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNLOAD_RESOURCE;
     op->resource = resource;
 
@@ -1856,7 +2076,11 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     struct wined3d_cs_map *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_MAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
@@ -1865,7 +2089,11 @@ HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
     op->flags = flags;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -1883,13 +2111,21 @@ HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resourc
     struct wined3d_cs_unmap *op;
     HRESULT hr;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UNMAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->hr = &hr;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
+#else  /* STAGING_CSMT */
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2022,7 +2258,11 @@ void wined3d_cs_emit_blt_sub_resource(struct wined3d_cs *cs, struct wined3d_reso
 {
     struct wined3d_cs_blt_sub_resource *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_BLT_SUB_RESOURCE;
     op->dst_resource = dst_resource;
     op->dst_sub_resource_idx = dst_sub_resource_idx;
@@ -2099,19 +2339,73 @@ void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_r
         unsigned int slice_pitch)
 {
     struct wined3d_cs_update_sub_resource *op;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    size_t data_size, size;
+
+    if (resource->type != WINED3D_RTYPE_BUFFER && resource->format_flags & WINED3DFMT_FLAG_BLOCKS)
+        goto no_async;
+
+    data_size = 0;
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_TEXTURE_3D:
+            data_size += (box->back - box->front - 1) * slice_pitch;
+            /* fall-through */
+        case WINED3D_RTYPE_TEXTURE_2D:
+            data_size += (box->bottom - box->top - 1) * row_pitch;
+            /* fall-through */
+        case WINED3D_RTYPE_TEXTURE_1D:
+            data_size += (box->right - box->left) * resource->format->byte_count;
+            break;
+        case WINED3D_RTYPE_BUFFER:
+            data_size = box->right - box->left;
+            break;
+    }
+
+    size = FIELD_OFFSET(struct wined3d_cs_update_sub_resource, copy_data[data_size]);
+    if (!cs->ops->check_space(cs, size, 0))
+        goto no_async;
+
+    op = cs->ops->require_space(cs, size, 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->box = *box;
     op->data.row_pitch = row_pitch;
     op->data.slice_pitch = slice_pitch;
+#if !defined(STAGING_CSMT)
     op->data.data = data;
+#else  /* STAGING_CSMT */
+    op->data.data = op->copy_data;
+    memcpy(op->copy_data, data, data_size);
+#endif /* STAGING_CSMT */
 
     wined3d_resource_acquire(resource);
 
     cs->ops->submit(cs);
+#if defined(STAGING_CSMT)
+    return;
+
+no_async:
+    wined3d_resource_wait_idle(resource);
+
+    op = cs->ops->require_space(cs, sizeof(*op), 1);
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->resource = resource;
+    op->sub_resource_idx = sub_resource_idx;
+    op->box = *box;
+    op->data.row_pitch = row_pitch;
+    op->data.slice_pitch = slice_pitch;
+    op->data.data = data;
+
+    wined3d_resource_acquire(resource);
+
+    cs->ops->submit_and_wait(cs);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_cs_exec_add_dirty_texture_region(struct wined3d_cs *cs, const void *data)
@@ -2140,7 +2434,11 @@ void wined3d_cs_emit_add_dirty_texture_region(struct wined3d_cs *cs,
 {
     struct wined3d_cs_add_dirty_texture_region *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_ADD_DIRTY_TEXTURE_REGION;
     op->texture = texture;
     op->layer = layer;
@@ -2154,7 +2452,11 @@ static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
 {
     struct wined3d_cs_stop *op;
 
+#if !defined(STAGING_CSMT)
     op = cs->ops->require_space(cs, sizeof(*op));
+#else  /* STAGING_CSMT */
+    op = cs->ops->require_space(cs, sizeof(*op), 0);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_STOP;
 
     cs->ops->submit(cs);
@@ -2167,6 +2469,9 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DISPATCH                   */ wined3d_cs_exec_dispatch,
     /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
+#if defined(STAGING_CSMT)
+    /* WINED3D_CS_OP_FINISH                     */ wined3d_cs_exec_finish,
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_FLUSH                      */ wined3d_cs_exec_flush,
     /* WINED3D_CS_OP_SET_PREDICATION            */ wined3d_cs_exec_set_predication,
     /* WINED3D_CS_OP_SET_VIEWPORT               */ wined3d_cs_exec_set_viewport,
@@ -2207,7 +2512,16 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_ADD_DIRTY_TEXTURE_REGION   */ wined3d_cs_exec_add_dirty_texture_region,
 };
 
+#if !defined(STAGING_CSMT)
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+#else  /* STAGING_CSMT */
+static BOOL wined3d_cs_st_check_space(struct wined3d_cs *cs, size_t size, int priority)
+{
+    return TRUE;
+}
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size, int priority)
+#endif /* STAGING_CSMT */
 {
     if (size > (cs->data_size - cs->end))
     {
@@ -2256,7 +2570,13 @@ static void wined3d_cs_st_submit(struct wined3d_cs *cs)
 
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
+#if !defined(STAGING_CSMT)
     wined3d_cs_st_require_space,
+#else  /* STAGING_CSMT */
+    wined3d_cs_st_check_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+#endif /* STAGING_CSMT */
     wined3d_cs_st_submit,
     wined3d_cs_st_push_constants,
 };
@@ -2268,7 +2588,28 @@ static BOOL wined3d_cs_queue_is_empty(const struct wined3d_cs_queue *queue)
 
 static void wined3d_cs_mt_submit(struct wined3d_cs *cs)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_cs_queue *queue = &cs->queue;
+#else  /* STAGING_CSMT */
+    struct wined3d_cs_queue *queue = cs->queue;
+    struct wined3d_cs_packet *packet;
+    size_t packet_size;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_submit(cs);
+
+    packet = (struct wined3d_cs_packet *)&queue->data[queue->head];
+    packet_size = FIELD_OFFSET(struct wined3d_cs_packet, data[packet->size]);
+    InterlockedExchange(&queue->head, (queue->head + packet_size) & (WINED3D_CS_QUEUE_SIZE - 1));
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static void wined3d_cs_mt_submit_and_wait(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_queue *queue = cs->queue;
+#endif /* STAGING_CSMT */
     struct wined3d_cs_packet *packet;
     size_t packet_size;
 
@@ -2286,15 +2627,42 @@ static void wined3d_cs_mt_submit(struct wined3d_cs *cs)
         wined3d_pause();
 }
 
+#if !defined(STAGING_CSMT)
 static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
 {
     struct wined3d_cs_queue *queue = &cs->queue;
+#else  /* STAGING_CSMT */
+static BOOL wined3d_cs_mt_check_space(struct wined3d_cs *cs, size_t size, int priority)
+{
+    struct wined3d_cs_queue *queue = priority ? &cs->prio_queue : &cs->norm_queue;
+    size_t queue_size = ARRAY_SIZE(queue->data);
+    size_t header_size, packet_size, remaining;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_check_space(cs, size, priority);
+
+    header_size = FIELD_OFFSET(struct wined3d_cs_packet, data[0]);
+    size = (size + header_size - 1) & ~(header_size - 1);
+    packet_size = FIELD_OFFSET(struct wined3d_cs_packet, data[size]);
+
+    remaining = queue_size - queue->head;
+    return (remaining >= packet_size);
+}
+
+static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, int priority)
+{
+    struct wined3d_cs_queue *queue = priority ? &cs->prio_queue : &cs->norm_queue;
+#endif /* STAGING_CSMT */
     size_t queue_size = ARRAY_SIZE(queue->data);
     size_t header_size, packet_size, remaining;
     struct wined3d_cs_packet *packet;
 
     if (cs->thread_id == GetCurrentThreadId())
+#if !defined(STAGING_CSMT)
         return wined3d_cs_st_require_space(cs, size);
+#else  /* STAGING_CSMT */
+        return wined3d_cs_st_require_space(cs, size, priority);
+#endif /* STAGING_CSMT */
 
     header_size = FIELD_OFFSET(struct wined3d_cs_packet, data[0]);
     size = (size + header_size - 1) & ~(header_size - 1);
@@ -2315,7 +2683,11 @@ static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
         TRACE("Inserting a nop for %lu + %lu bytes.\n",
                 (unsigned long)header_size, (unsigned long)nop_size);
 
+#if !defined(STAGING_CSMT)
         nop = wined3d_cs_mt_require_space(cs, nop_size);
+#else  /* STAGING_CSMT */
+        nop = wined3d_cs_mt_require_space(cs, nop_size, priority);
+#endif /* STAGING_CSMT */
         if (nop_size)
             nop->opcode = WINED3D_CS_OP_NOP;
 
@@ -2346,6 +2718,9 @@ static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
                 head, tail, (unsigned long)packet_size);
     }
 
+#if defined(STAGING_CSMT)
+    cs->queue = queue;
+#endif /* STAGING_CSMT */
     packet = (struct wined3d_cs_packet *)&queue->data[queue->head];
     packet->size = size;
     return packet->data;
@@ -2353,8 +2728,15 @@ static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
 
 static const struct wined3d_cs_ops wined3d_cs_mt_ops =
 {
+#if !defined(STAGING_CSMT)
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_submit,
+#else  /* STAGING_CSMT */
+    wined3d_cs_mt_check_space,
     wined3d_cs_mt_require_space,
     wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_and_wait,
+#endif /* STAGING_CSMT */
     wined3d_cs_mt_push_constants,
 };
 
@@ -2373,6 +2755,15 @@ static void poll_queries(struct wined3d_cs *cs)
     }
 }
 
+#if defined(STAGING_CSMT)
+static struct wined3d_cs_queue *wined3d_cs_get_queue(struct wined3d_cs *cs)
+{
+    if (!wined3d_cs_queue_is_empty(&cs->prio_queue)) return &cs->prio_queue;
+    if (!wined3d_cs_queue_is_empty(&cs->norm_queue)) return &cs->norm_queue;
+    return NULL;
+}
+
+#endif /* STAGING_CSMT */
 static void wined3d_cs_wait_event(struct wined3d_cs *cs)
 {
     InterlockedExchange(&cs->waiting_for_event, TRUE);
@@ -2384,7 +2775,11 @@ static void wined3d_cs_wait_event(struct wined3d_cs *cs)
      * Likewise, we can race with the main thread when resetting
      * "waiting_for_event", in which case we would need to call
      * WaitForSingleObject() because the main thread called SetEvent(). */
+#if !defined(STAGING_CSMT)
     if (!wined3d_cs_queue_is_empty(&cs->queue)
+#else  /* STAGING_CSMT */
+    if (wined3d_cs_get_queue(cs)
+#endif /* STAGING_CSMT */
             && InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
         return;
 
@@ -2403,7 +2798,9 @@ static DWORD WINAPI wined3d_cs_run(void *ctx)
 
     TRACE("Started.\n");
 
+#if !defined(STAGING_CSMT)
     queue = &cs->queue;
+#endif /* STAGING_CSMT */
     list_init(&cs->query_poll_list);
     cs->thread_id = GetCurrentThreadId();
     for (;;)
@@ -2414,7 +2811,11 @@ static DWORD WINAPI wined3d_cs_run(void *ctx)
             poll = 0;
         }
 
+#if !defined(STAGING_CSMT)
         if (wined3d_cs_queue_is_empty(queue))
+#else  /* STAGING_CSMT */
+        if (!(queue = wined3d_cs_get_queue(cs)))
+#endif /* STAGING_CSMT */
         {
             if (++spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
                 wined3d_cs_wait_event(cs);
@@ -2443,7 +2844,9 @@ static DWORD WINAPI wined3d_cs_run(void *ctx)
         InterlockedExchange(&queue->tail, tail);
     }
 
+#if !defined(STAGING_CSMT)
     queue->tail = queue->head = 0;
+#endif /* STAGING_CSMT */
     TRACE("Stopped.\n");
     FreeLibraryAndExitThread(cs->wined3d_module, 0);
 }
@@ -2514,17 +2917,28 @@ fail:
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+#if !defined(STAGING_CSMT)
     state_cleanup(&cs->state);
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, cs->data);
 
+#endif /* STAGING_CSMT */
     if (cs->thread)
     {
         wined3d_cs_emit_stop(cs);
+#if defined(STAGING_CSMT)
+        WaitForSingleObject(cs->thread, INFINITE);
+#endif /* STAGING_CSMT */
         CloseHandle(cs->thread);
         if (!CloseHandle(cs->event))
             ERR("Closing event failed.\n");
     }
 
+#if defined(STAGING_CSMT)
+    state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+    HeapFree(GetProcessHeap(), 0, cs->data);
+
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -1023,6 +1023,9 @@ static void wined3d_device_delete_opengl_contexts_cs(void *object)
 static void wined3d_device_delete_opengl_contexts(struct wined3d_device *device)
 {
     wined3d_cs_destroy_object(device->cs, wined3d_device_delete_opengl_contexts_cs, device);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_device_create_primary_opengl_context_cs(void *object)
@@ -1061,6 +1064,9 @@ static void wined3d_device_create_primary_opengl_context_cs(void *object)
 static HRESULT wined3d_device_create_primary_opengl_context(struct wined3d_device *device)
 {
     wined3d_cs_init_object(device->cs, wined3d_device_create_primary_opengl_context_cs, device);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
     if (!device->swapchains[0]->num_contexts)
         return E_FAIL;
 
@@ -1205,6 +1211,10 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
     if (device->cursor_texture)
@@ -1214,6 +1224,9 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 
     wine_rb_clear(&device->samplers, device_free_sampler, NULL);
 
+#if defined(STAGING_CSMT)
+    context_set_current(NULL);
+#endif /* STAGING_CSMT */
     wined3d_device_delete_opengl_contexts(device);
 
     if (device->fb.depth_stencil)
@@ -4165,6 +4178,7 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
             return WINED3DERR_INVALIDCALL;
         }
 
+#if !defined(STAGING_CSMT)
         if (dst_texture->sub_resources[dst_sub_resource_idx].map_count)
         {
             WARN("Destination sub-resource %u is mapped.\n", dst_sub_resource_idx);
@@ -4175,6 +4189,18 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
         {
             WARN("Source sub-resource %u is mapped.\n", src_sub_resource_idx);
             return WINED3DERR_INVALIDCALL;
+#else  /* STAGING_CSMT */
+        if (dst_texture->sub_resources[dst_sub_resource_idx].map_count ||
+            src_texture->sub_resources[src_sub_resource_idx].map_count)
+        {
+            wined3d_cs_emit_sync(dst_texture->resource.device->cs);
+            if (dst_texture->sub_resources[dst_sub_resource_idx].map_count ||
+                src_texture->sub_resources[src_sub_resource_idx].map_count)
+            {
+                WARN("Destination or source sub-resource is mapped.\n");
+                return WINEDDERR_SURFACEBUSY;
+            }
+#endif /* STAGING_CSMT */
         }
 
         if (!src_box)
@@ -5206,3 +5232,58 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -363,6 +363,11 @@ HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned i
 
     flags = wined3d_resource_sanitise_map_flags(resource, flags);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
 }
 
@@ -378,6 +383,11 @@ HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned
 {
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        wined3d_resource_wait_idle(resource);
+
+#endif /* STAGING_CSMT */
     return wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
 }
 
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -2416,7 +2416,11 @@ static BOOL surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if !defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
+#endif /* STAGING_CSMT */
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -66,6 +66,9 @@ static void swapchain_cleanup(struct wined3d_swapchain *swapchain)
     }
 
     wined3d_cs_destroy_object(swapchain->device->cs, wined3d_swapchain_destroy_object, swapchain);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(swapchain->device->cs);
+#endif /* STAGING_CSMT */
 
     /* Restore the screen resolution if we rendered in fullscreen.
      * This will restore the screen resolution to what it was before creating
@@ -113,6 +116,12 @@ ULONG CDECL wined3d_swapchain_decref(struct wined3d_swapchain *swapchain)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_device *device = swapchain->device;
+
+        wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -477,7 +486,11 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if !defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1)
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFinish();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
@@ -900,6 +913,9 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
         }
 
         wined3d_cs_init_object(device->cs, wined3d_swapchain_cs_init, swapchain);
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
 
         if (!swapchain->context[0])
         {
@@ -1040,6 +1056,10 @@ static struct wined3d_context *swapchain_create_context(struct wined3d_swapchain
 
     TRACE("Creating a new context for swapchain %p, thread %u.\n", swapchain, GetCurrentThreadId());
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(swapchain->device->cs);
+
+#endif /* STAGING_CSMT */
     if (!(ctx = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format)))
     {
         ERR("Failed to create a new context for the swapchain\n");
@@ -1189,6 +1209,9 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1200,6 +1223,10 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_sync(device->cs);
+
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -292,7 +292,11 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if !defined(STAGING_CSMT)
         data->buffer_object = sub_resource->buffer_object;
+#else  /* STAGING_CSMT */
+        data->buffer_object = sub_resource->buffer->name;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -393,6 +397,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
 {
     GLuint *buffer_object = &texture->sub_resources[sub_resource_idx].buffer_object;
@@ -405,6 +410,19 @@ static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture
 
     wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
     *buffer_object = 0;
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
+    GLuint name = buffer->name;
+
+    wined3d_device_release_bo(texture->resource.device, buffer, context);
+    texture->sub_resources[sub_resource_idx].buffer = NULL;
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -424,7 +442,11 @@ static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+#if !defined(STAGING_CSMT)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -581,28 +603,46 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     GLuint buffer_object;
+#else  /* STAGING_CSMT */
+    struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     unsigned int i;
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (!(buffer_object = texture->sub_resources[i].buffer_object))
             continue;
 
         TRACE("Deleting buffer object %u.\n", buffer_object);
+#else  /* STAGING_CSMT */
+        if (!(buffer = texture->sub_resources[i].buffer))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer->name);
+#endif /* STAGING_CSMT */
 
         /* We may not be able to get a context in wined3d_texture_cleanup() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
+#if !defined(STAGING_CSMT)
         {
             context = context_acquire(device, NULL, 0);
             gl_info = context->gl_info;
         }
 
         GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+#else  /* STAGING_CSMT */
+            context = context_acquire(device, NULL, 0);
+
+        wined3d_device_release_bo(device, buffer, context);
+        texture->sub_resources[i].buffer = NULL;
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -1338,6 +1378,9 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     if (surface->dc)
     {
         wined3d_cs_destroy_object(device->cs, texture2d_destroy_dc, surface);
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
         create_dib = TRUE;
     }
 
@@ -1398,18 +1441,30 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if !defined(STAGING_CSMT)
         wined3d_cs_init_object(device->cs, texture2d_create_dc, surface);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_cs_init_object(device->cs, texture2d_create_dc, surface);
+        wined3d_cs_emit_sync(device->cs);
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if !defined(STAGING_CSMT)
     if (sub_resource->buffer_object)
         return;
 
@@ -1421,6 +1476,16 @@ static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *textur
 
     TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
             sub_resource->buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+    if (sub_resource->buffer)
+        return;
+
+    sub_resource->buffer = wined3d_device_get_bo(texture->resource.device,
+            sub_resource->size, GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer->name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1546,7 +1611,11 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if !defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1847,7 +1916,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context, location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
                 texture1d_upload_data(texture, sub_resource_idx, context, NULL, &data, row_pitch, slice_pitch);
@@ -1892,7 +1965,11 @@ static BOOL texture1d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -2186,8 +2263,13 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if !defined(STAGING_CSMT)
         if (sub_resource->buffer_object)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer)
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -2782,6 +2864,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
             {
                 wined3d_cs_init_object(device->cs, texture2d_create_dc, surface);
+#if defined(STAGING_CSMT)
+                wined3d_cs_emit_sync(device->cs);
+#endif /* STAGING_CSMT */
                 if (!surface->dc)
                 {
                     wined3d_texture_cleanup_sync(texture);
@@ -2962,7 +3047,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
@@ -3008,7 +3097,11 @@ static BOOL texture3d_load_location(struct wined3d_texture *texture, unsigned in
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -3226,8 +3319,18 @@ HRESULT CDECL wined3d_texture_blt(struct wined3d_texture *dst_texture, unsigned
     if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
             || src_texture->sub_resources[src_sub_resource_idx].map_count)
     {
+#if !defined(STAGING_CSMT)
         WARN("Sub-resource is busy, returning WINEDDERR_SURFACEBUSY.\n");
         return WINEDDERR_SURFACEBUSY;
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_sync(dst_texture->resource.device->cs);
+        if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
+                || (src_texture && src_texture->sub_resources[src_sub_resource_idx].map_count))
+        {
+            WARN("Sub-resource is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+#endif /* STAGING_CSMT */
     }
 
     if ((src_format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
@@ -3569,7 +3672,14 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
         return WINED3DERR_INVALIDCALL;
 
     if (!surface->dc)
+#if !defined(STAGING_CSMT)
         wined3d_cs_init_object(device->cs, texture2d_create_dc, surface);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_cs_init_object(device->cs, texture2d_create_dc, surface);
+        wined3d_cs_emit_sync(device->cs);
+    }
+#endif /* STAGING_CSMT */
     if (!surface->dc)
         return WINED3DERR_INVALIDCALL;
 
@@ -3613,7 +3723,14 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
     }
 
     if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+#if !defined(STAGING_CSMT)
         wined3d_cs_destroy_object(device->cs, texture2d_destroy_dc, surface);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_cs_destroy_object(device->cs, texture2d_destroy_dc, surface);
+        wined3d_cs_emit_sync(device->cs);
+    }
+#endif /* STAGING_CSMT */
 
     --sub_resource->map_count;
     if (!--texture->resource.map_count && texture->update_map_binding)
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -716,6 +716,10 @@ static void wined3d_shader_resource_view_cs_init(void *object)
                     debug_d3dformat(resource->format->id), debug_d3dformat(view_format->id));
         }
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_resource_release(resource);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_view *view,
@@ -732,6 +736,9 @@ static HRESULT wined3d_shader_resource_view_init(struct wined3d_shader_resource_
 
     wined3d_resource_incref(view->resource = resource);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_acquire(resource);
+#endif /* STAGING_CSMT */
     wined3d_cs_init_object(resource->device->cs, wined3d_shader_resource_view_cs_init, view);
 
     return WINED3D_OK;
@@ -898,6 +905,10 @@ static void wined3d_unordered_access_view_cs_init(void *object)
                     desc, texture, view->format);
         }
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_resource_release(resource);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_unordered_access_view_init(struct wined3d_unordered_access_view *view,
@@ -917,6 +928,9 @@ static HRESULT wined3d_unordered_access_view_init(struct wined3d_unordered_acces
 
     wined3d_resource_incref(view->resource = resource);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_acquire(resource);
+#endif /* STAGING_CSMT */
     wined3d_cs_init_object(resource->device->cs, wined3d_unordered_access_view_cs_init, view);
 
     return WINED3D_OK;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -72,7 +72,11 @@ static CRITICAL_SECTION wined3d_wndproc_cs = {&wined3d_wndproc_cs_debug, -1, 0,
  * where appropriate. */
 struct wined3d_settings wined3d_settings =
 {
+#if !defined(STAGING_CSMT)
     FALSE,          /* No multithreaded CS by default. */
+#else  /* STAGING_CSMT */
+    TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
     MAKEDWORD_VERSION(1, 0), /* Default to legacy OpenGL */
     TRUE,           /* Use of GLSL enabled by default */
     ORM_FBO,        /* Use FBOs to do offscreen rendering */
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2645,6 +2645,16 @@ struct wined3d_state
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0u
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2756,6 +2766,12 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2942,7 +2958,11 @@ struct wined3d_texture
 
         unsigned int map_count;
         DWORD locations;
+#if !defined(STAGING_CSMT)
         GLuint buffer_object;
+#else  /* STAGING_CSMT */
+        struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -3249,8 +3269,15 @@ struct wined3d_cs_queue
 
 struct wined3d_cs_ops
 {
+#if !defined(STAGING_CSMT)
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
     void (*submit)(struct wined3d_cs *cs);
+#else  /* STAGING_CSMT */
+    BOOL (*check_space)(struct wined3d_cs *cs, size_t size, int priority);
+    void *(*require_space)(struct wined3d_cs *cs, size_t size, int priority);
+    void (*submit)(struct wined3d_cs *cs);
+    void (*submit_and_wait)(struct wined3d_cs *cs);
+#endif /* STAGING_CSMT */
     void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
             unsigned int start_idx, unsigned int count, const void *constants);
 };
@@ -3265,13 +3292,23 @@ struct wined3d_cs
     HANDLE thread;
     DWORD thread_id;
 
+#if !defined(STAGING_CSMT)
     struct wined3d_cs_queue queue;
+#else  /* STAGING_CSMT */
+    struct wined3d_cs_queue *queue;
+    struct wined3d_cs_queue norm_queue;
+    struct wined3d_cs_queue prio_queue;
+#endif /* STAGING_CSMT */
     size_t data_size, start, end;
     void *data;
     struct list query_poll_list;
 
     HANDLE event;
     BOOL waiting_for_event;
+#if defined(STAGING_CSMT)
+
+    LONG pending_presents;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
@@ -3293,6 +3330,9 @@ void wined3d_cs_emit_dispatch(struct wined3d_cs *cs,
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, GLenum primitive_type, int base_vertex_idx,
         unsigned int start_idx, unsigned int index_count, unsigned int start_instance,
         unsigned int instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_finish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_flush(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
@@ -3345,6 +3385,9 @@ void wined3d_cs_emit_set_unordered_access_view(struct wined3d_cs *cs, enum wined
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_sync(struct wined3d_cs *cs);
+#endif /* STAGING_CSMT */
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
         unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
