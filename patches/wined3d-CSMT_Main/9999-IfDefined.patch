From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

diff --git a/dlls/d3d8/tests/visual.c b/dlls/d3d8/tests/visual.c
--- a/dlls/d3d8/tests/visual.c
+++ b/dlls/d3d8/tests/visual.c
@@ -5480,7 +5480,11 @@
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
     todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
+    ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1339,7 +1339,11 @@
          * result on Wine.
          * {D3DFMT_YUY2,     "D3DFMT_YUY2",     BLOCKS,                              0},
          * {D3DFMT_UYVY,     "D3DFMT_UYVY",     BLOCKS,                              0}, */
+#if defined(STAGING_CSMT)
         {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS,                              0},
+#else  /* STAGING_CSMT */
+        {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS | TODO_FILL_RETURN,           0},
+#endif /* STAGING_CSMT */
         /* Vendor-specific formats like ATI2N are a non-issue here since they're not
          * supported as offscreen plain surfaces and do not support D3DUSAGE_RENDERTARGET
          * when created as texture. */
@@ -17618,7 +17622,11 @@
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
     todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
+    ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -704,7 +704,11 @@
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
+#if defined(STAGING_CSMT)
         UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
+        UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constants_f(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -729,12 +733,14 @@
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
     unsigned int i;
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
     }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -748,12 +754,14 @@
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
     unsigned int i;
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
     }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -4732,7 +4740,11 @@
         }
         else
         {
+#if defined(STAGING_CSMT)
             UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
+            UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -8002,11 +8014,16 @@
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         context->gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain
             && (dst_texture->swapchain->front_buffer == dst_texture)))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain && (dst_texture->swapchain->front_buffer == dst_texture)))
+#endif /* STAGING_CSMT */
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,7 +32,11 @@
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_USE_BO       0x02    /* Use a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
+#if defined(STAGING_CSMT)
 #define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#else  /* STAGING_CSMT */
+#define WINED3D_BUFFER_DISCARD      0x08    /* A DISCARD lock has occurred since the last preload. */
+#endif /* STAGING_CSMT */
 #define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
 #define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
 
@@ -41,7 +45,11 @@
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
+#if defined(STAGING_CSMT)
 void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#else  /* STAGING_CSMT */
+static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#endif /* STAGING_CSMT */
 {
     if (!offset && (!size || size == buffer->resource.size))
         goto invalidate_all;
@@ -122,7 +130,11 @@
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -194,10 +206,14 @@
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+#if defined(STAGING_CSMT)
     {
         wined3d_resource_free_sysmem(&This->resource);
         This->resource.map_heap_memory = NULL;
     }
+#else  /* STAGING_CSMT */
+        wined3d_resource_free_sysmem(&This->resource);
+#endif /* STAGING_CSMT */
 
     return;
 
@@ -461,8 +477,12 @@
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
+#if defined(STAGING_CSMT)
         if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
                 && buffer->flags & WINED3D_BUFFER_USE_BO)
+#else  /* STAGING_CSMT */
+        if ((buffer->flags & WINED3D_BUFFER_USE_BO) && !buffer->resource.map_count)
+#endif /* STAGING_CSMT */
         {
             buffer_create_buffer_object(buffer, context);
             if (buffer->buffer_object)
@@ -500,7 +520,9 @@
 
     if (!wined3d_resource_allocate_sysmem(&buffer->resource))
         ERR("Failed to allocate system memory.\n");
+#if defined(STAGING_CSMT)
     buffer->resource.heap_memory = buffer->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
 
     buffer_bind(buffer, context);
     GL_EXTCALL(glGetBufferSubData(buffer->buffer_type_hint, 0, buffer->resource.size, buffer->resource.heap_memory));
@@ -545,6 +567,7 @@
     resource_unload(resource);
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer)
 {
     struct wined3d_context *context;
@@ -577,6 +600,30 @@
 
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
         wined3d_cs_emit_buffer_cleanup(device->cs, buffer);
+#else  /* STAGING_CSMT */
+ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
+{
+    ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
+    struct wined3d_context *context;
+
+    TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
+
+    if (!refcount)
+    {
+        if (buffer->buffer_object)
+        {
+            context = context_acquire(buffer->resource.device, NULL);
+            delete_gl_buffer(buffer, context->gl_info);
+            context_release(context);
+
+            HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+        }
+
+        resource_cleanup(&buffer->resource);
+        buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
+        HeapFree(GetProcessHeap(), 0, buffer->maps);
+        HeapFree(GetProcessHeap(), 0, buffer);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -661,6 +708,7 @@
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
+#if defined(STAGING_CSMT)
     UINT start = 0, len = 0;
 
     /* This potentially invalidates the element array buffer binding, but the
@@ -684,6 +732,45 @@
         GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
         checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
         This->flags &= ~WINED3D_BUFFER_APPLESYNC;
+#else  /* STAGING_CSMT */
+    BYTE *map;
+    UINT start, len;
+
+    /* This potentially invalidates the element array buffer binding, but the
+     * caller always takes care of this. */
+    GL_EXTCALL(glBindBuffer(This->buffer_type_hint, This->buffer_object));
+    checkGLcall("glBindBuffer");
+    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+    {
+        GLbitfield mapflags;
+        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
+        if (flags & WINED3D_BUFFER_DISCARD)
+            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
+        else if (!(flags & WINED3D_BUFFER_SYNC))
+            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
+        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
+                    This->resource.size, mapflags));
+        checkGLcall("glMapBufferRange");
+    }
+    else
+    {
+        if (This->flags & WINED3D_BUFFER_APPLESYNC)
+        {
+            DWORD syncflags = 0;
+            if (flags & WINED3D_BUFFER_DISCARD)
+                syncflags |= WINED3D_MAP_DISCARD;
+            else if (!(flags & WINED3D_BUFFER_SYNC))
+                syncflags |= WINED3D_MAP_NOOVERWRITE;
+            buffer_sync_apple(This, syncflags, gl_info);
+        }
+        map = GL_EXTCALL(glMapBuffer(This->buffer_type_hint, GL_WRITE_ONLY));
+        checkGLcall("glMapBuffer");
+    }
+    if (!map)
+    {
+        ERR("Failed to map opengl buffer\n");
+        return;
+#endif /* STAGING_CSMT */
     }
 
     while (This->modified_areas)
@@ -692,12 +779,33 @@
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glBufferSubData(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
         checkGLcall("glBufferSubData");
     }
 }
 
 static void buffer_mark_used(struct wined3d_buffer *buffer)
+#else  /* STAGING_CSMT */
+        memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
+
+        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+        {
+            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
+            checkGLcall("glFlushMappedBufferRange");
+        }
+        else if (This->flags & WINED3D_BUFFER_APPLESYNC)
+        {
+            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
+            checkGLcall("glFlushMappedBufferRangeAPPLE");
+        }
+    }
+    GL_EXTCALL(glUnmapBuffer(This->buffer_type_hint));
+    checkGLcall("glUnmapBuffer");
+}
+
+void buffer_mark_used(struct wined3d_buffer *buffer)
+#endif /* STAGING_CSMT */
 {
     buffer->flags &= ~(WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -716,6 +824,14 @@
 
     TRACE("buffer %p.\n", buffer);
 
+#if !defined(STAGING_CSMT)
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+#endif /* STAGING_CSMT */
     buffer_mark_used(buffer);
 
     if (!buffer->buffer_object)
@@ -903,6 +1019,7 @@
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = buffer->resource.device;
 
     if (buffer->resource.map_count)
@@ -912,6 +1029,12 @@
     }
 
     wined3d_cs_emit_buffer_preload(device->cs, buffer);
+#else  /* STAGING_CSMT */
+    struct wined3d_context *context;
+    context = context_acquire(buffer->resource.device, NULL);
+    buffer_internal_preload(buffer, context, NULL);
+    context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -925,6 +1048,7 @@
 {
     LONG count;
     BYTE *base;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = buffer->resource.device;
     struct wined3d_context *context;
 
@@ -948,6 +1072,10 @@
     {
         wined3d_cs_emit_create_vbo(device->cs, buffer);
     }
+#else  /* STAGING_CSMT */
+
+    TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
+#endif /* STAGING_CSMT */
 
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
@@ -956,7 +1084,11 @@
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
+#if defined(STAGING_CSMT)
     if (buffer->ignore_discard)
+#else  /* STAGING_CSMT */
+    if (buffer->flags & WINED3D_BUFFER_DISCARD)
+#endif /* STAGING_CSMT */
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -967,6 +1099,7 @@
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
+#if defined(STAGING_CSMT)
             wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
             wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
@@ -984,6 +1117,19 @@
                     wined3d_cs_emit_glfinish(device->cs);
                     device->cs->ops->finish(device->cs);
                 }
+#else  /* STAGING_CSMT */
+            buffer_invalidate_bo_range(buffer, 0, 0);
+        else if (!(flags & WINED3D_MAP_READONLY))
+            buffer_invalidate_bo_range(buffer, offset, size);
+
+        if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
+        {
+            if (count == 1)
+            {
+                struct wined3d_device *device = buffer->resource.device;
+                struct wined3d_context *context;
+                const struct wined3d_gl_info *gl_info;
+#endif /* STAGING_CSMT */
 
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
@@ -1032,6 +1178,7 @@
                         buffer_get_sysmem(buffer, context);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
+#if defined(STAGING_CSMT)
                 }
                 context_release(context);
             }
@@ -1071,6 +1218,21 @@
     }
 
     base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
+#else  /* STAGING_CSMT */
+                    buffer->map_ptr = NULL;
+                }
+                context_release(context);
+            }
+        }
+
+        if (flags & WINED3D_MAP_DISCARD)
+            buffer->flags |= WINED3D_BUFFER_DISCARD;
+        else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+            buffer->flags |= WINED3D_BUFFER_SYNC;
+    }
+
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+#endif /* STAGING_CSMT */
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1133,6 +1295,7 @@
         }
 
         GL_EXTCALL(glUnmapBuffer(buffer->buffer_type_hint));
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
@@ -1141,6 +1304,18 @@
 
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+            gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+        context_release(context);
+
+        buffer_clear_dirty_areas(buffer);
+        buffer->map_ptr = NULL;
+    }
+    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
+    {
+        wined3d_buffer_preload(buffer);
+#endif /* STAGING_CSMT */
     }
 }
 
@@ -1333,7 +1508,9 @@
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+#if defined(STAGING_CSMT)
     buffer->ignore_discard = TRUE;
+#endif /* STAGING_CSMT */
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1369,6 +1546,7 @@
         buffer->flags |= WINED3D_BUFFER_USE_BO;
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
 
@@ -1379,6 +1557,13 @@
         resource_cleanup(&buffer->resource);
         if (wined3d_settings.cs_multithreaded)
             buffer->resource.device->cs->ops->finish(buffer->resource.device->cs);
+#else  /* STAGING_CSMT */
+    if (!(buffer->maps = HeapAlloc(GetProcessHeap(), 0, sizeof(*buffer->maps))))
+    {
+        ERR("Out of memory.\n");
+        buffer_unload(&buffer->resource);
+        resource_cleanup(&buffer->resource);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
     buffer->maps_size = 1;
@@ -1389,8 +1574,10 @@
         buffer_unload(&buffer->resource);
         resource_cleanup(&buffer->resource);
         HeapFree(GetProcessHeap(), 0, buffer->maps);
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             buffer->resource.device->cs->ops->finish(buffer->resource.device->cs);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -1501,6 +1688,7 @@
 
     return WINED3D_OK;
 }
+#if defined(STAGING_CSMT)
 
 void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
 {
@@ -1508,3 +1696,4 @@
     buffer->resource.heap_memory = mem;
     buffer->flags |= WINED3D_BUFFER_DISCARD;
 }
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1680,11 +1680,13 @@
         goto out;
     }
 
+#if defined(STAGING_CSMT)
     ret->current_fb.rt_size = gl_info->limits.buffers;
     if (!(ret->current_fb.render_targets = wined3d_calloc(ret->current_fb.rt_size,
             sizeof(*ret->current_fb.render_targets))))
         goto out;
 
+#endif /* STAGING_CSMT */
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1989,7 +1991,9 @@
     if (hdc) wined3d_release_dc(swapchain->win_handle, hdc);
     device->shader_backend->shader_free_context_data(ret);
     device->adapter->fragment_pipe->free_context_data(ret);
+#if defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -2026,7 +2030,9 @@
     device->shader_backend->shader_free_context_data(context);
     device->adapter->fragment_pipe->free_context_data(context);
     HeapFree(GetProcessHeap(), 0, context->fbo_key);
+#if defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2442,6 +2448,9 @@
 {
     /* Onscreen surfaces are always in a swapchain */
     struct wined3d_swapchain *swapchain = context->current_rt.texture->swapchain;
+#if !defined(STAGING_CSMT)
+    struct wined3d_surface *surface;
+#endif /* STAGING_CSMT */
 
     if (context->render_offscreen || !depth_stencil) return;
     if (match_depth_stencil_format(swapchain->ds_format, depth_stencil->format)) return;
@@ -2452,8 +2461,13 @@
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(context->current_rt.texture, context->current_rt.sub_resource_idx,
             context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    surface = context->current_rt.texture->sub_resources[context->current_rt.sub_resource_idx].u.surface;
+    surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
@@ -2554,7 +2568,11 @@
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb)
 {
     struct wined3d_rendertarget_view **rts = fb->render_targets;
@@ -2563,7 +2581,11 @@
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
+#if defined(STAGING_CSMT)
     if (isStateDirty(context, STATE_FRAMEBUFFER) || wined3d_fb_equal(fb, &context->current_fb)
+#else  /* STAGING_CSMT */
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != state->fb
+#endif /* STAGING_CSMT */
             || rt_count != gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, dsv))
@@ -2608,8 +2630,10 @@
             rt_mask = context_generate_rt_mask_no_fbo(context,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0])->container : NULL);
         }
+#if defined(STAGING_CSMT)
 
         wined3d_fb_copy(&context->current_fb, fb);
+#endif /* STAGING_CSMT */
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2650,8 +2674,12 @@
     gl_info->gl_ops.gl.p_glEnable(GL_SCISSOR_TEST);
     if (rt_count && gl_info->supported[ARB_FRAMEBUFFER_SRGB])
     {
+#if defined(STAGING_CSMT)
         /* FIXME: The way to access the state is ugly. */
         if (needs_srgb_write(context, &rts[0]->resource->device->cs->state, fb))
+#else  /* STAGING_CSMT */
+        if (needs_srgb_write(context, state, fb))
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
         else
             gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
@@ -2668,7 +2696,11 @@
 
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view **rts = state->fb.render_targets;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view **rts = state->fb->render_targets;
+#endif /* STAGING_CSMT */
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
@@ -2698,7 +2730,11 @@
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     DWORD rt_mask = find_draw_buffers_mask(context, state);
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2729,8 +2765,10 @@
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+#if defined(STAGING_CSMT)
 
     wined3d_fb_copy(&context->current_fb, &state->fb);
+#endif /* STAGING_CSMT */
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -3371,7 +3409,11 @@
         const struct wined3d_device *device, const struct wined3d_state *state)
 {
     const struct StateEntry *state_table = context->state_table;
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     unsigned int i;
     WORD map;
 
@@ -3404,12 +3446,17 @@
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
+#if defined(STAGING_CSMT)
                 buffer_internal_preload(state->streams[context->stream_info.elements[i].stream_idx].buffer,
                         context, state);
         }
         /* PreLoad may kick buffers out of vram. */
         if (isStateDirty(context, STATE_STREAMSRC))
             context_update_stream_info(context, state);
+#else  /* STAGING_CSMT */
+                buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
+        }
+#endif /* STAGING_CSMT */
     }
     if (state->index_buffer)
     {
@@ -3528,9 +3575,11 @@
 
     TRACE("device %p, target %p.\n", device, target);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded && device->cs->thread_id != GetCurrentThreadId())
         FIXME("Acquiring a GL context from outside the CS thread.\n");
 
+#endif /* STAGING_CSMT */
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,11 +22,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
+#if defined(STAGING_CSMT)
 enum wined3d_cs_op
 {
     WINED3D_CS_OP_NOP,
     WINED3D_CS_OP_SKIP,
     WINED3D_CS_OP_FENCE,
+#else  /* STAGING_CSMT */
+#define WINED3D_INITIAL_CS_SIZE 4096
+
+enum wined3d_cs_op
+{
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -53,6 +60,7 @@
     WINED3D_CS_OP_SET_COLOR_KEY,
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
+#if defined(STAGING_CSMT)
     WINED3D_CS_OP_SET_VS_CONSTS_F,
     WINED3D_CS_OP_SET_VS_CONSTS_B,
     WINED3D_CS_OP_SET_VS_CONSTS_I,
@@ -106,6 +114,7 @@
 {
     enum wined3d_cs_op opcode;
     BOOL *signalled;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -305,6 +314,7 @@
     enum wined3d_cs_op opcode;
 };
 
+#if defined(STAGING_CSMT)
 struct wined3d_cs_set_consts_f
 {
     enum wined3d_cs_op opcode;
@@ -2800,224 +2810,997 @@
     /* WINED3D_CS_OP_NOP                        */ wined3d_cs_exec_nop,
     /* WINED3D_CS_OP_SKIP                       */ wined3d_cs_exec_skip,
     /* WINED3D_CS_OP_FENCE                      */ wined3d_cs_exec_fence,
-    /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
-    /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
-    /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
-    /* WINED3D_CS_OP_SET_PREDICATION            */ wined3d_cs_exec_set_predication,
-    /* WINED3D_CS_OP_SET_VIEWPORT               */ wined3d_cs_exec_set_viewport,
-    /* WINED3D_CS_OP_SET_SCISSOR_RECT           */ wined3d_cs_exec_set_scissor_rect,
-    /* WINED3D_CS_OP_SET_RENDERTARGET_VIEW      */ wined3d_cs_exec_set_rendertarget_view,
-    /* WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW     */ wined3d_cs_exec_set_depth_stencil_view,
-    /* WINED3D_CS_OP_SET_VERTEX_DECLARATION     */ wined3d_cs_exec_set_vertex_declaration,
-    /* WINED3D_CS_OP_SET_STREAM_SOURCE          */ wined3d_cs_exec_set_stream_source,
-    /* WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ     */ wined3d_cs_exec_set_stream_source_freq,
-    /* WINED3D_CS_OP_SET_STREAM_OUTPUT          */ wined3d_cs_exec_set_stream_output,
-    /* WINED3D_CS_OP_SET_INDEX_BUFFER           */ wined3d_cs_exec_set_index_buffer,
-    /* WINED3D_CS_OP_SET_CONSTANT_BUFFER        */ wined3d_cs_exec_set_constant_buffer,
-    /* WINED3D_CS_OP_SET_TEXTURE                */ wined3d_cs_exec_set_texture,
-    /* WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW   */ wined3d_cs_exec_set_shader_resource_view,
-    /* WINED3D_CS_OP_SET_SAMPLER                */ wined3d_cs_exec_set_sampler,
-    /* WINED3D_CS_OP_SET_SHADER                 */ wined3d_cs_exec_set_shader,
-    /* WINED3D_CS_OP_SET_RENDER_STATE           */ wined3d_cs_exec_set_render_state,
-    /* WINED3D_CS_OP_SET_TEXTURE_STATE          */ wined3d_cs_exec_set_texture_state,
-    /* WINED3D_CS_OP_SET_SAMPLER_STATE          */ wined3d_cs_exec_set_sampler_state,
-    /* WINED3D_CS_OP_SET_TRANSFORM              */ wined3d_cs_exec_set_transform,
-    /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
-    /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
-    /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
-    /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
-    /* WINED3D_CS_OP_SET_VS_CONSTS_F            */ wined3d_cs_exec_set_vs_consts_f,
-    /* WINED3D_CS_OP_SET_VS_CONSTS_B            */ wined3d_cs_exec_set_vs_consts_b,
-    /* WINED3D_CS_OP_SET_VS_CONSTS_I            */ wined3d_cs_exec_set_vs_consts_i,
-    /* WINED3D_CS_OP_SET_PS_CONSTS_F            */ wined3d_cs_exec_set_ps_consts_f,
-    /* WINED3D_CS_OP_SET_PS_CONSTS_B            */ wined3d_cs_exec_set_ps_consts_b,
-    /* WINED3D_CS_OP_SET_PS_CONSTS_I            */ wined3d_cs_exec_set_ps_consts_i,
-    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
-    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX      */ wined3d_cs_exec_set_base_vertex_index,
-    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
-    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
-    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
-    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
-    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
-    /* WINED3D_CS_OP_TEXTURE_CHANGED            */ wined3d_cs_exec_texture_changed,
-    /* WINED3D_CS_OP_TEXTURE_MAP                */ wined3d_cs_exec_texture_map,
-    /* WINED3D_CS_OP_TEXTURE_UNMAP              */ wined3d_cs_exec_texture_unmap,
-    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
-    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
-    /* WINED3D_CS_OP_BUFFER_PRELOAD             */ wined3d_cs_exec_buffer_preload,
-    /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
-    /* WINED3D_CS_OP_QUERY_DESTROY              */ wined3d_cs_exec_query_destroy,
-    /* WINED3D_CS_OP_TEXTURE_PRELOAD            */ wined3d_cs_exec_texture_preload,
-    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
-    /* WINED3D_CS_OP_EVICT_RESOURCE             */ wined3d_cs_exec_evict_resource,
-    /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
-    /* WINED3D_CS_OP_VIEW_DESTROY               */ wined3d_cs_exec_view_destroy,
-    /* WINED3D_CS_OP_VDECL_DESTROY              */ wined3d_cs_exec_vertex_declaration_destroy,
-    /* WINED3D_CS_OP_SHADER_CLEANUP             */ wined3d_cs_exec_shader_cleanup,
-    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
-    /* WINED3D_CS_OP_RESOURCE_CLEANUP           */ wined3d_cs_exec_resource_cleanup,
-    /* WINED3D_CS_OP_BUFFER_CLEANUP             */ wined3d_cs_exec_buffer_cleanup,
-    /* WINED3D_CS_OP_TEXTURE_CLEANUP            */ wined3d_cs_exec_texture_cleanup,
-    /* WINED3D_CS_OP_SAMPLER_DESTROY            */ wined3d_cs_exec_sampler_destroy,
-    /* WINED3D_CS_OP_SAMPLER_INIT               */ wined3d_cs_exec_sampler_init,
-    /* WINED3D_CS_OP_SRV_DESTROY                */ wined3d_cs_exec_shader_resource_view_destroy,
-    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
-    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
-    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
-    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
-    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
-    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
-};
-
-static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+#else  /* STAGING_CSMT */
+static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
-    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
-
-    if (cs->thread_id == GetCurrentThreadId())
-        ERR("Attempting to queue a command from the CS thread.\n");
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
 
-    if (queue_size - size < queue->head)
-    {
-        struct wined3d_cs_skip *skip;
-        size_t nop_size = queue_size - queue->head;
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
 
-        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
-        if (nop_size < sizeof(*skip))
-        {
-            skip->opcode = WINED3D_CS_OP_NOP;
-        }
-        else
-        {
-            skip->opcode = WINED3D_CS_OP_SKIP;
-            skip->size = nop_size;
-        }
+    swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
+}
 
-        if (prio)
-            cs->ops->submit_prio(cs, nop_size);
-        else
-            cs->ops->submit(cs, nop_size);
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override, DWORD flags)
+{
+    struct wined3d_cs_present *op;
 
-        assert(!queue->head);
-    }
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_PRESENT;
+    op->dst_window_override = dst_window_override;
+    op->swapchain = swapchain;
+    op->src_rect = *src_rect;
+    op->dst_rect = *dst_rect;
+    op->flags = flags;
 
-    while(1)
-    {
-        LONG head = queue->head;
-        LONG tail = *((volatile LONG *)&queue->tail);
-        LONG new_pos;
-        /* Empty */
-        if (head == tail)
-            break;
-        /* Head ahead of tail, take care of wrap-around */
-        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
-        if (head > tail && (new_pos || tail))
-            break;
-        /* Tail ahead of head, but still enough space */
-        if (new_pos < tail && new_pos)
-            break;
+    cs->ops->submit(cs);
+}
 
-        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
-                (unsigned int) size);
-    }
+static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
 
-    return &queue->data[queue->head];
+    device = cs->device;
+    wined3d_get_draw_rect(&device->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
 }
 
-static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
-    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+    struct wined3d_cs_clear *op;
+
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+    op->opcode = WINED3D_CS_OP_CLEAR;
+    op->flags = flags;
+    op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+    op->rect_count = rect_count;
+    memcpy(op->rects, rects, sizeof(*rects) * rect_count);
+
+    cs->ops->submit(cs);
 }
 
-static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
 {
-    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+    const struct wined3d_cs_draw *op = data;
+
+    draw_primitive(cs->device, &cs->device->state, op->start_idx, op->index_count,
+            op->start_instance, op->instance_count, op->indexed);
 }
 
-/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
- * OP itself. */
-static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
+        UINT start_instance, UINT instance_count, BOOL indexed)
 {
-    struct wined3d_cs_stop *op;
+    struct wined3d_cs_draw *op;
 
-    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_STOP;
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DRAW;
+    op->start_idx = start_idx;
+    op->index_count = index_count;
+    op->start_instance = start_instance;
+    op->instance_count = instance_count;
+    op->indexed = indexed;
 
-    wined3d_cs_mt_submit(cs, sizeof(*op));
+    cs->ops->submit(cs);
 }
 
-static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
 {
-    BOOL fence;
-    wined3d_cs_emit_fence(cs, &fence);
+    const struct wined3d_cs_set_predication *op = data;
 
-    /* A busy wait should be fine, we're not supposed to have to wait very
-     * long. */
-    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+    cs->state.predicate = op->predicate;
+    cs->state.predicate_value = op->value;
 }
 
-static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
+void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
 {
-    BOOL fence;
-
-    if (cs->thread_id == GetCurrentThreadId())
-    {
-        static BOOL once;
-        if (!once)
-        {
-            FIXME("flush_and_wait called from cs thread\n");
-            once = TRUE;
-        }
-        return;
-    }
+    struct wined3d_cs_set_predication *op;
 
-    wined3d_cs_emit_fence_prio(cs, &fence);
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PREDICATION;
+    op->predicate = predicate;
+    op->value = value;
 
-    /* A busy wait should be fine, we're not supposed to have to wait very
-     * long. */
-    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+    cs->ops->submit(cs);
 }
 
-static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
 {
-    wined3d_cs_mt_require_space,
-    wined3d_cs_mt_require_space_prio,
-    wined3d_cs_mt_submit,
-    wined3d_cs_mt_submit_prio,
-    wined3d_cs_mt_finish,
-    wined3d_cs_mt_finish_prio,
-};
+    const struct wined3d_cs_set_viewport *op = data;
 
-static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(cs->device, STATE_VIEWPORT);
+}
+
+void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
 {
-    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+    struct wined3d_cs_set_viewport *op;
 
-    if (opcode >= WINED3D_CS_OP_STOP)
-    {
-        ERR("Invalid opcode %#x.\n", opcode);
-        return;
-    }
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
 
-    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
+    cs->ops->submit(cs);
 }
 
-static void wined3d_cs_st_finish(struct wined3d_cs *cs)
+static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
 {
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
 }
 
-static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
 {
-    return cs->queue.data;
+    struct wined3d_cs_set_scissor_rect *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+
+    cs->ops->submit(cs);
 }
 
-static const struct wined3d_cs_ops wined3d_cs_st_ops =
+static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
 {
-    wined3d_cs_st_require_space,
-    wined3d_cs_st_require_space,
-    wined3d_cs_st_submit,
-    wined3d_cs_st_submit,
-    wined3d_cs_st_finish,
-    wined3d_cs_st_finish,
+    const struct wined3d_cs_set_rendertarget_view *op = data;
+
+    cs->state.fb->render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+}
+
+void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
+        struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_rendertarget_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil_view *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_rendertarget_view *prev;
+
+    if ((prev = cs->state.fb->depth_stencil))
+    {
+        struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
+
+        if (prev_surface && (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || prev_surface->container->flags & WINED3D_TEXTURE_DISCARD))
+        {
+            surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
+            if (prev_surface == device->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(device->onscreen_depth_stencil->container);
+                device->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->fb.depth_stencil = op->view;
+
+    if (!prev != !op->view)
+    {
+        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+    else if (prev && (prev->format_flags & WINED3DFMT_FLAG_FLOAT)
+            != (op->view->format_flags & WINED3DFMT_FLAG_FLOAT))
+    {
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+
+    device_invalidate_state(device, STATE_FRAMEBUFFER);
+}
+
+void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_depth_stencil_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
+    op->view = view;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+}
+
+void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_set_vertex_declaration *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source *op = data;
+    struct wined3d_stream_state *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.streams[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+    stream->stride = op->stride;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+}
+
+void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+{
+    struct wined3d_cs_set_stream_source *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->stride = stride;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source_freq *op = data;
+    struct wined3d_stream_state *stream;
+
+    stream = &cs->state.streams[op->stream_idx];
+    stream->frequency = op->frequency;
+    stream->flags = op->flags;
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+}
+
+void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+{
+    struct wined3d_cs_set_stream_source_freq *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
+    op->stream_idx = stream_idx;
+    op->frequency = frequency;
+    op->flags = flags;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_output *op = data;
+    struct wined3d_stream_output *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.stream_output[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+}
+
+void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset)
+{
+    struct wined3d_cs_set_stream_output *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_index_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.index_buffer;
+    cs->state.index_buffer = op->buffer;
+    cs->state.index_format = op->format_id;
+    cs->state.index_offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+}
+
+void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        enum wined3d_format_id format_id, unsigned int offset)
+{
+    struct wined3d_cs_set_index_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->buffer = buffer;
+    op->format_id = format_id;
+    op->offset = offset;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_constant_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.cb[op->type][op->cb_idx];
+    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+}
+
+void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT cb_idx, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_set_constant_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
+    op->type = type;
+    op->cb_idx = cb_idx;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+    const struct wined3d_cs_set_texture *op = data;
+    struct wined3d_texture *prev;
+    BOOL old_use_color_key = FALSE, new_use_color_key = FALSE;
+
+    prev = cs->state.textures[op->stage];
+    cs->state.textures[op->stage] = op->texture;
+
+    if (op->texture)
+    {
+        const struct wined3d_format *new_format = op->texture->resource.format;
+        const struct wined3d_format *old_format = prev ? prev->resource.format : NULL;
+        unsigned int old_fmt_flags = prev ? prev->resource.format_flags : 0;
+        unsigned int new_fmt_flags = op->texture->resource.format_flags;
+
+        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
+            op->texture->sampler = op->stage;
+
+        if (!prev || op->texture->target != prev->target
+                || (!is_same_fixup(new_format->color_fixup, old_format->color_fixup)
+                && !(can_use_texture_swizzle(gl_info, new_format) && can_use_texture_swizzle(gl_info, old_format)))
+                || (new_fmt_flags & WINED3DFMT_FLAG_SHADOW) != (old_fmt_flags & WINED3DFMT_FLAG_SHADOW))
+            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+
+        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            /* The source arguments for color and alpha ops have different
+             * meanings when a NULL texture is bound, so the COLOR_OP and
+             * ALPHA_OP have to be dirtified. */
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+
+        if (!op->stage && op->texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+            new_use_color_key = TRUE;
+    }
+
+    if (prev)
+    {
+        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
+        {
+            unsigned int i;
+
+            /* Search for other stages the texture is bound to. Shouldn't
+             * happen if applications bind textures to a single stage only. */
+            TRACE("Searching for other stages the texture is bound to.\n");
+            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
+            {
+                if (cs->state.textures[i] == prev)
+                {
+                    TRACE("Texture is also bound to stage %u.\n", i);
+                    prev->sampler = i;
+                    break;
+                }
+            }
+        }
+
+        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+
+        if (!op->stage && prev->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+            old_use_color_key = TRUE;
+    }
+
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+
+    if (new_use_color_key != old_use_color_key)
+        device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+
+    if (new_use_color_key)
+        device_invalidate_state(cs->device, STATE_COLOR_KEY);
+}
+
+void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_set_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
+    op->stage = stage;
+    op->texture = texture;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader_resource_view *op = data;
+
+    cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+}
+
+void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT view_idx, struct wined3d_shader_resource_view *view)
+{
+    struct wined3d_cs_set_shader_resource_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
+    op->type = type;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+}
+
+void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT sampler_idx, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_set_sampler *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
+    op->type = type;
+    op->sampler_idx = sampler_idx;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+}
+
+void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_set_shader *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER;
+    op->type = type;
+    op->shader = shader;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+}
+
+void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+{
+    struct wined3d_cs_set_render_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+}
+
+void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
+        enum wined3d_texture_stage_state state, DWORD value)
+{
+    struct wined3d_cs_set_texture_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
+    op->stage = stage;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+}
+
+void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
+        enum wined3d_sampler_state state, DWORD value)
+{
+    struct wined3d_cs_set_sampler_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
+    op->sampler_idx = sampler_idx;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->d3d_info.limits.ffp_vertex_blend_matrices))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+}
+
+void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
+        const struct wined3d_matrix *matrix)
+{
+    struct wined3d_cs_set_transform *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
+    op->state = state;
+    op->matrix = *matrix;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+}
+
+void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+{
+    struct wined3d_cs_set_clip_plane *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
+    op->plane_idx = plane_idx;
+    op->plane = *plane;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_color_key *op = data;
+    struct wined3d_texture *texture = op->texture;
+
+    if (op->set)
+    {
+        switch (op->flags)
+        {
+            case WINED3D_CKEY_DST_BLT:
+                texture->async.dst_blt_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_DST_BLT;
+                break;
+
+            case WINED3D_CKEY_DST_OVERLAY:
+                texture->async.dst_overlay_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_DST_OVERLAY;
+                break;
+
+            case WINED3D_CKEY_SRC_BLT:
+                if (texture == cs->state.textures[0])
+                {
+                    device_invalidate_state(cs->device, STATE_COLOR_KEY);
+                    if (!(texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT))
+                        device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+                }
+
+                texture->async.src_blt_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_SRC_BLT;
+                break;
+
+            case WINED3D_CKEY_SRC_OVERLAY:
+                texture->async.src_overlay_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_SRC_OVERLAY;
+                break;
+        }
+    }
+    else
+    {
+        switch (op->flags)
+        {
+            case WINED3D_CKEY_DST_BLT:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_DST_BLT;
+                break;
+
+            case WINED3D_CKEY_DST_OVERLAY:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_DST_OVERLAY;
+                break;
+
+            case WINED3D_CKEY_SRC_BLT:
+                if (texture == cs->state.textures[0] && texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+                    device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+
+                texture->async.color_key_flags &= ~WINED3D_CKEY_SRC_BLT;
+                break;
+
+            case WINED3D_CKEY_SRC_OVERLAY:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_SRC_OVERLAY;
+                break;
+        }
+    }
+}
+
+void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        WORD flags, const struct wined3d_color_key *color_key)
+{
+    struct wined3d_cs_set_color_key *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_COLOR_KEY;
+    op->texture = texture;
+    op->flags = flags;
+    if (color_key)
+    {
+        op->color_key = *color_key;
+        op->set = 1;
+    }
+    else
+        op->set = 0;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+}
+
+void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+{
+    struct wined3d_cs_set_material *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+
+    state_cleanup(&cs->state);
+    memset(&cs->state, 0, sizeof(cs->state));
+    state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+}
+
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_reset_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit(cs);
+}
+
+static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+#endif /* STAGING_CSMT */
+    /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
+    /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
+    /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
+    /* WINED3D_CS_OP_SET_PREDICATION            */ wined3d_cs_exec_set_predication,
+    /* WINED3D_CS_OP_SET_VIEWPORT               */ wined3d_cs_exec_set_viewport,
+    /* WINED3D_CS_OP_SET_SCISSOR_RECT           */ wined3d_cs_exec_set_scissor_rect,
+    /* WINED3D_CS_OP_SET_RENDERTARGET_VIEW      */ wined3d_cs_exec_set_rendertarget_view,
+    /* WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW     */ wined3d_cs_exec_set_depth_stencil_view,
+    /* WINED3D_CS_OP_SET_VERTEX_DECLARATION     */ wined3d_cs_exec_set_vertex_declaration,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE          */ wined3d_cs_exec_set_stream_source,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ     */ wined3d_cs_exec_set_stream_source_freq,
+    /* WINED3D_CS_OP_SET_STREAM_OUTPUT          */ wined3d_cs_exec_set_stream_output,
+    /* WINED3D_CS_OP_SET_INDEX_BUFFER           */ wined3d_cs_exec_set_index_buffer,
+    /* WINED3D_CS_OP_SET_CONSTANT_BUFFER        */ wined3d_cs_exec_set_constant_buffer,
+    /* WINED3D_CS_OP_SET_TEXTURE                */ wined3d_cs_exec_set_texture,
+    /* WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW   */ wined3d_cs_exec_set_shader_resource_view,
+    /* WINED3D_CS_OP_SET_SAMPLER                */ wined3d_cs_exec_set_sampler,
+    /* WINED3D_CS_OP_SET_SHADER                 */ wined3d_cs_exec_set_shader,
+    /* WINED3D_CS_OP_SET_RENDER_STATE           */ wined3d_cs_exec_set_render_state,
+    /* WINED3D_CS_OP_SET_TEXTURE_STATE          */ wined3d_cs_exec_set_texture_state,
+    /* WINED3D_CS_OP_SET_SAMPLER_STATE          */ wined3d_cs_exec_set_sampler_state,
+    /* WINED3D_CS_OP_SET_TRANSFORM              */ wined3d_cs_exec_set_transform,
+    /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
+    /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
+    /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
+    /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
+#if defined(STAGING_CSMT)
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F            */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B            */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I            */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F            */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B            */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I            */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX      */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_TEXTURE_CHANGED            */ wined3d_cs_exec_texture_changed,
+    /* WINED3D_CS_OP_TEXTURE_MAP                */ wined3d_cs_exec_texture_map,
+    /* WINED3D_CS_OP_TEXTURE_UNMAP              */ wined3d_cs_exec_texture_unmap,
+    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD             */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_QUERY_DESTROY              */ wined3d_cs_exec_query_destroy,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD            */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE             */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
+    /* WINED3D_CS_OP_VIEW_DESTROY               */ wined3d_cs_exec_view_destroy,
+    /* WINED3D_CS_OP_VDECL_DESTROY              */ wined3d_cs_exec_vertex_declaration_destroy,
+    /* WINED3D_CS_OP_SHADER_CLEANUP             */ wined3d_cs_exec_shader_cleanup,
+    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_RESOURCE_CLEANUP           */ wined3d_cs_exec_resource_cleanup,
+    /* WINED3D_CS_OP_BUFFER_CLEANUP             */ wined3d_cs_exec_buffer_cleanup,
+    /* WINED3D_CS_OP_TEXTURE_CLEANUP            */ wined3d_cs_exec_texture_cleanup,
+    /* WINED3D_CS_OP_SAMPLER_DESTROY            */ wined3d_cs_exec_sampler_destroy,
+    /* WINED3D_CS_OP_SAMPLER_INIT               */ wined3d_cs_exec_sampler_init,
+    /* WINED3D_CS_OP_SRV_DESTROY                */ wined3d_cs_exec_shader_resource_view_destroy,
+    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
+    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
+};
+
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (cs->thread_id == GetCurrentThreadId())
+        ERR("Attempting to queue a command from the CS thread.\n");
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
+    }
+
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
+}
+
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
+{
+}
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
 };
 
 void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
@@ -3207,5 +3990,120 @@
             ERR("Closing event failed.\n");
     }
 
+#else  /* STAGING_CSMT */
+};
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    if (size > cs->data_size)
+    {
+        void *new_data;
+
+        size = max( size, cs->data_size * 2 );
+        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
+            return NULL;
+
+        cs->data_size = size;
+        cs->data = new_data;
+    }
+
+    return cs->data;
+}
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+
+    wined3d_cs_op_handlers[opcode](cs, cs->data);
+}
+
+static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_device *device = cs->device;
+    unsigned int context_count;
+    unsigned int i;
+    size_t offset;
+
+    static const struct
+    {
+        size_t offset;
+        size_t size;
+        DWORD mask;
+    }
+    push_constant_info[] =
+    {
+        /* WINED3D_PUSH_CONSTANTS_VS_F */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
+        /* WINED3D_PUSH_CONSTANTS_PS_F */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
+        /* WINED3D_PUSH_CONSTANTS_VS_I */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
+        /* WINED3D_PUSH_CONSTANTS_PS_I */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
+        /* WINED3D_PUSH_CONSTANTS_VS_B */
+        {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
+        /* WINED3D_PUSH_CONSTANTS_PS_B */
+        {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
+    };
+
+    if (p == WINED3D_PUSH_CONSTANTS_VS_F)
+        device->shader_backend->shader_update_float_vertex_constants(device, start_idx, count);
+    else if (p == WINED3D_PUSH_CONSTANTS_PS_F)
+        device->shader_backend->shader_update_float_pixel_constants(device, start_idx, count);
+
+    offset = push_constant_info[p].offset + start_idx * push_constant_info[p].size;
+    memcpy((BYTE *)&cs->state + offset, constants, count * push_constant_info[p].size);
+    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= push_constant_info[p].mask;
+    }
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_push_constants,
+};
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_cs *cs;
+
+    if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
+        return NULL;
+
+    if (!(cs->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*cs->fb.render_targets))))
+    {
+        HeapFree(GetProcessHeap(), 0, cs);
+        return NULL;
+    }
+
+    state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+
+    cs->ops = &wined3d_cs_st_ops;
+    cs->device = device;
+
+    cs->data_size = WINED3D_INITIAL_CS_SIZE;
+    if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+    {
+        state_cleanup(&cs->state);
+        HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+        HeapFree(GetProcessHeap(), 0, cs);
+        return NULL;
+    }
+
+    return cs;
+}
+
+void wined3d_cs_destroy(struct wined3d_cs *cs)
+{
+    state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+    HeapFree(GetProcessHeap(), 0, cs->data);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -198,6 +198,24 @@
     device->contexts = new_array;
 }
 
+#if !defined(STAGING_CSMT)
+void device_switch_onscreen_ds(struct wined3d_device *device,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (device->onscreen_depth_stencil)
+    {
+        surface_load_location(device->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(device->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                device->onscreen_depth_stencil->ds_current_size.cx,
+                device->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_texture_decref(device->onscreen_depth_stencil->container);
+    }
+    device->onscreen_depth_stencil = depth_stencil;
+    wined3d_texture_incref(device->onscreen_depth_stencil->container);
+}
+
+#endif /* STAGING_CSMT */
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     unsigned int height = wined3d_texture_get_level_height(target->container, target->texture_level);
@@ -267,7 +285,11 @@
     }
 
     /* Full load. */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#else  /* STAGING_CSMT */
+    surface_load_location(ds, context, location);
+#endif /* STAGING_CSMT */
     SetRect(out_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
 }
 
@@ -278,6 +300,9 @@
     struct wined3d_surface *target = rt_count ? wined3d_rendertarget_view_get_surface(fb->render_targets[0]) : NULL;
     struct wined3d_rendertarget_view *dsv = fb->depth_stencil;
     struct wined3d_surface *depth_stencil = dsv ? wined3d_rendertarget_view_get_surface(dsv) : NULL;
+#if !defined(STAGING_CSMT)
+    const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     UINT drawable_width, drawable_height;
     struct wined3d_color corrected_color;
@@ -307,6 +332,7 @@
     for (i = 0; i < rt_count; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if defined(STAGING_CSMT)
 
         if (rtv && rtv->format->id != WINED3DFMT_NULL)
         {
@@ -316,6 +342,16 @@
                 wined3d_texture_load_location(rt, rtv->sub_resource_idx, context, rtv->resource->draw_binding);
             else
                 wined3d_texture_prepare_location(rt, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+        struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(rtv);
+
+        if (rt && rtv->format->id != WINED3DFMT_NULL)
+        {
+            if (flags & WINED3DCLEAR_TARGET && !is_full_clear(target, draw_rect, rect_count ? clear_rect : NULL))
+                surface_load_location(rt, context, rtv->resource->draw_binding);
+            else
+                wined3d_texture_prepare_location(rt->container, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
         }
     }
@@ -342,6 +378,7 @@
     {
         DWORD location = render_offscreen ? dsv->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
+#if defined(STAGING_CSMT)
         if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
             wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
         prepare_ds_clear(depth_stencil, context, location,
@@ -349,6 +386,15 @@
     }
 
     if (!context_apply_clear_state(context, rt_count, fb))
+#else  /* STAGING_CSMT */
+        if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
+            device_switch_onscreen_ds(device, context, depth_stencil);
+        prepare_ds_clear(depth_stencil, context, location,
+                draw_rect, rect_count, clear_rect, &ds_rect);
+    }
+
+    if (!context_apply_clear_state(context, state, rt_count, fb))
+#endif /* STAGING_CSMT */
     {
         context_release(context);
         WARN("Failed to apply clear state, skipping clear.\n");
@@ -404,7 +450,11 @@
             wined3d_texture_invalidate_location(texture, rtv->sub_resource_idx, ~rtv->resource->draw_binding);
         }
 
+#if defined(STAGING_CSMT)
         if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, &device->cs->state, fb))
+#else  /* STAGING_CSMT */
+        if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, fb))
+#endif /* STAGING_CSMT */
         {
             if (rt_count > 1)
                 WARN("Clearing multiple sRGB render targets with no GL_ARB_framebuffer_sRGB "
@@ -664,6 +714,7 @@
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
 static void create_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -698,6 +749,9 @@
 
 /* Context activation is done by the caller. */
 void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -789,8 +843,10 @@
             checkGLcall("glTexImage3D");
         }
     }
+#if defined(STAGING_CSMT)
 
     create_default_samplers(device);
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -833,6 +889,41 @@
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
+static void create_default_samplers(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+
+    if (gl_info->supported[ARB_SAMPLER_OBJECTS])
+    {
+        /* In SM4+ shaders there is a separation between resources and samplers. Some shader
+         * instructions allow access to resources without using samplers.
+         * In GLSL, resources are always accessed through sampler or image variables. The default
+         * sampler object is used to emulate the direct resource access when there is no sampler state
+         * to use.
+         */
+        GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST));
+        checkGLcall("Create default sampler");
+
+        /* In D3D10+, a NULL sampler maps to the default sampler state. */
+        GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
+        checkGLcall("Create null sampler");
+    }
+    else
+    {
+        device->default_sampler = 0;
+        device->null_sampler = 0;
+    }
+}
+
+/* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void destroy_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -969,7 +1060,11 @@
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
+#if defined(STAGING_CSMT)
     if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
+    if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -987,7 +1082,13 @@
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
+#if defined(STAGING_CSMT)
+    struct wined3d_swapchain *swapchain = NULL;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -998,6 +1099,11 @@
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
+    if (!(device->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*device->fb.render_targets))))
+        return E_OUTOFMEMORY;
+
+#endif /* STAGING_CSMT */
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -1045,11 +1151,24 @@
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
+#else  /* STAGING_CSMT */
+    context = context_acquire(device, swapchain->front_buffer->sub_resources[0].u.surface);
+
+    create_dummy_textures(device, context);
+    create_default_samplers(device);
+
+    device->contexts[0]->last_was_rhw = 0;
+
+    TRACE("All defaults now set up, leaving 3D init.\n");
+
+    context_release(context);
+#endif /* STAGING_CSMT */
 
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
@@ -1066,6 +1185,9 @@
     return WINED3D_OK;
 
 err_out:
+#if !defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1122,6 +1244,10 @@
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
+#if !defined(STAGING_CSMT)
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1130,6 +1256,7 @@
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         device->cs->ops->finish(device->cs);
 
@@ -1170,6 +1297,82 @@
     /* FIXME: Is this in the right place??? */
     wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
 
+#else  /* STAGING_CSMT */
+    /* I don't think that the interface guarantees that the device is destroyed from the same thread
+     * it was created. Thus make sure a context is active for the glDelete* calls
+     */
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    if (device->logo_texture)
+        wined3d_texture_decref(device->logo_texture);
+    if (device->cursor_texture)
+        wined3d_texture_decref(device->cursor_texture);
+
+    state_unbind_resources(&device->state);
+
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        resource->resource_ops->resource_unload(resource);
+    }
+
+    wine_rb_clear(&device->samplers, device_free_sampler, NULL);
+
+    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
+     * private data, it might contain opengl pointers
+     */
+    if (device->depth_blt_texture)
+    {
+        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
+        device->depth_blt_texture = 0;
+    }
+
+    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
+    device->blitter->free_private(device);
+    device->shader_backend->shader_free_private(device);
+    destroy_dummy_textures(device, gl_info);
+    destroy_default_samplers(device);
+
+    /* Release the context again as soon as possible. In particular,
+     * releasing the render target views below may release the last reference
+     * to the swapchain associated with this context, which in turn will
+     * destroy the context. */
+    context_release(context);
+
+    /* Release the buffers (with sanity checks)*/
+    if (device->onscreen_depth_stencil)
+    {
+        surface = device->onscreen_depth_stencil;
+        device->onscreen_depth_stencil = NULL;
+        wined3d_texture_decref(surface->container);
+    }
+
+    if (device->fb.depth_stencil)
+    {
+        struct wined3d_rendertarget_view *view = device->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil view %p.\n", view);
+
+        device->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (device->auto_depth_stencil_view)
+    {
+        struct wined3d_rendertarget_view *view = device->auto_depth_stencil_view;
+
+        device->auto_depth_stencil_view = NULL;
+        if (wined3d_rendertarget_view_decref(view))
+            ERR("Something's still holding the auto depth/stencil view (%p).\n", view);
+    }
+
+    for (i = 0; i < gl_info->limits.buffers; ++i)
+    {
+        wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
+    }
+#endif /* STAGING_CSMT */
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
@@ -1187,6 +1390,11 @@
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
+#if !defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+    device->fb.render_targets = NULL;
+
+#endif /* STAGING_CSMT */
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1231,7 +1439,11 @@
 
     /* We can not acquire the context unless there is a swapchain. */
     if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+#if defined(STAGING_CSMT)
             !wined3d_settings.emulated_textureram && !wined3d_settings.cs_multithreaded)
+#else  /* STAGING_CSMT */
+            !wined3d_settings.emulated_textureram)
+#endif /* STAGING_CSMT */
     {
         GLint vram_free_kb;
         UINT64 vram_free;
@@ -1572,6 +1784,16 @@
             light->direction.x, light->direction.y, light->direction.z,
             light->range, light->falloff, light->theta, light->phi);
 
+#if !defined(STAGING_CSMT)
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1 && !device->recording)
+    {
+        if (object->OriginalParms.type != light->type)
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+#endif /* STAGING_CSMT */
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1651,9 +1873,11 @@
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+#if defined(STAGING_CSMT)
     if (!device->recording)
         wined3d_cs_emit_set_light(device->cs, object);
 
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1726,6 +1950,14 @@
     {
         if (light_info->glIndex != -1)
         {
+#if !defined(STAGING_CSMT)
+            if (!device->recording)
+            {
+                device_invalidate_state(device, STATE_LIGHT_TYPE);
+                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            }
+
+#endif /* STAGING_CSMT */
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1767,11 +1999,23 @@
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
+#if defined(STAGING_CSMT)
         }
     }
 
     if (!device->recording)
         wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+#else  /* STAGING_CSMT */
+
+            /* i == light_info->glIndex */
+            if (!device->recording)
+            {
+                device_invalidate_state(device, STATE_LIGHT_TYPE);
+                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+            }
+        }
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -1943,9 +2187,11 @@
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+#if defined(STAGING_CSMT)
 
     if (!device->recording)
         wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
+#endif /* STAGING_CSMT */
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1991,7 +2237,11 @@
             || !(dst_texture->resource.format_flags & WINED3DFMT_FLAG_DEPTH))
         return;
 
+#if defined(STAGING_CSMT)
     if (!(src_view = state->fb.depth_stencil))
+#else  /* STAGING_CSMT */
+    if (!(src_view = state->fb->depth_stencil))
+#endif /* STAGING_CSMT */
         return;
     if (src_view->resource->type == WINED3D_RTYPE_BUFFER)
     {
@@ -2326,6 +2576,7 @@
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
+#if defined(STAGING_CSMT)
 void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
 {
     UINT i;
@@ -2336,6 +2587,7 @@
     }
 }
 
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
         unsigned int start_idx, unsigned int count, const BOOL *constants)
 {
@@ -2363,8 +2615,12 @@
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2413,8 +2669,12 @@
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2459,8 +2719,12 @@
         memset(&device->recording->changed.vs_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.vs_consts_f));
     else
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
                 WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2599,8 +2863,12 @@
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2649,8 +2917,12 @@
     }
     else
     {
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
                 constants, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2696,8 +2968,12 @@
         memset(&device->recording->changed.ps_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.ps_consts_f));
     else
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
                 WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
+        wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2857,6 +3133,7 @@
         return hr;
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
     {
         FIXME("Waiting for cs.\n");
@@ -2864,6 +3141,7 @@
         device->cs->ops->finish(device->cs);
     }
 
+#endif /* STAGING_CSMT */
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3349,6 +3627,10 @@
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
+    struct wined3d_context *context;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3357,6 +3639,15 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
+    context = context_acquire(device, NULL);
+    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
+    context->gl_info->gl_ops.gl.p_glFlush();
+    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
+     * fails. */
+    context_release(context);
+
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3364,8 +3655,10 @@
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &device->state.fb;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, debug_color(color), depth, stencil);
 
@@ -3377,7 +3670,11 @@
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
+#if defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *ds = fb->depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3386,8 +3683,13 @@
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
+#if defined(STAGING_CSMT)
             if (ds->width < fb->render_targets[0]->width
                     || ds->height < fb->render_targets[0]->height)
+#else  /* STAGING_CSMT */
+            if (ds->width < device->fb.render_targets[0]->width
+                    || ds->height < device->fb.render_targets[0]->height)
+#endif /* STAGING_CSMT */
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3433,6 +3735,9 @@
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
+#if !defined(STAGING_CSMT)
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3440,8 +3745,13 @@
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
+#if defined(STAGING_CSMT)
     else if (gl_primitive_type != prev)
         wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
+    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
+        device_invalidate_state(device, STATE_POINT_ENABLE);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3458,6 +3768,14 @@
 {
     TRACE("device %p, start_vertex %u, vertex_count %u.\n", device, start_vertex, vertex_count);
 
+#if !defined(STAGING_CSMT)
+    if (device->state.load_base_vertex_index)
+    {
+        device->state.load_base_vertex_index = 0;
+        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
+    }
+
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_draw(device->cs, start_vertex, vertex_count, 0, 0, FALSE);
 
     return WINED3D_OK;
@@ -3474,6 +3792,10 @@
 
 HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count)
 {
+#if !defined(STAGING_CSMT)
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, start_idx %u, index_count %u.\n", device, start_idx, index_count);
 
     if (!device->state.index_buffer)
@@ -3486,6 +3808,15 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
+    if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX] &&
+            device->state.load_base_vertex_index != device->state.base_vertex_index)
+    {
+        device->state.load_base_vertex_index = device->state.base_vertex_index;
+        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
+    }
+
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, 0, 0, TRUE);
 
     return WINED3D_OK;
@@ -3500,6 +3831,7 @@
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
 static void wined3d_device_update_texture_3d(struct wined3d_context *context,
         struct wined3d_texture *src_texture, unsigned int src_level,
@@ -3510,6 +3842,36 @@
 
     TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
             context, src_texture, src_level, dst_texture, level_count);
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, unsigned int src_level,
+        struct wined3d_texture *dst_texture, unsigned int level_count)
+{
+    struct wined3d_const_bo_address data;
+    struct wined3d_context *context;
+    struct wined3d_map_desc src;
+    HRESULT hr = WINED3D_OK;
+    unsigned int i;
+
+    TRACE("device %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            device, src_texture, src_level, dst_texture, level_count);
+
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (wined3d_texture_get_level_width(src_texture, src_level) != dst_texture->resource.width
+            || wined3d_texture_get_level_height(src_texture, src_level) != dst_texture->resource.height
+            || wined3d_texture_get_level_depth(src_texture, src_level) != dst_texture->resource.depth)
+    {
+        WARN("Source and destination dimensions do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    context = context_acquire(device, NULL);
+#endif /* STAGING_CSMT */
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3517,6 +3879,7 @@
 
     for (i = 0; i < level_count; ++i)
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_get_memory(src_texture, src_level + i, &data,
                 src_texture->resource.map_binding, FALSE);
 
@@ -3594,6 +3957,34 @@
     unsigned int src_size, dst_size, src_skip_levels = 0;
     unsigned int layer_count;
     enum wined3d_resource_type type;
+#else  /* STAGING_CSMT */
+        if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
+                src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
+            goto done;
+
+        data.buffer_object = 0;
+        data.addr = src.data;
+        wined3d_volume_upload_data(dst_texture, i, context, &data);
+        wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
+
+        if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            goto done;
+    }
+
+done:
+    context_release(context);
+    return hr;
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int layer_count, level_count, i, j;
+    enum wined3d_resource_type type;
+    HRESULT hr;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3630,6 +4021,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
      * rejects mismatching formats, and we can't report the error back after dispatching the
      * call. */
@@ -3672,6 +4064,65 @@
     wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    context = context_acquire(device, NULL);
+    wined3d_texture_load(dst_texture, context, FALSE);
+    context_release(context);
+
+    /* Update every surface level of the texture. */
+    switch (type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return hr;
+                    }
+                }
+            }
+            return WINED3D_OK;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            if (FAILED(hr = wined3d_device_update_texture_3d(device,
+                    src_texture, src_skip_levels, dst_texture, level_count)))
+                WARN("Failed to update 3D texture, hr %#x.\n", hr);
+            return hr;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", type);
+            return WINED3DERR_INVALIDCALL;
+    }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3719,8 +4170,13 @@
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
+#if defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
         struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -3909,7 +4365,9 @@
     struct wined3d_texture *dst_texture, *src_texture;
     RECT dst_rect, src_rect;
     HRESULT hr;
+#if defined(STAGING_CSMT)
     struct wined3d_box dst_box;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, dst_resource %p, dst_sub_resource_idx %u, dst_x %u, dst_y %u, dst_z %u, "
             "src_resource %p, src_sub_resource_idx %u, src_box %s.\n",
@@ -3997,6 +4455,7 @@
 
     if (src_box)
     {
+#if defined(STAGING_CSMT)
         if ((src_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
                 && !wined3d_texture_check_block_align(src_texture,
                 src_sub_resource_idx % src_texture->level_count, src_box))
@@ -4005,6 +4464,7 @@
             return WINED3DERR_INVALIDCALL;
         }
 
+#endif /* STAGING_CSMT */
         SetRect(&src_rect, src_box->left, src_box->top, src_box->right, src_box->bottom);
     }
     else
@@ -4018,6 +4478,7 @@
     SetRect(&dst_rect, dst_x, dst_y, dst_x + (src_rect.right - src_rect.left),
             dst_y + (src_rect.bottom - src_rect.top));
 
+#if defined(STAGING_CSMT)
     if (dst_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
     {
         dst_box.left = dst_rect.left;
@@ -4035,6 +4496,7 @@
         }
     }
 
+#endif /* STAGING_CSMT */
     if (FAILED(hr = wined3d_texture_blt(dst_texture, dst_sub_resource_idx, &dst_rect,
             src_texture, src_sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_POINT)))
         WARN("Failed to blit, hr %#x.\n", hr);
@@ -4047,7 +4509,18 @@
         unsigned int depth_pitch)
 {
     struct wined3d_texture_sub_resource *sub_resource;
+#if defined(STAGING_CSMT)
     struct wined3d_texture *texture;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_const_bo_address addr;
+    unsigned int width, height, level;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture;
+    struct wined3d_surface *surface;
+    POINT dst_point;
+    RECT src_rect;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, resource %p, sub_resource_idx %u, box %s, data %p, row_pitch %u, depth_pitch %u.\n",
             device, resource, sub_resource_idx, debug_box(box), data, row_pitch, depth_pitch);
@@ -4081,6 +4554,7 @@
         WARN("Invalid sub_resource_idx %u.\n", sub_resource_idx);
         return;
     }
+#if defined(STAGING_CSMT)
 
     if (box)
     {
@@ -4090,6 +4564,18 @@
         width = wined3d_texture_get_level_width(texture, level);
         height = wined3d_texture_get_level_height(texture, level);
 
+#else  /* STAGING_CSMT */
+    surface = sub_resource->u.surface;
+
+    level = sub_resource_idx % texture->level_count;
+    width = wined3d_texture_get_level_width(texture, level);
+    height = wined3d_texture_get_level_height(texture, level);
+
+    src_rect.left = 0;
+    src_rect.top = 0;
+    if (box)
+    {
+#endif /* STAGING_CSMT */
         if (box->left >= box->right || box->right > width
                 || box->top >= box->bottom || box->bottom > height
                 || box->front >= box->back)
@@ -4097,9 +4583,46 @@
             WARN("Invalid box %s specified.\n", debug_box(box));
             return;
         }
+#if defined(STAGING_CSMT)
     }
 
     wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
+#else  /* STAGING_CSMT */
+
+        src_rect.right = box->right - box->left;
+        src_rect.bottom = box->bottom - box->top;
+        dst_point.x = box->left;
+        dst_point.y = box->top;
+    }
+    else
+    {
+        src_rect.right = width;
+        src_rect.bottom = height;
+        dst_point.x = 0;
+        dst_point.y = 0;
+    }
+
+    addr.buffer_object = 0;
+    addr.addr = data;
+
+    context = context_acquire(resource->device, NULL);
+    gl_info = context->gl_info;
+
+    /* Only load the surface for partial updates. */
+    if (!dst_point.x && !dst_point.y && src_rect.right == width && src_rect.bottom == height)
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+    else
+        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
+
+    wined3d_surface_upload_data(surface, gl_info, resource->format,
+            &src_rect, row_pitch, &dst_point, FALSE, &addr);
+
+    context_release(context);
+
+    wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -4108,8 +4631,13 @@
 {
     const struct blit_shader *blitter;
     struct wined3d_resource *resource;
+#if defined(STAGING_CSMT)
     RECT r;
     enum wined3d_blit_op blit_op;
+#else  /* STAGING_CSMT */
+    enum wined3d_blit_op blit_op;
+    RECT r;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view %p, rect %s, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, view, wine_dbgstr_rect(rect), flags, debug_color(color), depth, stencil);
@@ -4148,8 +4676,15 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
+        return blitter->color_fill(device, view, rect, color);
+    else
+        return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4163,6 +4698,7 @@
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
     return device->state.fb.render_targets[view_idx];
 }
 
@@ -4178,6 +4714,22 @@
 {
     struct wined3d_rendertarget_view *prev;
     struct wined3d_fb_state *fb = &device->state.fb;
+#else  /* STAGING_CSMT */
+    return device->fb.render_targets[view_idx];
+}
+
+struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
+{
+    TRACE("device %p.\n", device);
+
+    return device->fb.depth_stencil;
+}
+
+HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
+        unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
+{
+    struct wined3d_rendertarget_view *prev;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -4217,6 +4769,7 @@
     }
 
 
+#if defined(STAGING_CSMT)
     prev = fb->render_targets[view_idx];
     if (view == prev)
         return WINED3D_OK;
@@ -4224,6 +4777,15 @@
     if (view)
         wined3d_rendertarget_view_incref(view);
     fb->render_targets[view_idx] = view;
+#else  /* STAGING_CSMT */
+    prev = device->fb.render_targets[view_idx];
+    if (view == prev)
+        return WINED3D_OK;
+
+    if (view)
+        wined3d_rendertarget_view_incref(view);
+    device->fb.render_targets[view_idx] = view;
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -4235,6 +4797,7 @@
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state *fb = &device->state.fb;
     struct wined3d_rendertarget_view *prev;
 
@@ -4248,6 +4811,20 @@
     }
 
     if ((fb->depth_stencil = view))
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view *prev;
+
+    TRACE("device %p, view %p.\n", device, view);
+
+    prev = device->fb.depth_stencil;
+    if (prev == view)
+    {
+        TRACE("Trying to do a NOP SetRenderTarget operation.\n");
+        return;
+    }
+
+    if ((device->fb.depth_stencil = view))
+#endif /* STAGING_CSMT */
         wined3d_rendertarget_view_incref(view);
     wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
     if (prev)
@@ -4469,8 +5046,10 @@
 
     TRACE("device %p.\n", device);
 
+#if defined(STAGING_CSMT)
     /* The resource list is manged by the main thread, iterate here and emit commands for
      * each resource */
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4478,6 +5057,7 @@
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
+#if defined(STAGING_CSMT)
             wined3d_cs_emit_evict_resource(device->cs, resource);
         }
     }
@@ -4496,6 +5076,36 @@
 
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
+#else  /* STAGING_CSMT */
+            resource->resource_ops->resource_unload(resource);
+        }
+    }
+
+    /* Invalidate stream sources, the buffer(s) may have been evicted. */
+    device_invalidate_state(device, STATE_STREAMSRC);
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_shader *shader;
+
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        resource->resource_ops->resource_unload(resource);
+    }
+
+    LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
+    {
+        device->shader_backend->shader_destroy(shader);
+    }
+#endif /* STAGING_CSMT */
 
     if (device->depth_blt_texture)
     {
@@ -4517,6 +5127,7 @@
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+#if defined(STAGING_CSMT)
     swapchain->num_contexts = 0;
 }
 
@@ -4535,6 +5146,14 @@
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
+#else  /* STAGING_CSMT */
+}
+
+static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_context *context;
+    struct wined3d_texture *target;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4551,6 +5170,7 @@
         return hr;
     }
 
+#if defined(STAGING_CSMT)
     hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
     if (FAILED(hr))
     {
@@ -4561,6 +5181,33 @@
     }
 
     wined3d_cs_emit_create_dummy_textures(device->cs);
+#else  /* STAGING_CSMT */
+    /* Recreate the primary swapchain's context */
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to allocate memory for swapchain context array.\n");
+        device->blitter->free_private(device);
+        device->shader_backend->shader_free_private(device);
+        return E_OUTOFMEMORY;
+    }
+
+    target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
+    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    {
+        WARN("Failed to create context.\n");
+        device->blitter->free_private(device);
+        device->shader_backend->shader_free_private(device);
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        return E_FAIL;
+    }
+
+    swapchain->context[0] = context;
+    swapchain->num_contexts = 1;
+    create_dummy_textures(device, context);
+    create_default_samplers(device);
+    context_release(context);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4580,12 +5227,14 @@
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p, reset_state %#x.\n",
             device, swapchain_desc, mode, callback, reset_state);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
     {
         wined3d_cs_emit_glfinish(device->cs);
         device->cs->ops->finish(device->cs);
     }
 
+#endif /* STAGING_CSMT */
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
@@ -4605,9 +5254,16 @@
             wined3d_texture_decref(device->cursor_texture);
             device->cursor_texture = NULL;
         }
+#if defined(STAGING_CSMT)
     }
 
     if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4616,6 +5272,7 @@
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
+#if defined(STAGING_CSMT)
     if (reset_state)
     {
         state_unbind_resources(&device->state);
@@ -4625,6 +5282,12 @@
     {
         wined3d_texture_decref(device->cs->onscreen_depth_stencil->container);
         device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    if (device->onscreen_depth_stencil)
+    {
+        wined3d_texture_decref(device->onscreen_depth_stencil->container);
+        device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (reset_state)
@@ -4844,6 +5507,7 @@
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
+#if defined(STAGING_CSMT)
         if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -4868,6 +5532,32 @@
         state->scissor_rect.left = 0;
         state->scissor_rect.right = swapchain->desc.backbuffer_width;
         state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
+#else  /* STAGING_CSMT */
+        state_init(&device->state, &device->fb, &device->adapter->gl_info,
+                &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+        device->update_state = &device->state;
+
+        device_init_swapchain_state(device, swapchain);
+    }
+    else if (device->back_buffer_view)
+    {
+        struct wined3d_rendertarget_view *view = device->back_buffer_view;
+        struct wined3d_state *state = &device->state;
+
+        wined3d_device_set_rendertarget_view(device, 0, view, FALSE);
+
+        /* Note the min_z / max_z is not reset. */
+        state->viewport.x = 0;
+        state->viewport.y = 0;
+        state->viewport.width = view->width;
+        state->viewport.height = view->height;
+        wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
+
+        state->scissor_rect.top = 0;
+        state->scissor_rect.left = 0;
+        state->scissor_rect.right = view->width;
+        state->scissor_rect.bottom = view->height;
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4875,7 +5565,11 @@
     {
         if (reset_state)
             hr = create_primary_opengl_context(device, swapchain);
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
+#else  /* STAGING_CSMT */
+        swapchain_update_swap_interval(swapchain);
+#endif /* STAGING_CSMT */
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -4955,6 +5649,7 @@
 
     TRACE("device %p, resource %p, type %s.\n", device, resource, debug_d3dresourcetype(type));
 
+#if defined(STAGING_CSMT)
     for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
     {
         if ((rtv = device->state.fb.render_targets[i]) && rtv->resource == resource)
@@ -4962,6 +5657,17 @@
     }
 
     if ((rtv = device->state.fb.depth_stencil) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+    context_resource_released(device, resource, type);
+
+    for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
+    {
+        if ((rtv = device->fb.render_targets[i]) && rtv->resource == resource)
+            ERR("Resource %p is still in use as render target %u.\n", resource, i);
+    }
+
+    if ((rtv = device->fb.depth_stencil) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
         ERR("Resource %p is still in use as depth/stencil buffer.\n", resource);
 
     switch (type)
@@ -5097,12 +5803,17 @@
 
     device->blitter = adapter->blitter;
 
+#if defined(STAGING_CSMT)
     if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
         goto err;
     }
+#else  /* STAGING_CSMT */
+    state_init(&device->state, &device->fb, &adapter->gl_info,
+            &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#endif /* STAGING_CSMT */
     device->update_state = &device->state;
 
     if (!(device->cs = wined3d_cs_create(device)))
@@ -5196,6 +5907,7 @@
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
 
 /* Context activation is done by the caller */
 struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
@@ -5249,3 +5961,4 @@
 
     wined3d_device_destroy_bo(device, context, bo);
 }
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -411,7 +411,11 @@
         unsigned int start_idx, unsigned int index_count, unsigned int start_instance,
         unsigned int instance_count, BOOL indexed)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -437,6 +441,7 @@
     for (i = 0; i < gl_info->limits.buffers; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if defined(STAGING_CSMT)
 
         if (rtv && rtv->format->id != WINED3DFMT_NULL)
         {
@@ -450,6 +455,21 @@
             else
             {
                 wined3d_texture_prepare_location(target, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+        struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(rtv);
+
+        if (target && rtv->format->id != WINED3DFMT_NULL)
+        {
+            if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
+            {
+                surface_load_location(target, context, rtv->resource->draw_binding);
+                wined3d_texture_invalidate_location(target->container,
+                        rtv->sub_resource_idx, ~rtv->resource->draw_binding);
+            }
+            else
+            {
+                wined3d_texture_prepare_location(target->container, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
             }
         }
@@ -469,8 +489,13 @@
         {
             RECT current_rect, draw_rect, r;
 
+#if defined(STAGING_CSMT)
             if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
                 wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
+#else  /* STAGING_CSMT */
+            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
+                device_switch_onscreen_ds(device, context, ds);
+#endif /* STAGING_CSMT */
 
             if (surface_get_sub_resource(ds)->locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -481,7 +506,11 @@
 
             IntersectRect(&r, &draw_rect, &current_rect);
             if (!EqualRect(&r, &draw_rect))
+#if defined(STAGING_CSMT)
                 wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#else  /* STAGING_CSMT */
+                surface_load_location(ds, context, location);
+#endif /* STAGING_CSMT */
             else
                 wined3d_texture_prepare_location(ds->container, dsv->sub_resource_idx, context, location);
         }
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1470,7 +1470,11 @@
         const struct wined3d_vec4 correction_params =
         {
             /* Position is relative to the framebuffer, not the viewport. */
+#if defined(STAGING_CSMT)
             context->render_offscreen ? 0.0f : (float)state->fb.render_targets[0]->height,
+#else  /* STAGING_CSMT */
+            context->render_offscreen ? 0.0f : (float)state->fb->render_targets[0]->height,
+#endif /* STAGING_CSMT */
             context->render_offscreen ? 1.0f : -1.0f,
             0.0f,
             0.0f,
@@ -1576,11 +1580,13 @@
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
     }
+#endif /* STAGING_CSMT */
 }
 
 static void shader_glsl_update_float_pixel_constants(struct wined3d_device *device, UINT start, UINT count)
@@ -1593,11 +1599,13 @@
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
 
     for (i = 0; i < device->context_count; ++i)
     {
         device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
     }
+#endif /* STAGING_CSMT */
 }
 
 static unsigned int vec4_varyings(DWORD shader_major, const struct wined3d_gl_info *gl_info)
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -233,6 +233,7 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_query_destroy(struct wined3d_query *query)
 {
     /* Queries are specific to the GL context that created them. Not
@@ -263,6 +264,7 @@
     HeapFree(GetProcessHeap(), 0, query);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 {
     ULONG refcount = InterlockedDecrement(&query->ref);
@@ -270,7 +272,38 @@
     TRACE("%p decreasing refcount to %u.\n", query, refcount);
 
     if (!refcount)
+#if defined(STAGING_CSMT)
         wined3d_cs_emit_query_destroy(query->device->cs, query);
+#else  /* STAGING_CSMT */
+    {
+        /* Queries are specific to the GL context that created them. Not
+         * deleting the query will obviously leak it, but that's still better
+         * than potentially deleting a different query with the same id in this
+         * context, and (still) leaking the actual query. */
+        if (query->type == WINED3D_QUERY_TYPE_EVENT)
+        {
+            struct wined3d_event_query *event_query = query->extendedData;
+            if (event_query) wined3d_event_query_destroy(event_query);
+        }
+        else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
+        {
+            struct wined3d_occlusion_query *oq = query->extendedData;
+
+            if (oq->context) context_free_occlusion_query(oq);
+            HeapFree(GetProcessHeap(), 0, query->extendedData);
+        }
+        else if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP)
+        {
+            struct wined3d_timestamp_query *tq = query->extendedData;
+
+            if (tq->context)
+                context_free_timestamp_query(tq);
+            HeapFree(GetProcessHeap(), 0, query->extendedData);
+        }
+
+        HeapFree(GetProcessHeap(), 0, query);
+    }
+#endif /* STAGING_CSMT */
 
     return refcount;
 }
@@ -295,6 +328,7 @@
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
+#if defined(STAGING_CSMT)
     if (flags & WINED3DISSUE_END)
         query->counter_main++;
 
@@ -306,6 +340,9 @@
         query->state = QUERY_SIGNALLED;
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    return query->query_ops->query_issue(query, flags);
+#endif /* STAGING_CSMT */
 }
 
 static void fill_query_data(void *out, unsigned int out_size, const void *result, unsigned int result_size)
@@ -316,10 +353,25 @@
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_occlusion_query *oq = query->extendedData;
     GLuint samples;
+#else  /* STAGING_CSMT */
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    HRESULT res;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!oq->context)
+        query->state = QUERY_CREATED;
+#endif /* STAGING_CSMT */
 
     if (query->state == QUERY_CREATED)
     {
@@ -330,8 +382,10 @@
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
     TRACE("(%p) : type D3DQUERY_OCCLUSION, data %p, size %#x, flags %#x.\n", query, data, size, flags);
 
+#endif /* STAGING_CSMT */
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -347,6 +401,7 @@
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
     if (!wined3d_settings.cs_multithreaded)
     {
         if (!query->query_ops->query_poll(query))
@@ -378,6 +433,14 @@
         FIXME("%p Wrong thread, returning 1.\n", query);
         oq->samples = 1;
         return TRUE;
+#else  /* STAGING_CSMT */
+    if (oq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        samples = 1;
+        fill_query_data(data, size, &samples, sizeof(samples));
+        return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(oq->context));
@@ -388,6 +451,7 @@
 
     if (available)
     {
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
         checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
         TRACE("Returning %d samples.\n", samples);
@@ -459,6 +523,69 @@
 
     if (data)
         fill_query_data(data, dwSize, &ret, sizeof(ret));
+#else  /* STAGING_CSMT */
+        if (size)
+        {
+            GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
+            checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
+            TRACE("Returning %d samples.\n", samples);
+            fill_query_data(data, size, &samples, sizeof(samples));
+        }
+        res = S_OK;
+    }
+    else
+    {
+        res = S_FALSE;
+    }
+
+    context_release(context);
+
+    return res;
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL signaled;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!data || !size) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        signaled = TRUE;
+        fill_query_data(data, size, &signaled, sizeof(signaled));
+        return S_OK;
+    }
+
+    ret = wined3d_event_query_test(event_query, query->device);
+    switch(ret)
+    {
+        case WINED3D_EVENT_QUERY_OK:
+        case WINED3D_EVENT_QUERY_NOT_STARTED:
+            signaled = TRUE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_WAITING:
+            signaled = FALSE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_WRONG_THREAD:
+            FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
+            signaled = TRUE;
+            fill_query_data(data, size, &signaled, sizeof(signaled));
+            break;
+
+        case WINED3D_EVENT_QUERY_ERROR:
+            ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
+            return WINED3DERR_INVALIDCALL;
+    }
+#endif /* STAGING_CSMT */
 
     return S_OK;
 }
@@ -477,7 +604,11 @@
     return query->type;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -487,6 +618,7 @@
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
+#if defined(STAGING_CSMT)
         if (!event_query) return FALSE;
 
         wined3d_event_query_issue(event_query, query->device);
@@ -505,6 +637,30 @@
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     BOOL poll = FALSE;
+#else  /* STAGING_CSMT */
+        if (!event_query) return WINED3D_OK;
+
+        wined3d_event_query_issue(event_query, query->device);
+    }
+    else if (flags & WINED3DISSUE_BEGIN)
+    {
+        /* Started implicitly at device creation */
+        ERR("Event query issued with START flag - what to do?\n");
+    }
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+}
+
+static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+#endif /* STAGING_CSMT */
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -516,7 +672,11 @@
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
+#if defined(STAGING_CSMT)
             if (oq->started)
+#else  /* STAGING_CSMT */
+            if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -545,7 +705,9 @@
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+#if defined(STAGING_CSMT)
             oq->started = TRUE;
+#endif /* STAGING_CSMT */
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -553,7 +715,11 @@
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
+#if defined(STAGING_CSMT)
             if (oq->started)
+#else  /* STAGING_CSMT */
+            if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -567,10 +733,15 @@
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+#if defined(STAGING_CSMT)
                     poll = TRUE;
                 }
             }
             oq->started = FALSE;
+#else  /* STAGING_CSMT */
+                }
+            }
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -578,6 +749,7 @@
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
+#if defined(STAGING_CSMT)
     return poll;
 }
 
@@ -636,6 +808,47 @@
         FIXME("%p Wrong thread, returning 1.\n", query);
         tq->timestamp = 1;
         return TRUE;
+#else  /* STAGING_CSMT */
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+}
+
+static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    struct wined3d_timestamp_query *tq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint64 timestamp;
+    HRESULT res;
+
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (!tq->context)
+        query->state = QUERY_CREATED;
+
+    if (query->state == QUERY_CREATED)
+    {
+        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves. */
+        TRACE("Query wasn't yet started, returning S_OK.\n");
+        timestamp = 0;
+        fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        return S_OK;
+    }
+
+    if (tq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        timestamp = 1;
+        fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(tq->context));
@@ -646,6 +859,7 @@
 
     if (available)
     {
+#if defined(STAGING_CSMT)
         GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
         checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
         TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
@@ -663,6 +877,28 @@
 }
 
 static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+        if (size)
+        {
+            GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
+            checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
+            TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
+            fill_query_data(data, size, &timestamp, sizeof(timestamp));
+        }
+        res = S_OK;
+    }
+    else
+    {
+        res = S_FALSE;
+    }
+
+    context_release(context);
+
+    return res;
+}
+
+static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -695,6 +931,7 @@
     }
 
     if (flags & WINED3DISSUE_END)
+#if defined(STAGING_CSMT)
         return TRUE;
     return FALSE;
 }
@@ -703,6 +940,18 @@
         void *data, DWORD size, DWORD flags)
 {
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+#else  /* STAGING_CSMT */
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+}
+
+static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+#endif /* STAGING_CSMT */
     if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP_DISJOINT)
     {
         static const struct wined3d_query_data_timestamp_disjoint disjoint_data = {1000 * 1000 * 1000, FALSE};
@@ -724,6 +973,7 @@
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -733,6 +983,18 @@
 {
     TRACE("query %p, flags %#x.\n", query, flags);
     return FALSE;
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    TRACE("query %p, flags %#x.\n", query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    if (flags & WINED3DISSUE_END)
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_statistics_query_ops_get_data(struct wined3d_query *query,
@@ -747,6 +1009,7 @@
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_statistics_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -756,6 +1019,12 @@
 {
     FIXME("query %p, flags %#x.\n", query, flags);
     return FALSE;
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_statistics_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_overflow_query_ops_get_data(struct wined3d_query *query,
@@ -770,6 +1039,7 @@
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
 static BOOL wined3d_overflow_query_ops_poll(struct wined3d_query *query)
 {
     return TRUE;
@@ -820,6 +1090,47 @@
 {
     wined3d_overflow_query_ops_get_data,
     wined3d_overflow_query_ops_poll,
+#else  /* STAGING_CSMT */
+static HRESULT wined3d_overflow_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return WINED3D_OK;
+}
+
+static const struct wined3d_query_ops event_query_ops =
+{
+    wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_issue,
+};
+
+static const struct wined3d_query_ops occlusion_query_ops =
+{
+    wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_query_ops =
+{
+    wined3d_timestamp_query_ops_get_data,
+    wined3d_timestamp_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_disjoint_query_ops =
+{
+    wined3d_timestamp_disjoint_query_ops_get_data,
+    wined3d_timestamp_disjoint_query_ops_issue,
+};
+
+static const struct wined3d_query_ops statistics_query_ops =
+{
+    wined3d_statistics_query_ops_get_data,
+    wined3d_statistics_query_ops_issue,
+};
+
+static const struct wined3d_query_ops overflow_query_ops =
+{
+    wined3d_overflow_query_ops_get_data,
+#endif /* STAGING_CSMT */
     wined3d_overflow_query_ops_issue
 };
 
@@ -841,6 +1152,7 @@
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
+#if defined(STAGING_CSMT)
             query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                     sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
@@ -848,6 +1160,15 @@
                 ERR("Failed to allocate occlusion query extended data.\n");
                 return E_OUTOFMEMORY;
             }
+#else  /* STAGING_CSMT */
+            query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
+            if (!query->extendedData)
+            {
+                ERR("Failed to allocate occlusion query extended data.\n");
+                return E_OUTOFMEMORY;
+            }
+            ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -934,7 +1255,9 @@
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+#if defined(STAGING_CSMT)
     list_init(&query->poll_list_entry);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -213,7 +213,9 @@
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+#if defined(STAGING_CSMT)
         resource->heap_memory = resource->map_heap_memory;
+#endif /* STAGING_CSMT */
     }
     else
     {
@@ -237,6 +239,7 @@
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
 {
     wined3d_resource_free_sysmem(resource);
@@ -244,6 +247,7 @@
     context_resource_released(resource->device, resource, resource->type);
 }
 
+#endif /* STAGING_CSMT */
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -256,8 +260,14 @@
         adapter_adjust_memory(resource->device->adapter, (INT64)0 - resource->size);
     }
 
+#if defined(STAGING_CSMT)
     device_resource_released(resource->device, resource);
     wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
+#else  /* STAGING_CSMT */
+    wined3d_resource_free_sysmem(resource);
+
+    device_resource_released(resource->device, resource);
+#endif /* STAGING_CSMT */
 }
 
 void resource_unload(struct wined3d_resource *resource)
@@ -340,7 +350,11 @@
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
+#if defined(STAGING_CSMT)
     resource->map_heap_memory = ++p;
+#else  /* STAGING_CSMT */
+    resource->heap_memory = ++p;
+#endif /* STAGING_CSMT */
 
     return TRUE;
 }
diff --git a/dlls/wined3d/sampler.c b/dlls/wined3d/sampler.c
--- a/dlls/wined3d/sampler.c
+++ b/dlls/wined3d/sampler.c
@@ -33,6 +33,7 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_sampler_destroy(struct wined3d_sampler *sampler)
 {
     struct wined3d_context *context = context_acquire(sampler->device, NULL);
@@ -54,6 +55,24 @@
     {
         struct wined3d_device *device = sampler->device;
         wined3d_cs_emit_sampler_destroy(device->cs, sampler);
+#else  /* STAGING_CSMT */
+ULONG CDECL wined3d_sampler_decref(struct wined3d_sampler *sampler)
+{
+    ULONG refcount = InterlockedDecrement(&sampler->refcount);
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+
+    TRACE("%p decreasing refcount to %u.\n", sampler, refcount);
+
+    if (!refcount)
+    {
+        context = context_acquire(sampler->device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glDeleteSamplers(1, &sampler->name));
+        context_release(context);
+
+        HeapFree(GetProcessHeap(), 0, sampler);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -66,6 +85,7 @@
     return sampler->parent;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_sampler_init(struct wined3d_sampler *sampler)
 {
     const struct wined3d_gl_info *gl_info;
@@ -97,6 +117,45 @@
             wined3d_gl_compare_func(sampler->desc.comparison_func)));
     if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
             && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !sampler->desc.srgb_decode)
+#else  /* STAGING_CSMT */
+static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d_device *device,
+        const struct wined3d_sampler_desc *desc, void *parent)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+
+    sampler->refcount = 1;
+    sampler->device = device;
+    sampler->parent = parent;
+    sampler->desc = *desc;
+
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenSamplers(1, &sampler->name));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_S,
+            gl_info->wrap_lookup[desc->address_u - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
+            gl_info->wrap_lookup[desc->address_v - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_R,
+            gl_info->wrap_lookup[desc->address_w - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &desc->border_color[0]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAG_FILTER,
+            wined3d_gl_mag_filter(desc->mag_filter)));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MIN_FILTER,
+            wined3d_gl_min_mip_filter(desc->min_filter, desc->mip_filter)));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, desc->lod_bias));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, desc->min_lod));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, desc->max_lod));
+    if (gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC])
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, desc->max_anisotropy));
+    if (desc->compare)
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_FUNC,
+            wined3d_gl_compare_func(desc->comparison_func)));
+    if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
+            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !desc->srgb_decode)
+#endif /* STAGING_CSMT */
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_SRGB_DECODE_EXT, GL_SKIP_DECODE_EXT));
     checkGLcall("sampler creation");
 
@@ -108,12 +167,14 @@
 HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler)
 {
+#if defined(STAGING_CSMT)
     return wined3d_sampler_create_from_cs(device, desc, parent, sampler, FALSE);
 }
 
 HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler, BOOL from_cs)
 {
+#endif /* STAGING_CSMT */
     struct wined3d_sampler *object;
 
     TRACE("device %p, desc %p, parent %p, sampler %p.\n", device, desc, parent, sampler);
@@ -134,6 +195,7 @@
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
+#if defined(STAGING_CSMT)
     object->refcount = 1;
     object->device = device;
     object->parent = parent;
@@ -142,6 +204,9 @@
         wined3d_sampler_init(object);
     else
         wined3d_cs_emit_sampler_init(device->cs, object);
+#else  /* STAGING_CSMT */
+    wined3d_sampler_init(object, device, desc, parent);
+#endif /* STAGING_CSMT */
 
     TRACE("Created sampler %p.\n", object);
     *sampler = object;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -2338,7 +2338,11 @@
     string_buffer_free(&buffer);
 }
 
+#if defined(STAGING_CSMT)
 void shader_cleanup(struct wined3d_shader *shader)
+#else  /* STAGING_CSMT */
+static void shader_cleanup(struct wined3d_shader *shader)
+#endif /* STAGING_CSMT */
 {
     HeapFree(GetProcessHeap(), 0, shader->output_signature.elements);
     HeapFree(GetProcessHeap(), 0, shader->input_signature.elements);
@@ -2606,10 +2610,16 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_device *device = shader->device;
 
         shader->parent_ops->wined3d_object_destroyed(shader->parent);
         wined3d_cs_emit_shader_cleanup(device->cs, shader);
+#else  /* STAGING_CSMT */
+        shader_cleanup(shader);
+        shader->parent_ops->wined3d_object_destroyed(shader->parent);
+        HeapFree(GetProcessHeap(), 0, shader);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -2930,7 +2940,11 @@
     UINT i;
 
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
+#if defined(STAGING_CSMT)
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb))
+#else  /* STAGING_CSMT */
+    if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb))
+#endif /* STAGING_CSMT */
     {
         static unsigned int warned = 0;
 
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -105,7 +105,11 @@
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     /* No z test without depth stencil buffers */
+#if defined(STAGING_CSMT)
     if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -382,6 +386,7 @@
     GLenum srcBlend, dstBlend;
     unsigned int rt_fmt_flags;
 
+#if defined(STAGING_CSMT)
     if (!state->fb.render_targets[0])
     {
         gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
@@ -390,6 +395,16 @@
 
     rt_format = state->fb.render_targets[0]->format;
     rt_fmt_flags = state->fb.render_targets[0]->format_flags;
+#else  /* STAGING_CSMT */
+    if (!state->fb->render_targets[0])
+    {
+        gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+        return;
+    }
+
+    rt_format = state->fb->render_targets[0]->format;
+    rt_fmt_flags = state->fb->render_targets[0]->format_flags;
+#endif /* STAGING_CSMT */
 
     /* According to the red book, GL_LINE_SMOOTH needs GL_BLEND with specific
      * blending parameters to work. */
@@ -823,7 +838,11 @@
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
+#if defined(STAGING_CSMT)
     if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -919,7 +938,11 @@
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -933,7 +956,11 @@
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1671,7 +1698,11 @@
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+#endif /* STAGING_CSMT */
         float scale;
 
         union
@@ -3604,7 +3635,11 @@
             }
             else
             {
+#if defined(STAGING_CSMT)
                 if (FAILED(wined3d_sampler_create_from_cs(device, &desc, NULL, &sampler, TRUE)))
+#else  /* STAGING_CSMT */
+                if (FAILED(wined3d_sampler_create(device, &desc, NULL, &sampler)))
+#endif /* STAGING_CSMT */
                 {
                     ERR("Failed to create sampler.\n");
                     sampler = NULL;
@@ -4580,8 +4615,13 @@
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_rendertarget_view *depth_stencil = state->fb.depth_stencil;
     const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
+    const struct wined3d_rendertarget_view *depth_stencil = state->fb->depth_stencil;
+    const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
     unsigned int width, height;
@@ -4767,7 +4807,11 @@
     }
     else
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
         UINT height;
         UINT width;
 
@@ -4835,7 +4879,11 @@
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
+#if defined(STAGING_CSMT)
     if (needs_srgb_write(context, state, &state->fb))
+#else  /* STAGING_CSMT */
+    if (needs_srgb_write(context, state, state->fb))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
     else
         gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -430,7 +430,9 @@
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -507,6 +509,7 @@
             }
         }
     }
+#if defined(STAGING_CSMT)
 
     if (state->fb.depth_stencil)
     {
@@ -532,6 +535,7 @@
             }
         }
     }
+#endif /* STAGING_CSMT */
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -556,8 +560,10 @@
             HeapFree(GetProcessHeap(), 0, light);
         }
     }
+#if defined(STAGING_CSMT)
 
     HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
+#endif /* STAGING_CSMT */
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1009,8 +1015,13 @@
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
+#if defined(STAGING_CSMT)
         if (gl_primitive_type != prev)
             wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
+        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
+            device_invalidate_state(device, STATE_POINT_ENABLE);
+#endif /* STAGING_CSMT */
     }
 
     if (stateblock->changed.indices)
@@ -1269,6 +1280,7 @@
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+#if defined(STAGING_CSMT)
         state->textures[i] = NULL;
     }
 
@@ -1315,6 +1327,37 @@
 
     if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
         return hr;
+#else  /* STAGING_CSMT */
+    }
+}
+
+void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD flags)
+{
+    unsigned int i;
+
+    state->flags = flags;
+    state->fb = fb;
+
+    for (i = 0; i < LIGHTMAP_SIZE; i++)
+    {
+        list_init(&state->light_map[i]);
+    }
+
+    if (flags & WINED3D_STATE_INIT_DEFAULT)
+        state_init_default(state, gl_info);
+}
+
+static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
+        struct wined3d_device *device, enum wined3d_stateblock_type type)
+{
+    const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+
+    stateblock->ref = 1;
+    stateblock->device = device;
+    state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0);
+#endif /* STAGING_CSMT */
 
     if (type == WINED3D_SBT_RECORDED)
         return WINED3D_OK;
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,11 +36,13 @@
 static const DWORD surface_simple_locations = WINED3D_LOCATION_SYSMEM
         | WINED3D_LOCATION_USER_MEMORY | WINED3D_LOCATION_BUFFER;
 
+#if defined(STAGING_CSMT)
 static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int dst_sub_resource_idx,
         const struct wined3d_box *dst_box, struct wined3d_texture *src_texture, unsigned int src_sub_resource_idx,
         const struct wined3d_box *src_box, DWORD flags, const struct wined3d_blt_fx *fx,
         enum wined3d_texture_filter_type filter);
 
+#endif /* STAGING_CSMT */
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
         unsigned int *width, unsigned int *height)
 {
@@ -324,7 +326,11 @@
         gl_info = context->gl_info;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
     wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
 
     if (context)
@@ -360,7 +366,11 @@
         gl_info = context->gl_info;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
     desc.pMemory = wined3d_texture_map_bo_address(&data, texture->sub_resources[sub_resource_idx].size,
             gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
@@ -455,11 +465,17 @@
 
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
             context, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
         wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
                 context, dst_location);
+#else  /* STAGING_CSMT */
+    surface_load_location(src_surface, context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        surface_load_location(dst_surface, context, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, context, dst_location);
 
@@ -553,11 +569,17 @@
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
             old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
         wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
                                       old_ctx, dst_location);
+#else  /* STAGING_CSMT */
+    surface_load_location(src_surface, old_ctx, src_location);
+    if (!surface_is_full_rect(dst_surface, &dst_rect))
+        surface_load_location(dst_surface, old_ctx, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, old_ctx, dst_location);
 
@@ -628,8 +650,12 @@
             dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, GL_COLOR_BUFFER_BIT, gl_filter);
     checkGLcall("glBlitFramebuffer()");
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering
             || (dst_location == WINED3D_LOCATION_DRAWABLE
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering || (dst_location == WINED3D_LOCATION_DRAWABLE
+#endif /* STAGING_CSMT */
             && dst_texture->swapchain->front_buffer == dst_texture))
         gl_info->gl_ops.gl.p_glFlush();
 
@@ -718,7 +744,12 @@
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view_desc view_desc;
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -729,6 +760,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     view.resource = resource;
     view.parent = NULL;
     view.parent_ops = &wined3d_null_parent_ops;
@@ -740,6 +772,21 @@
     view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
 
     hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+#else  /* STAGING_CSMT */
+    view_desc.format_id = resource->format->id;
+    view_desc.u.texture.level_idx = surface->texture_level;
+    view_desc.u.texture.layer_idx = surface->texture_layer;
+    view_desc.u.texture.layer_count = 1;
+    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
+            resource, NULL, &wined3d_null_parent_ops, &view)))
+    {
+        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
+        return hr;
+    }
+
+    hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+    wined3d_rendertarget_view_decref(view);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -804,7 +851,11 @@
         }
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#endif /* STAGING_CSMT */
 
     if (texture->flags & WINED3D_TEXTURE_COND_NP2_EMULATED)
     {
@@ -1182,6 +1233,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     /* Use surface_cpu_blt() instead of uploading directly if we need
      * conversion. Avoid calling wined3d_surface_blt() since that goes
      * through the CS. */
@@ -1192,6 +1244,11 @@
         return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box, src_texture,
                 src_sub_resource_idx, &src_box, 0, NULL, WINED3D_TEXF_POINT);
     }
+#else  /* STAGING_CSMT */
+    /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
+    if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_texture, FALSE))
+        return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+#endif /* STAGING_CSMT */
 
     context = context_acquire(dst_texture->resource.device, NULL);
     gl_info = context->gl_info;
@@ -1202,11 +1259,19 @@
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
     else
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(dst_texture, dst_sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
 
     wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
             src_texture->sub_resources[src_sub_resource_idx].locations, FALSE);
+#else  /* STAGING_CSMT */
+        surface_load_location(dst_surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
+
+    wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
+            src_texture->sub_resources[src_sub_resource_idx].locations);
+#endif /* STAGING_CSMT */
     wined3d_texture_get_pitch(src_texture, src_surface->texture_level, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
@@ -1707,6 +1772,7 @@
 {
     unsigned int texture_level = sub_resource_idx % src_texture->level_count;
     const struct wined3d_format *src_format = src_texture->resource.format;
+#if defined(STAGING_CSMT)
     void *dst_data = NULL, *src_data = NULL;
     UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const struct d3dfmt_converter_desc *conv;
@@ -1715,6 +1781,13 @@
     struct wined3d_context *context = NULL;
     struct wined3d_device *device = src_texture->resource.device;
     struct wined3d_bo_address src_bo_addr;
+#else  /* STAGING_CSMT */
+    struct wined3d_device *device = src_texture->resource.device;
+    const struct d3dfmt_converter_desc *conv = NULL;
+    struct wined3d_texture *dst_texture;
+    struct wined3d_resource_desc desc;
+    struct wined3d_map_desc src_map;
+#endif /* STAGING_CSMT */
 
     if (!(conv = find_converter(src_format->id, dst_format->id)) && (!device->d3d_initialized
             || !is_identity_fixup(src_format->color_fixup) || src_format->convert
@@ -1744,6 +1817,7 @@
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_pitch(src_texture, sub_resource_idx & src_texture->level_count,
             &src_row_pitch, &src_slice_pitch);
     wined3d_texture_get_pitch(dst_texture, 0, &dst_row_pitch, &dst_slice_pitch);
@@ -1783,6 +1857,36 @@
         /* FIXME: This seems weird, considering that we got a wined3d_bo_address from the source
          * surface above. Though not sure if the upload_data would work properly with a PBO src. */
         struct wined3d_bo_address data = {0, src_data};
+#else  /* STAGING_CSMT */
+    memset(&src_map, 0, sizeof(src_map));
+    if (FAILED(wined3d_resource_map(&src_texture->resource, sub_resource_idx,
+            &src_map, NULL, WINED3D_MAP_READONLY)))
+    {
+        ERR("Failed to map the source texture.\n");
+        wined3d_texture_decref(dst_texture);
+        return NULL;
+    }
+    if (conv)
+    {
+        struct wined3d_map_desc dst_map;
+
+        memset(&dst_map, 0, sizeof(dst_map));
+        if (FAILED(wined3d_resource_map(&dst_texture->resource, 0, &dst_map, NULL, 0)))
+        {
+            ERR("Failed to map the destination texture.\n");
+            wined3d_resource_unmap(&src_texture->resource, sub_resource_idx);
+            wined3d_texture_decref(dst_texture);
+            return NULL;
+        }
+
+        conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch, desc.width, desc.height);
+
+        wined3d_resource_unmap(&dst_texture->resource, 0);
+    }
+    else
+    {
+        struct wined3d_bo_address data = {0, src_map.data};
+#endif /* STAGING_CSMT */
         RECT src_rect = {0, 0, desc.width, desc.height};
         const struct wined3d_gl_info *gl_info;
         struct wined3d_context *context;
@@ -1795,6 +1899,7 @@
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
         wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
         wined3d_surface_upload_data(dst_texture->sub_resources[0].u.surface, gl_info, src_format,
+#if defined(STAGING_CSMT)
                 &src_rect, src_row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
 
         context_release(context);
@@ -1819,6 +1924,18 @@
     if (context)
         context_release(context);
     return NULL;
+#else  /* STAGING_CSMT */
+                &src_rect, src_map.row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
+
+        context_release(context);
+
+        wined3d_texture_validate_location(dst_texture, 0, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_texture_invalidate_location(dst_texture, 0, ~WINED3D_LOCATION_TEXTURE_RGB);
+    }
+    wined3d_resource_unmap(&src_texture->resource, sub_resource_idx);
+
+    return dst_texture;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -1896,7 +2013,11 @@
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
 
+#if defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#endif /* STAGING_CSMT */
 
     restore_rt = context_get_rt_surface(old_ctx);
     if (restore_rt != surface)
@@ -2423,9 +2544,13 @@
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
@@ -2490,9 +2615,15 @@
 
     gl_info = context->gl_info;
 
+#if defined(STAGING_CSMT)
     /* Make sure the surface is up-to-date. This should probably use
      * wined3d_texture_load_location() and worry about the destination surface too,
      * unless we're overwriting it completely. */
+#else  /* STAGING_CSMT */
+    /* Make sure the surface is up-to-date. This should probably use
+     * surface_load_location() and worry about the destination surface too,
+     * unless we're overwriting it completely. */
+#endif /* STAGING_CSMT */
     wined3d_texture_load(src_texture, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -2535,11 +2666,16 @@
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFinish();
     else if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain
             && dst_texture->swapchain->front_buffer == dst_texture))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain && dst_texture->swapchain->front_buffer == dst_texture))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     if (restore_rt)
@@ -2550,7 +2686,12 @@
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view_desc view_desc;
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2561,6 +2702,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     view.resource = resource;
     view.parent = NULL;
     view.parent_ops = &wined3d_null_parent_ops;
@@ -2572,6 +2714,21 @@
     view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
 
     hr = blitter->color_fill(device, &view, rect, color);
+#else  /* STAGING_CSMT */
+    view_desc.format_id = resource->format->id;
+    view_desc.u.texture.level_idx = s->texture_level;
+    view_desc.u.texture.layer_idx = s->texture_layer;
+    view_desc.u.texture.layer_count = 1;
+    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
+            resource, NULL, &wined3d_null_parent_ops, &view)))
+    {
+        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
+        return hr;
+    }
+
+    hr = blitter->color_fill(device, view, rect, color);
+    wined3d_rendertarget_view_decref(view);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2582,7 +2739,11 @@
 {
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
+#if defined(STAGING_CSMT)
     const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
+#else  /* STAGING_CSMT */
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
+#endif /* STAGING_CSMT */
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_texture *src_texture;
 
@@ -2883,9 +3044,13 @@
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -2902,9 +3067,13 @@
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
             gl_info->gl_ops.gl.p_glFinish();
         else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -2913,6 +3082,69 @@
     }
 }
 
+#if !defined(STAGING_CSMT)
+static DWORD resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_BUFFER:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
+{
+    unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
+    struct wined3d_texture *texture = surface->container;
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_context *context;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    wined3d_texture_get_memory(texture, sub_resource_idx, &dst, location);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &src, sub_resource->locations);
+
+    if (dst.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
+        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, sub_resource->size, src.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+        checkGLcall("Upload PBO");
+        context_release(context);
+        return;
+    }
+    if (src.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, sub_resource->size, dst.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
+        checkGLcall("Download PBO");
+        context_release(context);
+        return;
+    }
+    memcpy(dst.addr, src.addr, sub_resource->size);
+}
+
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD dst_location)
@@ -2925,9 +3157,20 @@
     wined3d_texture_prepare_location(texture, sub_resource_idx, context, dst_location);
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if defined(STAGING_CSMT)
     if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
         wined3d_texture_load_location(surface->container, surface_get_sub_resource_idx(surface),
                 context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    if (sub_resource->locations & surface_simple_locations)
+    {
+        surface_copy_simple_location(surface, dst_location);
+        return;
+    }
+
+    if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 
     /* Download the surface to system memory. */
     if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
@@ -2965,8 +3208,12 @@
     }
 
     surface_get_rect(surface, NULL, &r);
+#if defined(STAGING_CSMT)
     wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
             context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     surface_blt_to_drawable(texture->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
@@ -3043,8 +3290,12 @@
                 == WINED3D_LOCATION_TEXTURE_RGB)
         {
             FIXME_(d3d_perf)("Downloading RGB surface %p to reload it as sRGB.\n", surface);
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
                     context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(surface, context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -3053,8 +3304,12 @@
                 == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             FIXME_(d3d_perf)("Downloading sRGB surface %p to reload it as RGB.\n", surface);
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
                     context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(surface, context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
 
@@ -3062,7 +3317,11 @@
     {
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface), context, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
+        surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
     }
 
     wined3d_texture_prepare_texture(texture, context, srgb);
@@ -3076,6 +3335,7 @@
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
@@ -3085,6 +3345,17 @@
     }
 
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations, FALSE);
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+    {
+        TRACE("Removing the pbo attached to surface %p.\n", surface);
+
+        surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_texture_set_map_binding(texture, WINED3D_LOCATION_SYSMEM);
+    }
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations);
+#endif /* STAGING_CSMT */
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -3167,6 +3438,7 @@
 }
 
 /* Context activation is done by the caller. Context may be NULL in ddraw-only mode. */
+#if defined(STAGING_CSMT)
 void surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
 {
     unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
@@ -3177,6 +3449,52 @@
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#else  /* STAGING_CSMT */
+HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
+{
+    unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
+    struct wined3d_texture *texture = surface->container;
+    struct wined3d_texture_sub_resource *sub_resource;
+    unsigned int surface_w, surface_h;
+    HRESULT hr;
+
+    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
+
+    surface_w = wined3d_texture_get_level_width(texture, surface->texture_level);
+    surface_h = wined3d_texture_get_level_height(texture, surface->texture_level);
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    if (sub_resource->locations & location && (!(texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+            || (surface->ds_current_size.cx == surface_w && surface->ds_current_size.cy == surface_h)))
+    {
+        TRACE("Location (%#x) is already up to date.\n", location);
+        return WINED3D_OK;
+    }
+
+    if (WARN_ON(d3d))
+    {
+        DWORD required_access = resource_access_from_location(location);
+        if ((texture->resource.access_flags & required_access) != required_access)
+            WARN("Operation requires %#x access, but surface only has %#x.\n",
+                    required_access, texture->resource.access_flags);
+    }
+
+    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface previously discarded, nothing to do.\n");
+        wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        goto done;
+    }
+
+    if (!sub_resource->locations)
+    {
+        ERR("Surface %p does not have any up to date location.\n", surface);
+        wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        return surface_load_location(surface, context, location);
+    }
+#endif /* STAGING_CSMT */
 
     if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
@@ -3189,7 +3507,11 @@
 
         FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
                 wined3d_debug_location(sub_resource->locations), wined3d_debug_location(location));
+#if defined(STAGING_CSMT)
         return;
+#else  /* STAGING_CSMT */
+        return WINED3DERR_INVALIDCALL;
+#endif /* STAGING_CSMT */
     }
 
     switch (location)
@@ -3202,7 +3524,11 @@
 
         case WINED3D_LOCATION_DRAWABLE:
             if (FAILED(hr = surface_load_drawable(surface, context)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return hr;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_LOCATION_RB_RESOLVED:
@@ -3214,7 +3540,11 @@
         case WINED3D_LOCATION_TEXTURE_SRGB:
             if (FAILED(hr = surface_load_texture(surface, context,
                     location == WINED3D_LOCATION_TEXTURE_SRGB)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return hr;
+#endif /* STAGING_CSMT */
             break;
 
         default:
@@ -3223,7 +3553,19 @@
     }
 
 done:
+#if defined(STAGING_CSMT)
     return;
+#else  /* STAGING_CSMT */
+    wined3d_texture_validate_location(texture, sub_resource_idx, location);
+
+    if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+    {
+        surface->ds_current_size.cx = surface_w;
+        surface->ds_current_size.cy = surface_h;
+    }
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT ffp_blit_alloc(struct wined3d_device *device) { return WINED3D_OK; }
@@ -3555,6 +3897,7 @@
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_context *context = NULL;
     struct wined3d_bo_address src_bo_addr, dst_bo_addr;
@@ -3582,6 +3925,18 @@
         wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
                 &dst_map.row_pitch, &dst_map.slice_pitch);
 
+#else  /* STAGING_CSMT */
+
+    TRACE("dst_texture %p, dst_sub_resource_idx %u, dst_box %s, src_texture %p, "
+            "src_sub_resource_idx %u, src_box %s, flags %#x, fx %p, filter %s.\n",
+            dst_texture, dst_sub_resource_idx, debug_box(dst_box), src_texture,
+            src_sub_resource_idx, debug_box(src_box), flags, fx, debug_d3dtexturefiltertype(filter));
+
+    if (src_texture == dst_texture && src_sub_resource_idx == dst_sub_resource_idx)
+    {
+        same_sub_resource = TRUE;
+        wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, NULL, 0);
+#endif /* STAGING_CSMT */
         src_map = dst_map;
         src_format = dst_texture->resource.format;
         dst_format = src_format;
@@ -3606,6 +3961,7 @@
                 src_texture = converted_texture;
                 src_sub_resource_idx = 0;
             }
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(src_texture, src_sub_resource_idx,
                     context, src_texture->resource.map_binding);
             wined3d_texture_get_pitch(src_texture, src_sub_resource_idx % src_texture->level_count,
@@ -3616,6 +3972,9 @@
                     src_texture->sub_resources[src_sub_resource_idx].size,
                     context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
+#else  /* STAGING_CSMT */
+            wined3d_resource_map(&src_texture->resource, src_sub_resource_idx, &src_map, NULL, WINED3D_MAP_READONLY);
+#endif /* STAGING_CSMT */
             src_format = src_texture->resource.format;
             src_fmt_flags = src_texture->resource.format_flags;
         }
@@ -3625,6 +3984,7 @@
             src_fmt_flags = dst_fmt_flags;
         }
 
+#if defined(STAGING_CSMT)
         wined3d_texture_get_memory(dst_texture, dst_sub_resource_idx, &dst_bo_addr,
                 dst_texture->resource.map_binding, FALSE);
         dst_map.data = wined3d_texture_map_bo_address(&dst_bo_addr,
@@ -3632,6 +3992,9 @@
                 context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
         wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
                 &dst_map.row_pitch, &dst_map.slice_pitch);
+#else  /* STAGING_CSMT */
+        wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, dst_box, 0);
+#endif /* STAGING_CSMT */
     }
 
     bpp = dst_format->byte_count;
@@ -3645,9 +4008,18 @@
         sbase = (BYTE *)src_map.data
                 + ((src_box->top / src_format->block_height) * src_map.row_pitch)
                 + ((src_box->left / src_format->block_width) * src_format->block_byte_count);
+#if defined(STAGING_CSMT)
     dbuf = (BYTE *)dst_map.data
             + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
             + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
+#else  /* STAGING_CSMT */
+    if (same_sub_resource)
+        dbuf = (BYTE *)dst_map.data
+                + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
+                + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
+    else
+        dbuf = dst_map.data;
+#endif /* STAGING_CSMT */
 
     if (src_fmt_flags & dst_fmt_flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -4040,6 +4412,7 @@
         }
     }
 
+#if defined(STAGING_CSMT)
     wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
             ~dst_texture->resource.map_binding);
 
@@ -4066,6 +4439,18 @@
         wined3d_texture_decref(converted_texture);
     if (context)
         context_release(context);
+#else  /* STAGING_CSMT */
+error:
+    if (flags)
+        FIXME("    Unsupported flags %#x.\n", flags);
+
+release:
+    wined3d_resource_unmap(&dst_texture->resource, dst_sub_resource_idx);
+    if (src_texture && !same_sub_resource)
+        wined3d_resource_unmap(&src_texture->resource, src_sub_resource_idx);
+    if (converted_texture)
+        wined3d_texture_decref(converted_texture);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -4110,7 +4495,11 @@
     cpu_blit_blit_surface,
 };
 
+#if defined(STAGING_CSMT)
 void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#else  /* STAGING_CSMT */
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#endif /* STAGING_CSMT */
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -4120,8 +4509,14 @@
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#if defined(STAGING_CSMT)
     struct wined3d_texture *src_texture;
     unsigned int src_sub_resource_idx;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *src_texture = NULL;
+    unsigned int dst_w, dst_h, src_w, src_h;
+    unsigned int src_sub_resource_idx = 0;
+#endif /* STAGING_CSMT */
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
 
@@ -4134,6 +4529,7 @@
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
+#if defined(STAGING_CSMT)
     if (src_surface)
     {
         src_texture = src_surface->container;
@@ -4145,6 +4541,86 @@
         src_texture = NULL;
         src_sub_resource_idx = 0;
         src_swapchain = NULL;
+#else  /* STAGING_CSMT */
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_texture = src_surface->container;
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+    }
+
+    if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
+            || (src_texture && src_texture->sub_resources[src_sub_resource_idx].map_count))
+    {
+        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+        return WINEDDERR_SURFACEBUSY;
+    }
+
+    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
+    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
+    if (IsRectEmpty(dst_rect) || dst_rect->left > dst_w || dst_rect->left < 0
+            || dst_rect->top > dst_h || dst_rect->top < 0
+            || dst_rect->right > dst_w || dst_rect->right < 0
+            || dst_rect->bottom > dst_h || dst_rect->bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_texture)
+    {
+        src_w = wined3d_texture_get_level_width(src_texture, src_surface->texture_level);
+        src_h = wined3d_texture_get_level_height(src_texture, src_surface->texture_level);
+        if (IsRectEmpty(src_rect) || src_rect->left > src_w || src_rect->left < 0
+                || src_rect->top > src_h || src_rect->top < 0
+                || src_rect->right > src_w || src_rect->right < 0
+                || src_rect->bottom > src_h || src_rect->bottom < 0)
+        {
+            WARN("The application gave us a bad source rectangle.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+#endif /* STAGING_CSMT */
     }
 
     if (!device->d3d_initialized)
@@ -4169,6 +4645,13 @@
         goto fallback;
     }
 
+#if !defined(STAGING_CSMT)
+    if (src_texture)
+        src_swapchain = src_texture->swapchain;
+    else
+        src_swapchain = NULL;
+
+#endif /* STAGING_CSMT */
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -4204,6 +4687,7 @@
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->fill_color, &depth))
+#if defined(STAGING_CSMT)
                 return;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
@@ -4214,6 +4698,24 @@
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3DERR_INVALIDCALL;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return WINED3D_OK;
+        }
+        else
+        {
+            if (src_ds_flags != dst_ds_flags)
+            {
+                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
+                    src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -4249,7 +4751,11 @@
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -4288,11 +4794,18 @@
                         if (!wined3d_resource_is_offscreen(&dst_texture->resource))
                         {
                             struct wined3d_context *context = context_acquire(device, dst_surface);
+#if defined(STAGING_CSMT)
                             wined3d_texture_load_location(dst_texture, surface_get_sub_resource_idx(dst_surface),
                                     context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
                         return;
+#else  /* STAGING_CSMT */
+                            surface_load_location(dst_surface, context, dst_texture->resource.draw_binding);
+                            context_release(context);
+                        }
+                        return WINED3D_OK;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4316,7 +4829,11 @@
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4337,7 +4854,11 @@
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4347,7 +4868,11 @@
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
+#if defined(STAGING_CSMT)
                 return;
+#else  /* STAGING_CSMT */
+                return WINED3D_OK;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -4355,6 +4880,7 @@
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+#if defined(STAGING_CSMT)
         return;
 
 cpu:
@@ -4499,4 +5025,11 @@
             flags, fx, filter);
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+        return WINED3D_OK;
+
+cpu:
+    return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+            src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -105,11 +105,13 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         struct wined3d_device *device = swapchain->device;
 
         if (wined3d_settings.cs_multithreaded)
             device->cs->ops->finish(device->cs);
 
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -332,7 +334,11 @@
         if (texture->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, 0, context, location);
+#else  /* STAGING_CSMT */
+            surface_load_location(back_buffer, context, location);
+#endif /* STAGING_CSMT */
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, back_buffer, NULL, location);
@@ -462,7 +468,11 @@
         sub_resource = &texture->sub_resources[0];
 
         if (!(sub_resource->locations & supported_locations))
+#if defined(STAGING_CSMT)
             wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#else  /* STAGING_CSMT */
+            surface_load_location(sub_resource->u.surface, context, texture->resource.draw_binding);
+#endif /* STAGING_CSMT */
 
         texture_prev->texture_rgb = texture->texture_rgb;
         texture_prev->rb_multisample = texture->rb_multisample;
@@ -483,10 +493,17 @@
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
+#if defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags,
         struct wined3d_rendertarget_view *depth_stencil)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+{
+    struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
+    const struct wined3d_fb_state *fb = &swapchain->device->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_texture *logo_texture;
     struct wined3d_context *context;
@@ -507,8 +524,12 @@
         RECT rect = {0, 0, logo_texture->resource.width, logo_texture->resource.height};
 
         /* Blit the logo into the upper left corner of the drawable. */
+#if defined(STAGING_CSMT)
         surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &rect,
                 logo_texture->sub_resources[0].u.surface, &rect,
+#else  /* STAGING_CSMT */
+        wined3d_texture_blt(swapchain->back_buffers[0], 0, &rect, logo_texture, 0, &rect,
+#endif /* STAGING_CSMT */
                 WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -537,8 +558,13 @@
         if (swapchain->desc.windowed)
             MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&dst_rect, 2);
         if (wined3d_clip_blit(&clip_rect, &dst_rect, &src_rect))
+#if defined(STAGING_CSMT)
             surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &dst_rect,
                     swapchain->device->cursor_texture->sub_resources[0].u.surface, &src_rect,
+#else  /* STAGING_CSMT */
+            wined3d_texture_blt(swapchain->back_buffers[0], 0, &dst_rect,
+                    swapchain->device->cursor_texture, 0, &src_rect,
+#endif /* STAGING_CSMT */
                     WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -562,6 +588,7 @@
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_load_location(back_buffer->container, 0, context, WINED3D_LOCATION_TEXTURE_RGB);
         wined3d_texture_invalidate_location(back_buffer->container, 0, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
@@ -571,6 +598,16 @@
     {
         wined3d_texture_load_location(swapchain->back_buffers[0], 0, context,
                 swapchain->back_buffers[0]->resource.draw_binding);
+#else  /* STAGING_CSMT */
+        surface_load_location(back_buffer, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_texture_invalidate_location(back_buffer->container, 0, WINED3D_LOCATION_DRAWABLE);
+        swapchain->render_to_fbo = TRUE;
+        swapchain_update_draw_bindings(swapchain);
+    }
+    else
+    {
+        surface_load_location(back_buffer, context, back_buffer->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->render_to_fbo)
@@ -583,8 +620,13 @@
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
         gl_info->gl_ops.gl.p_glFlush();
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1)
+        gl_info->gl_ops.gl.p_glFinish();
+#endif /* STAGING_CSMT */
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc);
@@ -621,6 +663,7 @@
         wined3d_texture_validate_location(swapchain->back_buffers[swapchain->desc.backbuffer_count - 1],
                 0, WINED3D_LOCATION_DISCARDED);
 
+#if defined(STAGING_CSMT)
     if (depth_stencil)
     {
         struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(depth_stencil);
@@ -634,6 +677,21 @@
             {
                 wined3d_texture_decref(swapchain->device->cs->onscreen_depth_stencil->container);
                 swapchain->device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    if (fb->depth_stencil)
+    {
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(fb->depth_stencil);
+
+        if (ds && (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || ds->container->flags & WINED3D_TEXTURE_DISCARD))
+        {
+            surface_modify_ds_location(ds, WINED3D_LOCATION_DISCARDED,
+                    fb->depth_stencil->width, fb->depth_stencil->height);
+            if (ds == swapchain->device->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(swapchain->device->onscreen_depth_stencil->container);
+                swapchain->device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -643,12 +701,21 @@
 
 static void swapchain_gl_frontbuffer_updated(struct wined3d_swapchain *swapchain)
 {
+#if defined(STAGING_CSMT)
     struct wined3d_texture *texture = swapchain->front_buffer;
     struct wined3d_surface *surface = texture->sub_resources[0].u.surface;
     struct wined3d_context *context;
 
     context = context_acquire(swapchain->device, surface);
     wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#else  /* STAGING_CSMT */
+    struct wined3d_surface *surface;
+    struct wined3d_context *context;
+
+    surface = swapchain->front_buffer->sub_resources[0].u.surface;
+    context = context_acquire(swapchain->device, surface);
+    surface_load_location(surface, context, surface->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
     context_release(context);
     SetRectEmpty(&swapchain->front_buffer_update);
 }
@@ -704,8 +771,12 @@
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain,
+#if defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags,
         struct wined3d_rendertarget_view *depth_stencil)
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_surface *front, *back;
     HBITMAP bitmap;
@@ -816,6 +887,7 @@
     *quality = 0;
 }
 
+#if defined(STAGING_CSMT)
 HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
     const struct wined3d_adapter *adapter = device->adapter;
@@ -879,6 +951,7 @@
     return WINED3D_OK;
 }
 
+#endif /* STAGING_CSMT */
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -996,9 +1069,67 @@
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if defined(STAGING_CSMT)
         hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
         if (FAILED(hr))
             goto err;
+#else  /* STAGING_CSMT */
+        static const enum wined3d_format_id formats[] =
+        {
+            WINED3DFMT_D24_UNORM_S8_UINT,
+            WINED3DFMT_D32_UNORM,
+            WINED3DFMT_R24_UNORM_X8_TYPELESS,
+            WINED3DFMT_D16_UNORM,
+            WINED3DFMT_S1_UINT_D15_UNORM
+        };
+
+        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+        if (!swapchain->context)
+        {
+            ERR("Failed to create the context array.\n");
+            hr = E_OUTOFMEMORY;
+            goto err;
+        }
+        swapchain->num_contexts = 1;
+
+        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+         * You are able to add a depth + stencil surface at a later stage when you need it.
+         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+         * context, need torecreate shaders, textures and other resources.
+         *
+         * The context manager already takes care of the state problem and for the other tasks code from Reset
+         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+         * issue needs to be fixed. */
+        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+        {
+            swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+            swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+            if (swapchain->context[0]) break;
+            TRACE("Depth stencil format %s is not supported, trying next format\n",
+                  debug_d3dformat(formats[i]));
+        }
+
+        if (!swapchain->context[0])
+        {
+            WARN("Failed to create context.\n");
+            hr = WINED3DERR_NOTAVAILABLE;
+            goto err;
+        }
+
+        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+                && (!desc->enable_auto_depth_stencil
+                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+        {
+            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+        }
+        context_release(swapchain->context[0]);
+        swapchain_update_swap_interval(swapchain);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1324,7 +1455,9 @@
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
     struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1336,9 +1469,11 @@
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
     if (wined3d_settings.cs_multithreaded)
         device->cs->ops->finish(device->cs);
 
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -104,7 +104,9 @@
         sub_resource->locations &= ~WINED3D_LOCATION_SYSMEM;
     }
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
     texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
@@ -196,7 +198,11 @@
 }
 
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+#if defined(STAGING_CSMT)
         struct wined3d_bo_address *data, DWORD locations, BOOL map)
+#else  /* STAGING_CSMT */
+        struct wined3d_bo_address *data, DWORD locations)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
@@ -207,10 +213,14 @@
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if defined(STAGING_CSMT)
         if (map)
             data->buffer_object = sub_resource->map_buffer->name;
         else
             data->buffer_object = sub_resource->buffer->name;
+#else  /* STAGING_CSMT */
+        data->buffer_object = sub_resource->buffer_object;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -221,10 +231,14 @@
     }
     if (locations & WINED3D_LOCATION_SYSMEM)
     {
+#if defined(STAGING_CSMT)
         if (map)
             data->addr = texture->resource.map_heap_memory;
         else
             data->addr = texture->resource.heap_memory;
+#else  /* STAGING_CSMT */
+        data->addr = texture->resource.heap_memory;
+#endif /* STAGING_CSMT */
         data->addr += sub_resource->offset;
         data->buffer_object = 0;
         return;
@@ -310,6 +324,7 @@
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if defined(STAGING_CSMT)
         unsigned int sub_resource_idx, struct wined3d_context *context)
 {
     struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
@@ -326,6 +341,20 @@
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
             name, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+{
+    GLuint *buffer_object;
+
+    buffer_object = &texture->sub_resources[sub_resource_idx].buffer_object;
+    GL_EXTCALL(glDeleteBuffers(1, buffer_object));
+    checkGLcall("glDeleteBuffers");
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+    *buffer_object = 0;
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            *buffer_object, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -342,10 +371,17 @@
     for (i = 0; i < sub_count; ++i)
     {
         if (texture->sub_resources[i].locations == texture->resource.map_binding
+#if defined(STAGING_CSMT)
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
             wined3d_texture_remove_buffer_object(texture, i, context);
+#else  /* STAGING_CSMT */
+                && !texture->texture_ops->texture_load_location(texture, i, context, map_binding))
+            ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
+        if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -479,6 +515,7 @@
     resource_unload(&texture->resource);
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_texture_cleanup(struct wined3d_texture *texture)
 {
     unsigned int sub_count = texture->level_count * texture->layer_count;
@@ -515,6 +552,42 @@
     texture->texture_ops->texture_cleanup_sub_resources(texture);
     wined3d_texture_unload_gl_texture(texture);
     HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+static void wined3d_texture_cleanup(struct wined3d_texture *texture)
+{
+    unsigned int sub_count = texture->level_count * texture->layer_count;
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    const struct wined3d_gl_info *gl_info;
+    GLuint buffer_object;
+    unsigned int i;
+
+    TRACE("texture %p.\n", texture);
+
+    for (i = 0; i < sub_count; ++i)
+    {
+        if (!(buffer_object = texture->sub_resources[i].buffer_object))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer_object);
+
+        /* We may not be able to get a context in wined3d_texture_cleanup() in
+         * general, but if a buffer object was previously created we can. */
+        if (!context)
+        {
+            context = context_acquire(device, NULL);
+            gl_info = context->gl_info;
+        }
+
+        GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+    }
+    if (context)
+        context_release(context);
+
+    texture->texture_ops->texture_cleanup_sub_resources(texture);
+    wined3d_texture_unload_gl_texture(texture);
+    resource_cleanup(&texture->resource);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture, struct wined3d_swapchain *swapchain)
@@ -808,6 +881,7 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 static void wined3d_texture_cleanup_main(struct wined3d_texture *texture)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -831,6 +905,7 @@
     wined3d_cs_emit_texture_cleanup(device->cs, texture);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 {
     ULONG refcount;
@@ -845,8 +920,14 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(texture);
+        texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -896,7 +977,11 @@
         TRACE("Reloading because of color key value change.\n");
         for (i = 0; i < sub_count; i++)
         {
+#if defined(STAGING_CSMT)
             if (!wined3d_texture_load_location(texture, i, context, texture->resource.map_binding))
+#else  /* STAGING_CSMT */
+            if (!texture->texture_ops->texture_load_location(texture, i, context, texture->resource.map_binding))
+#endif /* STAGING_CSMT */
                 ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
             else
                 wined3d_texture_invalidate_location(texture, i, ~texture->resource.map_binding);
@@ -914,7 +999,11 @@
     /* Reload the surfaces if the texture is marked dirty. */
     for (i = 0; i < sub_count; ++i)
     {
+#if defined(STAGING_CSMT)
         if (!wined3d_texture_load_location(texture, i, context,
+#else  /* STAGING_CSMT */
+        if (!texture->texture_ops->texture_load_location(texture, i, context,
+#endif /* STAGING_CSMT */
                 srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB))
             ERR("Failed to load location (srgb %#x).\n", srgb);
     }
@@ -923,8 +1012,15 @@
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
+#if defined(STAGING_CSMT)
     const struct wined3d_device *device = texture->resource.device;
     wined3d_cs_emit_texture_preload(device->cs, texture);
+#else  /* STAGING_CSMT */
+    struct wined3d_context *context;
+    context = context_acquire(texture->resource.device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -987,6 +1083,7 @@
 
     if (texture->lod != lod)
     {
+#if defined(STAGING_CSMT)
         if (wined3d_settings.cs_multithreaded)
         {
             struct wined3d_device *device = texture->resource.device;
@@ -994,6 +1091,7 @@
             device->cs->ops->finish(device->cs);
         }
 
+#endif /* STAGING_CSMT */
         texture->lod = lod;
 
         texture->texture_rgb.base_level = ~0u;
@@ -1114,10 +1212,14 @@
     }
 
     if (device->d3d_initialized)
+#if defined(STAGING_CSMT)
     {
         wined3d_cs_emit_evict_resource(device->cs, &texture->resource);
         device->cs->ops->finish(device->cs);
     }
+#else  /* STAGING_CSMT */
+        texture->resource.resource_ops->resource_unload(&texture->resource);
+#endif /* STAGING_CSMT */
 
     sub_resource = &texture->sub_resources[0];
     surface = sub_resource->u.surface;
@@ -1128,7 +1230,9 @@
     }
 
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
     texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 
     if ((texture->row_pitch = pitch))
         texture->slice_pitch = height * pitch;
@@ -1185,6 +1289,7 @@
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if defined(STAGING_CSMT)
     {
         HDC dc;
         wined3d_texture_get_dc(texture, 0, &dc);
@@ -1218,6 +1323,31 @@
      * message. Freeing the actual memory and setting the read pointer to 0 is
      * the task of the worker thread. */
     texture->resource.map_heap_memory = NULL;
+#else  /* STAGING_CSMT */
+        wined3d_surface_create_dc(surface);
+
+    return WINED3D_OK;
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+{
+    struct wined3d_texture_sub_resource *sub_resource;
+
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+    if (sub_resource->buffer_object)
+        return;
+
+    GL_EXTCALL(glGenBuffers(1, &sub_resource->buffer_object));
+    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, sub_resource->buffer_object));
+    GL_EXTCALL(glBufferData(GL_PIXEL_UNPACK_BUFFER, sub_resource->size, NULL, GL_STREAM_DRAW));
+    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer_object, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1335,7 +1465,9 @@
                 ERR("Failed to allocate system memory.\n");
                 return FALSE;
             }
+#if defined(STAGING_CSMT)
             texture->resource.heap_memory = texture->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_USER_MEMORY:
@@ -1344,7 +1476,11 @@
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1415,7 +1551,11 @@
         WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
 
     context = context_acquire(texture->resource.device, NULL);
+#if defined(STAGING_CSMT)
     if (!wined3d_texture_load_location(texture, sub_resource_idx,
+#else  /* STAGING_CSMT */
+    if (!texture->texture_ops->texture_load_location(texture, sub_resource_idx,
+#endif /* STAGING_CSMT */
             context, texture->resource.map_binding))
     {
         ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
@@ -1461,7 +1601,9 @@
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -1484,8 +1626,12 @@
 static BOOL texture2d_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location)
 {
+#if defined(STAGING_CSMT)
     surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location);
     return TRUE;
+#else  /* STAGING_CSMT */
+    return SUCCEEDED(surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location));
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -1575,6 +1721,10 @@
             list_remove(&overlay->overlay_entry);
             overlay->overlay_dest = NULL;
         }
+#if !defined(STAGING_CSMT)
+
+        sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -1623,7 +1773,11 @@
         struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[i];
 
         if (resource->pool != WINED3D_POOL_DEFAULT
+#if defined(STAGING_CSMT)
                 && wined3d_texture_load_location(texture, i, context, resource->map_binding))
+#else  /* STAGING_CSMT */
+                && texture->texture_ops->texture_load_location(texture, i, context, resource->map_binding))
+#endif /* STAGING_CSMT */
         {
             wined3d_texture_invalidate_location(texture, i, ~resource->map_binding);
         }
@@ -1638,8 +1792,13 @@
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if defined(STAGING_CSMT)
         if (sub_resource->buffer)
             wined3d_texture_remove_buffer_object(texture, i, context);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer_object)
+            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -1664,6 +1823,7 @@
     wined3d_texture_unload_gl_texture(texture);
 }
 
+#if defined(STAGING_CSMT)
 void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx, DWORD flags)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -1745,6 +1905,7 @@
     return data;
 }
 
+#endif /* STAGING_CSMT */
 static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
@@ -1752,9 +1913,19 @@
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_device *device = resource->device;
     unsigned int fmt_flags = resource->format_flags;
+#if defined(STAGING_CSMT)
     struct wined3d_texture *texture;
     unsigned int texture_level;
     BYTE *base_memory;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = NULL;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture *texture;
+    struct wined3d_bo_address data;
+    unsigned int texture_level;
+    BYTE *base_memory;
+    BOOL ret;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %s, flags %#x.\n",
             resource, sub_resource_idx, map_desc, debug_box(box), flags);
@@ -1801,6 +1972,7 @@
 
     flags = wined3d_resource_sanitize_map_flags(resource, flags);
 
+#if defined(STAGING_CSMT)
     if (flags & WINED3D_MAP_NOOVERWRITE)
         FIXME("WINED3D_MAP_NOOVERWRITE is not implemented yet.\n");
 
@@ -1822,6 +1994,47 @@
         wined3d_resource_wait_fence(&texture->resource);
 
     base_memory = wined3d_cs_emit_texture_map(device->cs, texture, sub_resource_idx, flags);
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
+                wined3d_debug_location(texture->resource.map_binding));
+        if ((ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
+                context, texture->resource.map_binding)))
+            wined3d_texture_validate_location(texture, sub_resource_idx, texture->resource.map_binding);
+    }
+    else
+    {
+        if (resource->usage & WINED3DUSAGE_DYNAMIC)
+            WARN_(d3d_perf)("Mapping a dynamic texture without WINED3D_MAP_DISCARD.\n");
+        ret = texture->texture_ops->texture_load_location(texture,
+                sub_resource_idx, context, texture->resource.map_binding);
+    }
+
+    if (!ret)
+    {
+        ERR("Failed to prepare location.\n");
+        context_release(context);
+        return E_OUTOFMEMORY;
+    }
+
+    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    base_memory = wined3d_texture_map_bo_address(&data, sub_resource->size,
+            gl_info, GL_PIXEL_UNPACK_BUFFER, flags);
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (context)
+        context_release(context);
+#endif /* STAGING_CSMT */
 
     if (fmt_flags & WINED3DFMT_FLAG_BROKEN_PITCH)
     {
@@ -1857,6 +2070,19 @@
         }
     }
 
+#if !defined(STAGING_CSMT)
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        RECT *r = &texture->swapchain->front_buffer_update;
+
+        if (!box)
+            SetRect(r, 0, 0, resource->width, resource->height);
+        else
+            SetRect(r, box->left, box->top, box->right, box->bottom);
+        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
+    }
+
+#endif /* STAGING_CSMT */
     ++resource->map_count;
     ++sub_resource->map_count;
 
@@ -1866,6 +2092,7 @@
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_texture_unmap_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx)
 {
     struct wined3d_context *context = NULL;
@@ -1921,6 +2148,16 @@
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_texture *texture;
     struct wined3d_device *device = resource->device;
+#else  /* STAGING_CSMT */
+static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
+{
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_device *device = resource->device;
+    const struct wined3d_gl_info *gl_info = NULL;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture *texture;
+    struct wined3d_bo_address data;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
@@ -1936,6 +2173,7 @@
         return WINEDDERR_NOTLOCKED;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_texture_unmap(device->cs, texture, sub_resource_idx);
 
     if (sub_resource->unmap_dirtify)
@@ -1943,6 +2181,28 @@
         wined3d_cs_emit_texture_changed(device->cs, texture, sub_resource_idx, sub_resource->map_buffer,
                 resource->map_heap_memory);
         sub_resource->unmap_dirtify = FALSE;
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+    }
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        if (!(sub_resource->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
+            texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(texture->swapchain);
+    }
+    else if (resource->format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
+    {
+        FIXME("Depth / stencil buffer locking is not implemented.\n");
+#endif /* STAGING_CSMT */
     }
 
     --sub_resource->map_count;
@@ -1976,7 +2236,9 @@
             && !gl_info->supported[EXT_TEXTURE_ARRAY])
     {
         WARN("OpenGL implementation does not support array textures.\n");
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1985,7 +2247,9 @@
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2008,7 +2272,9 @@
             if (desc->pool != WINED3D_POOL_SCRATCH)
             {
                 WARN("Attempted to create a mipmapped/cube/array NPOT texture without unconditional NPOT support.\n");
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
 
@@ -2026,7 +2292,9 @@
             {
                 FIXME("Compressed or height scaled non-power-of-two (%ux%u) textures are not supported.\n",
                         desc->width, desc->height);
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_NOTAVAILABLE;
             }
 
@@ -2058,7 +2326,9 @@
         if (desc->pool == WINED3D_POOL_DEFAULT || desc->pool == WINED3D_POOL_MANAGED)
         {
             WARN("Dimensions (%ux%u) exceed the maximum texture size.\n", pow2_width, pow2_height);
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
             return WINED3DERR_NOTAVAILABLE;
         }
 
@@ -2072,6 +2342,7 @@
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
@@ -2080,6 +2351,14 @@
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
             HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (level_count != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2088,7 +2367,9 @@
             flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2130,7 +2411,11 @@
     if (level_count > ~(SIZE_T)0 / layer_count
             || !(surfaces = wined3d_calloc(level_count * layer_count, sizeof(*surfaces))))
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
 
@@ -2173,7 +2458,11 @@
                     texture, idx, &sub_resource->parent, &sub_resource->parent_ops)))
             {
                 WARN("Failed to create surface parent, hr %#x.\n", hr);
+#if defined(STAGING_CSMT)
                 wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+                wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
                 return hr;
             }
 
@@ -2181,6 +2470,7 @@
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
+#if defined(STAGING_CSMT)
             if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
             {
                 HDC dc;
@@ -2190,6 +2480,13 @@
                     return hr;
                 }
                 wined3d_texture_release_dc(texture, idx, dc);
+#else  /* STAGING_CSMT */
+            if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
+                    && FAILED(hr = wined3d_surface_create_dc(surface)))
+            {
+                wined3d_texture_cleanup(texture);
+                return hr;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -2197,7 +2494,9 @@
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture3d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -2256,6 +2555,23 @@
 
 static void texture3d_cleanup_sub_resources(struct wined3d_texture *texture)
 {
+#if !defined(STAGING_CSMT)
+    unsigned int sub_count = texture->level_count * texture->layer_count;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_volume *volume;
+    unsigned int i;
+
+    for (i = 0; i < sub_count; ++i)
+    {
+        sub_resource = &texture->sub_resources[i];
+        if ((volume = sub_resource->u.volume))
+        {
+            TRACE("volume %p.\n", volume);
+
+            sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
+        }
+    }
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, texture->sub_resources[0].u.volume);
 }
 
@@ -2309,7 +2625,9 @@
     if (layer_count != 1)
     {
         ERR("Invalid layer count for volume texture.\n");
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return E_INVALIDARG;
     }
 
@@ -2318,6 +2636,7 @@
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
@@ -2326,6 +2645,14 @@
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
         HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!gl_info->supported[EXT_TEXTURE3D])
+    {
+        WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2335,6 +2662,7 @@
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
             HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
@@ -2343,6 +2671,14 @@
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
             HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (level_count != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2351,7 +2687,9 @@
             || desc->pool == WINED3D_POOL_SCRATCH))
     {
         WARN("Attempted to create a DYNAMIC texture in pool %s.\n", debug_d3dpool(desc->pool));
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2378,7 +2716,9 @@
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+#if defined(STAGING_CSMT)
                 HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -2388,7 +2728,9 @@
             0, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2401,6 +2743,7 @@
     if (wined3d_texture_use_pbo(texture, gl_info))
     {
         wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
         texture->resource.map_heap_memory = NULL;
         texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
     }
@@ -2408,6 +2751,14 @@
     if (!(volumes = wined3d_calloc(level_count, sizeof(*volumes))))
     {
         wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+        texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
+    }
+
+    if (!(volumes = wined3d_calloc(level_count, sizeof(*volumes))))
+    {
+        wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
 
@@ -2429,7 +2780,11 @@
                 texture, i, &sub_resource->parent, &sub_resource->parent_ops)))
         {
             WARN("Failed to create volume parent, hr %#x.\n", hr);
+#if defined(STAGING_CSMT)
             wined3d_texture_cleanup_main(texture);
+#else  /* STAGING_CSMT */
+            wined3d_texture_cleanup(texture);
+#endif /* STAGING_CSMT */
             return hr;
         }
 
@@ -2726,6 +3081,9 @@
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if !defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2733,7 +3091,12 @@
      * in this case. */
     if (data && FAILED(hr = wined3d_texture_upload_data(object, data)))
     {
+#if defined(STAGING_CSMT)
         wined3d_texture_cleanup_main(object);
+#else  /* STAGING_CSMT */
+        wined3d_texture_cleanup(object);
+        HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -2743,6 +3106,7 @@
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
 {
     struct wined3d_device *device = texture->resource.device;
@@ -2776,6 +3140,15 @@
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_surface *surface;
+#else  /* STAGING_CSMT */
+HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource;
+    struct wined3d_context *context = NULL;
+    struct wined3d_surface *surface;
+    HRESULT hr = WINED3D_OK;
+#endif /* STAGING_CSMT */
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -2793,6 +3166,7 @@
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
     if (FAILED(texture->dc_hr))
         return texture->dc_hr;
@@ -2817,6 +3191,30 @@
         wined3d_texture_update_map_binding(texture);
     if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+#else  /* STAGING_CSMT */
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    surface_load_location(surface, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        hr = wined3d_surface_create_dc(surface);
+    if (context)
+        context_release(context);
+    if (FAILED(hr))
+        return WINED3DERR_INVALIDCALL;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+
+    *dc = surface->dc;
+    TRACE("Returning dc %p.\n", *dc);
+
+    return hr;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -2847,6 +3245,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
     wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
 
     return WINED3D_OK;
@@ -2980,4 +3379,16 @@
         }
     }
     return ret;
+#else  /* STAGING_CSMT */
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
+
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -4331,7 +4331,11 @@
         float y_offset = context->render_offscreen
                 ? (center_offset - (2.0f * y) - h) / h
                 : (center_offset - (2.0f * y) - h) / -h;
+#if defined(STAGING_CSMT)
         enum wined3d_depth_buffer_type zenable = state->fb.depth_stencil ?
+#else  /* STAGING_CSMT */
+        enum wined3d_depth_buffer_type zenable = state->fb->depth_stencil ?
+#endif /* STAGING_CSMT */
                 state->render_states[WINED3D_RS_ZENABLE] : WINED3D_ZB_FALSE;
         float z_scale = zenable ? 2.0f : 0.0f;
         float z_offset = zenable ? -1.0f : 0.0f;
@@ -5128,7 +5132,11 @@
                 break;
         }
     }
+#if defined(STAGING_CSMT)
     settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb);
+#else  /* STAGING_CSMT */
+    settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb);
+#endif /* STAGING_CSMT */
     if (d3d_info->vs_clipping || !use_vs(state) || !state->render_states[WINED3D_RS_CLIPPING]
             || !state->render_states[WINED3D_RS_CLIPPLANEENABLE])
     {
diff --git a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
--- a/dlls/wined3d/vertexdeclaration.c
+++ b/dlls/wined3d/vertexdeclaration.c
@@ -50,12 +50,14 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration)
 {
     HeapFree(GetProcessHeap(), 0, declaration->elements);
     HeapFree(GetProcessHeap(), 0, declaration);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration *declaration)
 {
     ULONG refcount = InterlockedDecrement(&declaration->ref);
@@ -64,9 +66,15 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         const struct wined3d_device *device = declaration->device;
         declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
         wined3d_cs_emit_vertex_declaration_destroy(device->cs, declaration);
+#else  /* STAGING_CSMT */
+        HeapFree(GetProcessHeap(), 0, declaration->elements);
+        declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
+        HeapFree(GetProcessHeap(), 0, declaration);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -33,11 +33,13 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view)
 {
     HeapFree(GetProcessHeap(), 0, view);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_rendertarget_view_decref(struct wined3d_rendertarget_view *view)
 {
     ULONG refcount = InterlockedDecrement(&view->refcount);
@@ -46,6 +48,7 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         struct wined3d_device *device = view->resource->device;
 
         /* Call wined3d_object_destroyed() before releasing the resource,
@@ -53,6 +56,13 @@
         view->parent_ops->wined3d_object_destroyed(view->parent);
         wined3d_resource_decref(view->resource);
         wined3d_cs_emit_view_destroy(device->cs, view);
+#else  /* STAGING_CSMT */
+        /* Call wined3d_object_destroyed() before releasing the resource,
+         * since releasing the resource may end up destroying the parent. */
+        view->parent_ops->wined3d_object_destroyed(view->parent);
+        wined3d_resource_decref(view->resource);
+        HeapFree(GetProcessHeap(), 0, view);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -184,11 +194,13 @@
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_shader_resource_view_destroy_cs(struct wined3d_shader_resource_view *view)
 {
     HeapFree(GetProcessHeap(), 0, view);
 }
 
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_shader_resource_view_decref(struct wined3d_shader_resource_view *view)
 {
     ULONG refcount = InterlockedDecrement(&view->refcount);
@@ -197,6 +209,7 @@
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
         struct wined3d_device *device = view->resource->device;
 
         /* Call wined3d_object_destroyed() before releasing the resource,
@@ -204,6 +217,13 @@
         view->parent_ops->wined3d_object_destroyed(view->parent);
         wined3d_resource_decref(view->resource);
         wined3d_cs_emit_shader_resource_view_destroy(device->cs, view);
+#else  /* STAGING_CSMT */
+        /* Call wined3d_object_destroyed() before releasing the resource,
+         * since releasing the resource may end up destroying the parent. */
+        view->parent_ops->wined3d_object_destroyed(view->parent);
+        wined3d_resource_decref(view->resource);
+        HeapFree(GetProcessHeap(), 0, view);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -119,6 +119,29 @@
 
 }
 
+#if !defined(STAGING_CSMT)
+static DWORD volume_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void wined3d_volume_srgb_transfer(struct wined3d_volume *volume,
         struct wined3d_context *context, BOOL dest_is_srgb)
@@ -149,6 +172,9 @@
 BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         struct wined3d_context *context, DWORD location)
 {
+#if !defined(STAGING_CSMT)
+    DWORD required_access = volume_access_from_location(location);
+#endif /* STAGING_CSMT */
     unsigned int sub_resource_idx = volume->texture_level;
     struct wined3d_texture *texture = volume->container;
     struct wined3d_texture_sub_resource *sub_resource;
@@ -157,8 +183,34 @@
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
         wined3d_debug_location(sub_resource->locations));
 
+#if defined(STAGING_CSMT)
     if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
         return FALSE;
+#else  /* STAGING_CSMT */
+    if ((sub_resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return TRUE;
+    }
+
+    if ((texture->resource.access_flags & required_access) != required_access)
+    {
+        ERR("Operation requires %#x access, but volume only has %#x.\n",
+                required_access, texture->resource.access_flags);
+        return FALSE;
+    }
+
+    if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
+        return FALSE;
+
+    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Volume previously discarded, nothing to do.\n");
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        goto done;
+    }
+#endif /* STAGING_CSMT */
 
     switch (location)
     {
@@ -174,7 +226,11 @@
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_volume_upload_data(texture, sub_resource_idx, context, &data);
@@ -219,7 +275,11 @@
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -242,6 +302,9 @@
             return FALSE;
     }
 
+#if !defined(STAGING_CSMT)
+done:
+#endif /* STAGING_CSMT */
     wined3d_texture_validate_location(texture, sub_resource_idx, location);
 
     return TRUE;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -90,7 +90,9 @@
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
     TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -332,6 +334,7 @@
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if defined(STAGING_CSMT)
         if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
                 && !strcmp(buffer,"disabled"))
         {
@@ -342,6 +345,9 @@
 
     FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
         wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#else  /* STAGING_CSMT */
+    }
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -31,7 +31,9 @@
 #define WINE_GLAPI
 #endif
 
+#if defined(STAGING_CSMT)
 #include <assert.h>
+#endif /* STAGING_CSMT */
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -310,7 +312,9 @@
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
     BOOL cs_multithreaded;
+#endif /* STAGING_CSMT */
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1310,8 +1314,10 @@
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
     DWORD samples;
     BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1347,6 +1353,7 @@
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
     UINT64 timestamp;
 };
 
@@ -1382,6 +1389,12 @@
     for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
         dst->render_targets[i] = src->render_targets[i];
 }
+#else  /* STAGING_CSMT */
+};
+
+void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_context
 {
@@ -1397,7 +1410,9 @@
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state current_fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_swapchain *swapchain;
     struct
@@ -1505,6 +1520,14 @@
     GLuint                  dummy_arbfp_prog;
 };
 
+#if !defined(STAGING_CSMT)
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+};
+
+#endif /* STAGING_CSMT */
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
 
 struct StateEntry
@@ -1643,7 +1666,11 @@
 void context_alloc_occlusion_query(struct wined3d_context *context,
         struct wined3d_occlusion_query *query) DECLSPEC_HIDDEN;
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
 BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -2261,7 +2288,11 @@
 struct wined3d_state
 {
     DWORD flags;
+#if defined(STAGING_CSMT)
     struct wined3d_fb_state fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -2307,6 +2338,7 @@
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+#if defined(STAGING_CSMT)
 struct wined3d_gl_bo
 {
     GLuint name;
@@ -2315,6 +2347,7 @@
     UINT size;
 };
 
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2367,11 +2400,23 @@
     struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+#if defined(STAGING_CSMT)
     struct wined3d_rendertarget_view *auto_depth_stencil_view;
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
     struct wine_rb_tree samplers;
+#else  /* STAGING_CSMT */
+
+    struct list             resources; /* a linked list to track resources created by the device */
+    struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
+    struct wine_rb_tree samplers;
+
+    /* Render Target Support */
+    struct wined3d_fb_state fb;
+    struct wined3d_surface *onscreen_depth_stencil;
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
+#endif /* STAGING_CSMT */
 
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
@@ -2419,6 +2464,7 @@
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
 void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
 void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
@@ -2430,6 +2476,11 @@
 void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void device_delete_opengl_contexts_cs(struct wined3d_device *device,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2473,9 +2524,14 @@
     UINT depth;
     UINT size;
     DWORD priority;
+#if defined(STAGING_CSMT)
     void *heap_memory, *map_heap_memory;
     struct list resource_list_entry;
     LONG access_fence;
+#else  /* STAGING_CSMT */
+    void *heap_memory;
+    struct list resource_list_entry;
+#endif /* STAGING_CSMT */
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2501,7 +2557,9 @@
         const struct wined3d_resource_ops *resource_ops) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
 GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
@@ -2509,6 +2567,7 @@
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_resource_update_draw_binding(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 
+#if defined(STAGING_CSMT)
 static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
 {
     InterlockedIncrement(&resource->access_fence);
@@ -2524,6 +2583,7 @@
     while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
 }
 
+#endif /* STAGING_CSMT */
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
 
@@ -2581,7 +2641,9 @@
     DWORD flags;
     GLenum target;
     DWORD update_map_binding;
+#if defined(STAGING_CSMT)
     HRESULT dc_hr;
+#endif /* STAGING_CSMT */
 
     GLuint rb_multisample;
     GLuint rb_resolved;
@@ -2619,8 +2681,12 @@
 
         unsigned int map_count;
         DWORD locations;
+#if defined(STAGING_CSMT)
         struct wined3d_gl_bo *buffer, *map_buffer;
         BOOL unmap_dirtify;
+#else  /* STAGING_CSMT */
+        GLuint buffer_object;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -2671,6 +2737,7 @@
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_texture_changed(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
         void *swap_heap_memory) DECLSPEC_HIDDEN;
@@ -2681,6 +2748,13 @@
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_bo_address *data, DWORD locations, BOOL map) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
+        unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_texture_invalidate_location(struct wined3d_texture *texture,
@@ -2691,6 +2765,7 @@
         const struct wined3d_gl_info *gl_info, GLenum binding, DWORD flags) DECLSPEC_HIDDEN;
 BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 BOOL wined3d_texture_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location);
 void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx,
@@ -2706,6 +2781,15 @@
         const struct wined3d_gl_info *gl_info, GLenum binding) DECLSPEC_HIDDEN;
 void wined3d_texture_unmap_internal(struct wined3d_texture *texture,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
+        struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
+void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
+        const struct wined3d_gl_info *gl_info, GLenum binding) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, DWORD location) DECLSPEC_HIDDEN;
 
@@ -2823,7 +2907,11 @@
         unsigned int *width, unsigned int *height) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void surface_load_location(struct wined3d_surface *surface,
+#else  /* STAGING_CSMT */
+HRESULT surface_load_location(struct wined3d_surface *surface,
+#endif /* STAGING_CSMT */
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_set_compatible_renderbuffer(struct wined3d_surface *surface,
@@ -2834,9 +2922,11 @@
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
         struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -2851,12 +2941,14 @@
     GLuint name;
 };
 
+#if defined(STAGING_CSMT)
 
 HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler, BOOL from_cs) DECLSPEC_HIDDEN;
 void wined3d_sampler_destroy(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
 void wined3d_sampler_init(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
 
+#endif /* STAGING_CSMT */
 struct wined3d_vertex_declaration_element
 {
     const struct wined3d_format *format;
@@ -2885,8 +2977,10 @@
     BOOL half_float_conv_needed;
 };
 
+#if defined(STAGING_CSMT)
 void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 
+#endif /* STAGING_CSMT */
 struct wined3d_saved_states
 {
     DWORD transform[(HIGHEST_TRANSFORMSTATE >> 5) + 1];
@@ -2954,6 +3048,7 @@
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
         const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -3004,6 +3099,44 @@
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
         struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD flags) DECLSPEC_HIDDEN;
+void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
+
+enum wined3d_push_constants
+{
+    WINED3D_PUSH_CONSTANTS_VS_F,
+    WINED3D_PUSH_CONSTANTS_PS_F,
+    WINED3D_PUSH_CONSTANTS_VS_I,
+    WINED3D_PUSH_CONSTANTS_PS_I,
+    WINED3D_PUSH_CONSTANTS_VS_B,
+    WINED3D_PUSH_CONSTANTS_PS_B,
+};
+
+struct wined3d_cs_ops
+{
+    void *(*require_space)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs);
+    void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
+            unsigned int start_idx, unsigned int count, const void *constants);
+};
+
+struct wined3d_cs
+{
+    const struct wined3d_cs_ops *ops;
+    struct wined3d_device *device;
+    struct wined3d_fb_state fb;
+    struct wined3d_state state;
+
+    size_t data_size;
+    void *data;
+};
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
+void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -3052,6 +3185,7 @@
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, unsigned int start_idx,
         unsigned int count, const struct wined3d_vec4 *constants, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, unsigned int start_idx,
@@ -3119,6 +3253,14 @@
 void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+
+static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    cs->ops->push_constants(cs, p, start_idx, count, constants);
+}
+#endif /* STAGING_CSMT */
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -3133,8 +3275,12 @@
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
+#if defined(STAGING_CSMT)
     BOOL (*query_poll)(struct wined3d_query *query);
     BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
+#else  /* STAGING_CSMT */
+    HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_query
@@ -3148,12 +3294,16 @@
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+#if defined(STAGING_CSMT)
 
     LONG                     counter_main, counter_retrieved;
     struct list              poll_list_entry;
 };
 
 void wined3d_query_destroy(struct wined3d_query *query) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+};
+#endif /* STAGING_CSMT */
 
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
@@ -3180,7 +3330,9 @@
     GLenum buffer_object_usage;
     GLenum buffer_type_hint;
     DWORD flags;
+#if defined(STAGING_CSMT)
     BOOL ignore_discard;
+#endif /* STAGING_CSMT */
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -3205,6 +3357,7 @@
 BYTE *buffer_get_sysmem(struct wined3d_buffer *buffer, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
         struct wined3d_buffer *src_buffer, unsigned int src_offset, unsigned int size) DECLSPEC_HIDDEN;
 HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
@@ -3214,6 +3367,13 @@
 void buffer_create_buffer_object(struct wined3d_buffer *This,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
 void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
+        struct wined3d_buffer *src_buffer, unsigned int src_offset, unsigned int size) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
+        const struct wined3d_box *box, const void *data) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_rendertarget_view
 {
@@ -3246,8 +3406,10 @@
     return texture->sub_resources[view->sub_resource_idx].u.surface;
 }
 
+#if defined(STAGING_CSMT)
 void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
 
+#endif /* STAGING_CSMT */
 struct wined3d_shader_resource_view
 {
     LONG refcount;
@@ -3257,6 +3419,7 @@
     const struct wined3d_parent_ops *parent_ops;
 };
 
+#if defined(STAGING_CSMT)
 void wined3d_shader_resource_view_destroy_cs(struct wined3d_shader_resource_view *view) DECLSPEC_HIDDEN;
 
 struct wined3d_swapchain_ops
@@ -3264,6 +3427,12 @@
     void (*swapchain_present)(struct wined3d_swapchain *swapchain,
             const RECT *src_rect, const RECT *dst_rect, DWORD flags,
             struct wined3d_rendertarget_view *depth_stencil);
+#else  /* STAGING_CSMT */
+struct wined3d_swapchain_ops
+{
+    void (*swapchain_present)(struct wined3d_swapchain *swapchain,
+            const RECT *src_rect, const RECT *dst_rect, DWORD flags);
+#endif /* STAGING_CSMT */
     void (*swapchain_frontbuffer_updated)(struct wined3d_swapchain *swapchain);
 };
 
@@ -3299,8 +3468,10 @@
 
 void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 HRESULT swapchain_create_context_cs(struct wined3d_device *device,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
@@ -3512,7 +3683,9 @@
 void shader_generate_main(const struct wined3d_shader *shader, struct wined3d_string_buffer *buffer,
         const struct wined3d_shader_reg_maps *reg_maps, const DWORD *byte_code, void *backend_ctx) DECLSPEC_HIDDEN;
 BOOL shader_match_semantic(const char *semantic_name, enum wined3d_decl_usage usage) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
 void shader_cleanup(struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL shader_is_scalar(const struct wined3d_shader_register *reg)
 {
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2011,7 +2011,9 @@
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
     ERR("glFinish\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -2037,7 +2039,9 @@
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
     ERR("glFlush\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
