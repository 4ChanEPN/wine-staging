From 70d900c4a460e27e5b6da3de623df8fffa0b9b68 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20D=C3=B6singer?= <stefandoesinger@gmx.at>
Date: Sat, 7 May 2016 13:02:33 +0100
Subject: wined3d: Clean up textures through the command stream.

FIXME: This HeapFree stuff when creation fails is ugly.
---
 dlls/wined3d/texture.c | 82 +++++++++++++++++++++++++++-----------------------
 1 file changed, 44 insertions(+), 38 deletions(-)

diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 53dfea6..18e71ff 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -479,8 +479,9 @@ static void wined3d_texture_unload_gl_texture(struct wined3d_texture *texture)
     resource_unload(&texture->resource);
 }
 
-static void wined3d_texture_cleanup(struct wined3d_texture *texture)
+static void wined3d_texture_destroy_object(void *object)
 {
+    struct wined3d_texture *texture = object;
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
@@ -489,12 +490,6 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 
     TRACE("texture %p.\n", texture);
 
-    if (wined3d_settings.cs_multithreaded)
-    {
-        FIXME("Waiting for cs.\n");
-        texture->resource.device->cs->ops->finish(texture->resource.device->cs);
-    }
-
     for (i = 0; i < sub_count; ++i)
     {
         if (texture->sub_resources[i].buffer != texture->sub_resources[i].map_buffer)
@@ -506,7 +501,7 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 
         TRACE("Deleting buffer object %u.\n", buffer->name);
 
-        /* We may not be able to get a context in wined3d_texture_cleanup() in
+        /* We may not be able to get a context in wined3d_texture_destroy_object() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
             context = context_acquire(device, NULL);
@@ -520,9 +515,7 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 
     texture->texture_ops->texture_cleanup_sub_resources(texture);
     wined3d_texture_unload_gl_texture(texture);
-    resource_cleanup(&texture->resource);
-    if (wined3d_settings.cs_multithreaded)
-        texture->resource.device->cs->ops->finish(texture->resource.device->cs);
+    HeapFree(GetProcessHeap(), 0, texture);
 }
 
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture, struct wined3d_swapchain *swapchain)
@@ -816,6 +809,23 @@ ULONG CDECL wined3d_texture_incref(struct wined3d_texture *texture)
     return refcount;
 }
 
+static void wined3d_texture_cleanup_main(struct wined3d_texture *texture)
+{
+    struct wined3d_device *device = texture->resource.device;
+    unsigned int sub_count = texture->level_count * texture->layer_count;
+    struct wined3d_texture_sub_resource *sub_resource;
+    unsigned int i;
+
+    for (i = 0; i < sub_count; ++i) {
+        sub_resource = &texture->sub_resources[i];
+        if (sub_resource->parent_ops && sub_resource->parent)
+            sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
+    }
+
+    resource_cleanup(&texture->resource);
+    wined3d_cs_emit_destroy_object(device->cs, wined3d_texture_destroy_object, texture);
+}
+
 ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 {
     ULONG refcount;
@@ -830,9 +840,8 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 
     if (!refcount)
     {
-        wined3d_texture_cleanup(texture);
         texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
-        HeapFree(GetProcessHeap(), 0, texture);
+        wined3d_texture_cleanup_main(texture);
     }
 
     return refcount;
@@ -1546,8 +1555,6 @@ static void texture2d_cleanup_sub_resources(struct wined3d_texture *texture)
             list_remove(&overlay->overlay_entry);
             overlay->overlay_dest = NULL;
         }
-
-        sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
     }
     if (context)
         context_release(context);
@@ -1947,6 +1954,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             && !gl_info->supported[EXT_TEXTURE_ARRAY])
     {
         WARN("OpenGL implementation does not support array textures.\n");
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1955,6 +1963,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1977,6 +1986,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             if (desc->pool != WINED3D_POOL_SCRATCH)
             {
                 WARN("Attempted to create a mipmapped/cube/array NPOT texture without unconditional NPOT support.\n");
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
 
@@ -1994,6 +2004,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             {
                 FIXME("Compressed or height scaled non-power-of-two (%ux%u) textures are not supported.\n",
                         desc->width, desc->height);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_NOTAVAILABLE;
             }
 
@@ -2025,6 +2036,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (desc->pool == WINED3D_POOL_DEFAULT || desc->pool == WINED3D_POOL_MANAGED)
         {
             WARN("Dimensions (%ux%u) exceed the maximum texture size.\n", pow2_width, pow2_height);
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_NOTAVAILABLE;
         }
 
@@ -2038,12 +2050,14 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (level_count != 1)
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2052,6 +2066,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -2093,7 +2108,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (level_count > ~(SIZE_T)0 / layer_count
             || !(surfaces = wined3d_calloc(level_count * layer_count, sizeof(*surfaces))))
     {
-        wined3d_texture_cleanup(texture);
+        wined3d_texture_cleanup_main(texture);
         return E_OUTOFMEMORY;
     }
 
@@ -2136,7 +2151,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                     texture, idx, &sub_resource->parent, &sub_resource->parent_ops)))
             {
                 WARN("Failed to create surface parent, hr %#x.\n", hr);
-                wined3d_texture_cleanup(texture);
+                wined3d_texture_cleanup_main(texture);
                 return hr;
             }
 
@@ -2147,7 +2162,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
                     && FAILED(hr = wined3d_surface_create_dc(surface)))
             {
-                wined3d_texture_cleanup(texture);
+                wined3d_texture_cleanup_main(texture);
                 return hr;
             }
         }
@@ -2215,21 +2230,6 @@ static void texture3d_prepare_texture(struct wined3d_texture *texture, struct wi
 
 static void texture3d_cleanup_sub_resources(struct wined3d_texture *texture)
 {
-    unsigned int sub_count = texture->level_count * texture->layer_count;
-    struct wined3d_texture_sub_resource *sub_resource;
-    struct wined3d_volume *volume;
-    unsigned int i;
-
-    for (i = 0; i < sub_count; ++i)
-    {
-        sub_resource = &texture->sub_resources[i];
-        if ((volume = sub_resource->u.volume))
-        {
-            TRACE("volume %p.\n", volume);
-
-            sub_resource->parent_ops->wined3d_object_destroyed(sub_resource->parent);
-        }
-    }
     HeapFree(GetProcessHeap(), 0, texture->sub_resources[0].u.volume);
 }
 
@@ -2283,6 +2283,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (layer_count != 1)
     {
         ERR("Invalid layer count for volume texture.\n");
+        HeapFree(GetProcessHeap(), 0, texture);
         return E_INVALIDARG;
     }
 
@@ -2291,12 +2292,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2306,12 +2309,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (level_count != 1)
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -2320,6 +2325,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             || desc->pool == WINED3D_POOL_SCRATCH))
     {
         WARN("Attempted to create a DYNAMIC texture in pool %s.\n", debug_d3dpool(desc->pool));
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -2346,6 +2352,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -2355,6 +2362,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             0, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -2373,7 +2381,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
 
     if (!(volumes = wined3d_calloc(level_count, sizeof(*volumes))))
     {
-        wined3d_texture_cleanup(texture);
+        wined3d_texture_cleanup_main(texture);
         return E_OUTOFMEMORY;
     }
 
@@ -2395,7 +2403,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
                 texture, i, &sub_resource->parent, &sub_resource->parent_ops)))
         {
             WARN("Failed to create volume parent, hr %#x.\n", hr);
-            wined3d_texture_cleanup(texture);
+            wined3d_texture_cleanup_main(texture);
             return hr;
         }
 
@@ -2692,7 +2700,6 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         return hr;
     }
 
@@ -2700,8 +2707,7 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
      * in this case. */
     if (data && FAILED(hr = wined3d_texture_upload_data(object, data)))
     {
-        wined3d_texture_cleanup(object);
-        HeapFree(GetProcessHeap(), 0, object);
+        wined3d_texture_cleanup_main(object);
         return hr;
     }
 
-- 
2.8.0

