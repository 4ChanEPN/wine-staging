From e1e98fc97f883a0ed00d7475bc2131df7d46c224 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20D=C3=B6singer?= <stefan@codeweavers.com>
Date: Sun, 17 Nov 2013 20:33:17 +0100
Subject: wined3d: Replace surface_load_location with resource_load_location.

FIXME: Check if this patch is complete enough to make sense.
---
 dlls/wined3d/context.c         |   2 +-
 dlls/wined3d/device.c          |   4 +-
 dlls/wined3d/drawprim.c        |   2 +-
 dlls/wined3d/surface.c         | 113 +++++++++++++----------------------------
 dlls/wined3d/swapchain.c       |   8 +--
 dlls/wined3d/texture.c         |   2 +-
 dlls/wined3d/wined3d_private.h |   2 -
 7 files changed, 45 insertions(+), 88 deletions(-)

diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 9408cd9..0d9de90 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -2293,7 +2293,7 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
-    surface_load_location(context->current_rt, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_load_location(&context->current_rt->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index d34aa4e..5e02b97 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -324,7 +324,7 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
         if (rt && rt->resource.format->id != WINED3DFMT_NULL)
         {
             if (flags & WINED3DCLEAR_TARGET && !is_full_clear(target, draw_rect, clear_rect))
-                surface_load_location(rt, context, rt->container->resource.draw_binding);
+                wined3d_resource_load_location(&rt->resource, context, rt->container->resource.draw_binding);
             else
                 wined3d_surface_prepare(rt, context, rt->container->resource.draw_binding);
         }
@@ -4116,7 +4116,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
             && src_rect.bottom == sub_resource->height)
         wined3d_texture_prepare_texture(texture, context, FALSE);
     else
-        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
 
     wined3d_surface_upload_data(surface, gl_info, resource->format,
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
index 9ba6ef7..0afeff9 100644
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -627,7 +627,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         {
             if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
             {
-                surface_load_location(target, context, target->container->resource.draw_binding);
+                wined3d_resource_load_location(&target->resource, context, target->container->resource.draw_binding);
                 wined3d_resource_invalidate_location(&target->resource, ~target->container->resource.draw_binding);
             }
             else
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 151dcd0..9987919 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -735,7 +735,7 @@ static void surface_unmap(struct wined3d_surface *surface)
 
         if (device->d3d_initialized)
             context = context_acquire(device, surface);
-        surface_load_location(surface, context, surface->container->resource.draw_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->container->resource.draw_binding);
         if (context)
             context_release(context);
     }
@@ -801,9 +801,9 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
 
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
-    surface_load_location(src_surface, context, src_location);
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
-        surface_load_location(dst_surface, context, dst_location);
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
     else
         wined3d_surface_prepare(dst_surface, context, dst_location);
 
@@ -894,9 +894,9 @@ static void surface_blt_fbo(const struct wined3d_device *device,
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
-    surface_load_location(src_surface, old_ctx, src_location);
+    wined3d_resource_load_location(&src_surface->resource, old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
-        surface_load_location(dst_surface, old_ctx, dst_location);
+        wined3d_resource_load_location(&dst_surface->resource, old_ctx, dst_location);
     else
         wined3d_surface_prepare(dst_surface, old_ctx, dst_location);
 
@@ -1148,7 +1148,7 @@ static void surface_unload(struct wined3d_resource *resource)
     else
     {
         surface_prepare_map_memory(surface);
-        surface_load_location(surface, context, surface->resource.map_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
     }
 
@@ -1206,24 +1206,6 @@ static void wined3d_surface_location_invalidated(struct wined3d_resource *resour
         wined3d_texture_set_dirty(surface->container);
 }
 
-/* Context activation is done by the caller. */
-static void wined3d_surface_load_location(struct wined3d_resource *resource,
-        struct wined3d_context *context, DWORD location)
-{
-    ERR("Not yet implemented.\n");
-}
-
-static const struct wined3d_resource_ops surface_resource_ops =
-{
-    surface_resource_incref,
-    surface_resource_decref,
-    surface_unload,
-    surface_resource_sub_resource_map,
-    surface_resource_sub_resource_unmap,
-    wined3d_surface_location_invalidated,
-    wined3d_surface_load_location,
-};
-
 static const struct wined3d_surface_ops surface_ops =
 {
     surface_private_setup,
@@ -1683,7 +1665,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_surface->container, context, FALSE);
     else
-        surface_load_location(dst_surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&dst_surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind_and_dirtify(dst_surface->container, context, FALSE);
 
     surface_get_memory(src_surface, &data, src_surface->resource.locations);
@@ -1816,7 +1798,7 @@ void surface_load(struct wined3d_surface *surface, struct wined3d_context *conte
     }
     TRACE("Reloading because surface is dirty.\n");
 
-    surface_load_location(surface, context, location);
+    wined3d_resource_load_location(&surface->resource, context, location);
     surface_evict_sysmem(surface);
 }
 
@@ -2690,7 +2672,7 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
 
         if (surface->resource.device->d3d_initialized)
             context = context_acquire(surface->resource.device, NULL);
-        surface_load_location(surface, context, surface->resource.map_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         if (context)
             context_release(context);
     }
@@ -2805,7 +2787,7 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
             surface->resource.map_binding = WINED3D_LOCATION_DIB;
     }
 
-    surface_load_location(surface, context, WINED3D_LOCATION_DIB);
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_DIB);
     wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DIB);
 
     if (context)
@@ -2854,7 +2836,7 @@ HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
         if (device->d3d_initialized)
             context = context_acquire(device, NULL);
 
-        surface_load_location(surface, context, surface->resource.map_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_DIB);
         if (context)
             context_release(context);
@@ -3491,8 +3473,8 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     gl_info = context->gl_info;
 
     /* Make sure the surface is up-to-date. This should probably use
-     * surface_load_location() and worry about the destination surface too,
-     * unless we're overwriting it completely. */
+     * wined3d_resource_load_location() and worry about the destination
+     * surface too, unless we're overwriting it completely. */
     wined3d_texture_load(src_surface->container, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -3912,29 +3894,6 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
     surface->ds_current_size.cy = surface->resource.height;
 }
 
-static DWORD surface_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_DIB:
-        case WINED3D_LOCATION_BUFFER:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_DRAWABLE:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_RB_MULTISAMPLE:
-        case WINED3D_LOCATION_RB_RESOLVED:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
-}
-
 static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
 {
     struct wined3d_device *device = surface->resource.device;
@@ -3984,7 +3943,7 @@ static void surface_load_sysmem(struct wined3d_surface *surface,
     }
 
     if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
-        surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
 
     /* Download the surface to system memory. */
     if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
@@ -4020,7 +3979,7 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
-    surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     surface_blt_to_drawable(surface->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
@@ -4093,7 +4052,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             /* Performance warning... */
             FIXME("Downloading RGB surface %p to reload it as sRGB.\n", surface);
             surface_prepare_map_memory(surface);
-            surface_load_location(surface, context, surface->resource.map_binding);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
     else
@@ -4104,7 +4063,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             /* Performance warning... */
             FIXME("Downloading sRGB surface %p to reload it as RGB.\n", surface);
             surface_prepare_map_memory(surface);
-            surface_load_location(surface, context, surface->resource.map_binding);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
 
@@ -4113,7 +4072,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
         surface_prepare_system_memory(surface);
-        surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_SYSMEM);
     }
 
     wined3d_texture_prepare_texture(texture, context, srgb);
@@ -4139,7 +4098,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
         surface_prepare_map_memory(surface);
-        surface_load_location(surface, context, surface->resource.map_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         surface_remove_pbo(surface, gl_info);
     }
 
@@ -4214,9 +4173,11 @@ static void surface_load_renderbuffer(struct wined3d_surface *surface, struct wi
             surface, src_location, &rect, surface, dst_location, &rect);
 }
 
-/* Context activation is done by the caller. Context may be NULL in ddraw-only mode. */
-void surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
+/* Context activation is done by the caller. */
+static void wined3d_surface_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
 {
+    struct wined3d_surface *surface = surface_from_resource(resource);
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
@@ -4243,20 +4204,6 @@ void surface_load_location(struct wined3d_surface *surface, struct wined3d_conte
         }
     }
 
-    if (surface->resource.locations & location)
-    {
-        TRACE("Location already up to date.\n");
-        return;
-    }
-
-    if (WARN_ON(d3d_surface))
-    {
-        DWORD required_access = surface_access_from_location(location);
-        if ((surface->resource.access_flags & required_access) != required_access)
-            WARN("Operation requires %#x access, but surface only has %#x.\n",
-                    required_access, surface->resource.access_flags);
-    }
-
     if (!surface->resource.locations)
     {
         ERR("Surface %p does not have any up to date location.\n", surface);
@@ -5411,7 +5358,8 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                         if (!wined3d_resource_is_offscreen(&dst_surface->container->resource))
                         {
                             struct wined3d_context *context = context_acquire(device, dst_surface);
-                            surface_load_location(dst_surface, context, dst_surface->container->resource.draw_binding);
+                            wined3d_resource_load_location(&dst_surface->resource, context,
+                                    dst_surface->container->resource.draw_binding);
                             context_release(context);
                         }
                         return WINED3D_OK;
@@ -5481,6 +5429,17 @@ cpu:
     return surface_cpu_blt(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
 }
 
+static const struct wined3d_resource_ops surface_resource_ops =
+{
+    surface_resource_incref,
+    surface_resource_decref,
+    surface_unload,
+    surface_resource_sub_resource_map,
+    surface_resource_sub_resource_unmap,
+    wined3d_surface_location_invalidated,
+    wined3d_surface_load_location,
+};
+
 static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_texture *container,
         const struct wined3d_resource_desc *desc, GLenum target, unsigned int level, unsigned int layer, DWORD flags)
 {
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 4009dac..346129e 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -315,7 +315,7 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (backbuffer->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
-            surface_load_location(backbuffer, context, location);
+            wined3d_resource_load_location(&backbuffer->resource, context, location);
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, backbuffer, NULL, location);
@@ -525,14 +525,14 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
-        surface_load_location(back_buffer, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&back_buffer->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
         wined3d_resource_invalidate_location(&back_buffer->resource, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
         swapchain_update_draw_bindings(swapchain);
     }
     else
     {
-        surface_load_location(back_buffer, context, back_buffer->container->resource.draw_binding);
+        wined3d_resource_load_location(&back_buffer->resource, context, back_buffer->container->resource.draw_binding);
     }
 
     if (swapchain->render_to_fbo)
@@ -625,7 +625,7 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 
     TRACE("Copying surface %p to screen.\n", front);
 
-    surface_load_location(front, NULL, WINED3D_LOCATION_DIB);
+    wined3d_resource_load_location(&front->resource, NULL, WINED3D_LOCATION_DIB);
 
     src_dc = front->hDC;
     window = swapchain->win_handle;
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 2c768a0..36c32e0 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -774,7 +774,7 @@ static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub
 
     surface_prepare_map_memory(surface);
     context = context_acquire(surface->resource.device, NULL);
-    surface_load_location(surface, context, surface->resource.map_binding);
+    wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
     context_release(context);
     wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
 }
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 0866451..f3c47ec 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2494,8 +2494,6 @@ void surface_load_ds_location(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
-void surface_load_location(struct wined3d_surface *surface,
-        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void wined3d_surface_prepare(struct wined3d_surface *surface, struct wined3d_context *context,
         DWORD location) DECLSPEC_HIDDEN;
-- 
2.7.0

