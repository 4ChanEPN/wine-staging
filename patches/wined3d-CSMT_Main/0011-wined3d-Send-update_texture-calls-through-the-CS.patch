From a8f6de27d548772a55d15580bdab50b3658628d7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20D=C3=B6singer?= <stefan@codeweavers.com>
Date: Thu, 1 Aug 2013 00:33:48 +0200
Subject: wined3d: Send update_texture calls through the CS

FIXME: This logic duplication is ugly.
---
 dlls/wined3d/cs.c              |  37 ++++++++
 dlls/wined3d/device.c          | 190 +++++++++++++++++++++++------------------
 dlls/wined3d/wined3d_private.h |   4 +
 3 files changed, 147 insertions(+), 84 deletions(-)

diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index 1b9c199e91..b6c56ca164 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -68,6 +68,7 @@ enum wined3d_cs_op
     WINED3D_CS_OP_BLT_SUB_RESOURCE,
     WINED3D_CS_OP_UPDATE_SUB_RESOURCE,
     WINED3D_CS_OP_PUSH_CONSTANTS,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
 };
 
 struct wined3d_cs_sync
@@ -394,6 +395,12 @@ struct wined3d_cs_push_constants
     BYTE constants[1];
 };
 
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
 static void wined3d_cs_exec_sync(struct wined3d_cs *cs, const void *data)
 {
 }
@@ -2078,6 +2085,35 @@ void wined3d_cs_emit_push_constants(struct wined3d_cs *cs, enum wined3d_push_con
     cs->ops->submit(cs);
 }
 
+static void wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL, 0);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_release(&op->src->resource);
+    wined3d_resource_release(&op->dst->resource);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_acquire(&op->src->resource);
+    wined3d_resource_acquire(&op->dst->resource);
+
+    cs->ops->submit(cs);
+}
+
 static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
     /* WINED3D_CS_OP_SYNC                       */ wined3d_cs_exec_sync,
@@ -2122,6 +2158,7 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_BLT_SUB_RESOURCE           */ wined3d_cs_exec_blt_sub_resource,
     /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
     /* WINED3D_CS_OP_PUSH_CONSTANTS             */ wined3d_cs_exec_push_constants,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
 };
 
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 62ea164dfd..5bd7f1075d 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -3656,28 +3656,17 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
-static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+/* Context activation is done by the caller. */
+static void wined3d_device_update_texture_3d(struct wined3d_context *context,
         struct wined3d_texture *src_texture, unsigned int src_level,
         struct wined3d_texture *dst_texture, unsigned int level_count)
 {
     struct wined3d_const_bo_address data;
-    struct wined3d_context *context;
     struct wined3d_map_desc src;
-    HRESULT hr = WINED3D_OK;
     unsigned int i;
 
-    TRACE("device %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
-            device, src_texture, src_level, dst_texture, level_count);
-
-    if (wined3d_texture_get_level_width(src_texture, src_level) != dst_texture->resource.width
-            || wined3d_texture_get_level_height(src_texture, src_level) != dst_texture->resource.height
-            || wined3d_texture_get_level_depth(src_texture, src_level) != dst_texture->resource.depth)
-    {
-        WARN("Source and destination dimensions do not match.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    context = context_acquire(device, NULL, 0);
+    TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            context, src_texture, src_level, dst_texture, level_count);
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3685,81 +3674,34 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 
     for (i = 0; i < level_count; ++i)
     {
-        if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
+        if (FAILED(wined3d_resource_map(&src_texture->resource,
                 src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
-            goto done;
+            return;
 
         data.buffer_object = 0;
         data.addr = src.data;
         wined3d_texture_upload_data(dst_texture, i, context, NULL, &data, src.row_pitch, src.slice_pitch);
         wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
 
-        if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
-            goto done;
+        if (FAILED(wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            return;
     }
-
-done:
-    context_release(context);
-    return hr;
 }
 
-HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
-        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
 {
     unsigned int src_size, dst_size, src_skip_levels = 0;
-    unsigned int layer_count, level_count, i, j;
-    enum wined3d_resource_type type;
-    HRESULT hr;
-    struct wined3d_context *context;
+    unsigned int level_count, i, j;
     RECT r;
 
-    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
-
-    /* Verify that the source and destination textures are non-NULL. */
-    if (!src_texture || !dst_texture)
-    {
-        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
-    {
-        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
-    {
-        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Verify that the source and destination textures are the same type. */
-    type = src_texture->resource.type;
-    if (dst_texture->resource.type != type)
-    {
-        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    layer_count = src_texture->layer_count;
-    if (layer_count != dst_texture->layer_count)
-    {
-        WARN("Source and destination have different layer counts.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (src_texture->resource.format != dst_texture->resource.format)
-    {
-        WARN("Source and destination formats do not match.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
     level_count = min(wined3d_texture_get_level_count(src_texture),
             wined3d_texture_get_level_count(dst_texture));
 
     src_size = max(src_texture->resource.width, src_texture->resource.height);
     dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
-    if (type == WINED3D_RTYPE_TEXTURE_3D)
+    if (dst_texture->resource.type == WINED3D_RTYPE_TEXTURE_3D)
     {
         src_size = max(src_size, src_texture->resource.depth);
         dst_size = max(dst_size, dst_texture->resource.depth);
@@ -3771,12 +3713,10 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     }
 
     /* Make sure that the destination texture is loaded. */
-    context = context_acquire(device, NULL, 0);
     wined3d_texture_load(dst_texture, context, FALSE);
-    context_release(context);
 
     /* Update every surface level of the texture. */
-    switch (type)
+    switch (dst_texture->resource.type)
     {
         case WINED3D_RTYPE_TEXTURE_2D:
         {
@@ -3785,12 +3725,13 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             struct wined3d_surface *src_surface;
             struct wined3d_surface *dst_surface;
 
-            for (i = 0; i < layer_count; ++i)
+            for (i = 0; i < src_texture->layer_count; ++i)
             {
                 for (j = 0; j < level_count; ++j)
                 {
                     unsigned int src_sub_resource_idx = i * src_levels + j + src_skip_levels;
                     unsigned int dst_sub_resource_idx = i * dst_levels + j;
+                    HRESULT hr;
 
                     /* Use wined3d_texture_blt() instead of uploading directly if we need conversion. */
                     if (dst_texture->resource.format->convert
@@ -3802,7 +3743,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
                                 src_texture, src_sub_resource_idx, &r, 0, NULL, WINED3D_TEXF_POINT)))
                         {
                             WARN("Failed to update surface, hr %#x.\n", hr);
-                            return hr;
+                            return;
                         }
                         continue;
                     }
@@ -3812,25 +3753,106 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
                     if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
                     {
                         WARN("Failed to update surface, hr %#x.\n", hr);
-                        return hr;
+                        return;
                     }
                 }
             }
-            return WINED3D_OK;
+            break;
         }
 
         case WINED3D_RTYPE_TEXTURE_3D:
-            if (FAILED(hr = wined3d_device_update_texture_3d(device,
-                    src_texture, src_skip_levels, dst_texture, level_count)))
-                WARN("Failed to update 3D texture, hr %#x.\n", hr);
-            return hr;
+            wined3d_device_update_texture_3d(context,
+                    src_texture, src_skip_levels, dst_texture, level_count);
+            break;
 
         default:
-            FIXME("Unsupported texture type %#x.\n", type);
-            return WINED3DERR_INVALIDCALL;
+            FIXME("Unsupported texture type %#x.\n", dst_texture->resource.type);
     }
 }
 
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int layer_count;
+    enum wined3d_resource_type type;
+
+    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
+
+    /* Verify that the source and destination textures are non-NULL. */
+    if (!src_texture || !dst_texture)
+    {
+        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+    {
+        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
+    {
+        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Verify that the source and destination textures are the same type. */
+    type = src_texture->resource.type;
+    if (dst_texture->resource.type != type)
+    {
+        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    layer_count = src_texture->layer_count;
+    if (layer_count != dst_texture->layer_count)
+    {
+        WARN("Source and destination have different layer counts.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    switch (type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+            break;
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            src_size = max(src_texture->resource.width, src_texture->resource.height);
+            src_size = max(src_size, src_texture->resource.depth);
+            dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+            dst_size = max(dst_size, dst_texture->resource.depth);
+
+            while (src_size > dst_size)
+            {
+                src_size >>= 1;
+                ++src_skip_levels;
+            }
+
+            if (wined3d_texture_get_level_width(src_texture, src_skip_levels) != dst_texture->resource.width
+                    || wined3d_texture_get_level_height(src_texture, src_skip_levels) != dst_texture->resource.height
+                    || wined3d_texture_get_level_depth(src_texture, src_skip_levels) != dst_texture->resource.depth)
+            {
+                WARN("Source and destination dimensions do not match.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+            break;
+
+        default:
+            break;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
+    return WINED3D_OK;
+}
+
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
 {
     const struct wined3d_state *state = &device->state;
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 04f2fdf1b8..e021012dac 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2725,6 +2725,8 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -3313,6 +3315,8 @@ void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resou
 void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
         unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
         unsigned int slice_pitch) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
 void wined3d_cs_init_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
-- 
2.11.0

