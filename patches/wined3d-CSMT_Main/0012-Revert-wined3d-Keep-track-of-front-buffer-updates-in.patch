From c5c6d38be8d73ef6b217cd836c8bc579e731b809 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 6 Mar 2016 22:08:51 +0100
Subject: Revert "wined3d: Keep track of front buffer updates in the
 swapchain."

This reverts commit 29c27b9bab922a485e02ad816a5e34802c1f4227.
---
 dlls/wined3d/surface.c         | 56 +++++++++++++++++++-----------------------
 dlls/wined3d/wined3d_private.h |  3 ++-
 2 files changed, 27 insertions(+), 32 deletions(-)

diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 1acc3b6..ee6588e 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -677,10 +677,11 @@ static void surface_unmap(struct wined3d_surface *surface)
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
-    struct wined3d_texture *texture;
 
     TRACE("surface %p.\n", surface);
 
+    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
+
     switch (surface->resource.map_binding)
     {
         case WINED3D_LOCATION_SYSMEM:
@@ -709,15 +710,13 @@ static void surface_unmap(struct wined3d_surface *surface)
         return;
     }
 
-    texture = surface->container;
-    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    if (surface->container->swapchain && surface->container->swapchain->front_buffer == surface->container)
     {
         context = context_acquire(device, surface);
-        surface_load_location(surface, context, texture->resource.draw_binding);
+        surface_load_location(surface, context, surface->container->resource.draw_binding);
         context_release(context);
-        memset(&texture->swapchain->front_buffer_update, 0, sizeof(texture->swapchain->front_buffer_update));
     }
-    else if (texture->resource.format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
+    else if (surface->container->resource.format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
         FIXME("Depth / stencil buffer locking is not implemented.\n");
 }
 
@@ -1261,15 +1260,13 @@ static HRESULT gdi_surface_private_setup(struct wined3d_surface *surface)
 
 static void gdi_surface_unmap(struct wined3d_surface *surface)
 {
-    struct wined3d_texture *texture = surface->container;
-
     TRACE("surface %p.\n", surface);
 
     /* Tell the swapchain to update the screen. */
-    if (texture->swapchain && texture == texture->swapchain->front_buffer)
-        x11_copy_to_screen(texture->swapchain, &texture->swapchain->front_buffer_update);
+    if (surface->container->swapchain && surface->container == surface->container->swapchain->front_buffer)
+        x11_copy_to_screen(surface->container->swapchain, &surface->lockedRect);
 
-    memset(&texture->swapchain->front_buffer_update, 0, sizeof(texture->swapchain->front_buffer_update));
+    memset(&surface->lockedRect, 0, sizeof(RECT));
 }
 
 static const struct wined3d_surface_ops gdi_surface_ops =
@@ -2256,10 +2253,9 @@ HRESULT wined3d_surface_unmap(struct wined3d_surface *surface)
 HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_desc *map_desc,
         const struct wined3d_box *box, DWORD flags)
 {
-    struct wined3d_texture *texture = surface->container;
-    const struct wined3d_format *format = texture->resource.format;
-    struct wined3d_device *device = texture->resource.device;
-    unsigned int fmt_flags = texture->resource.format_flags;
+    const struct wined3d_format *format = surface->resource.format;
+    unsigned int fmt_flags = surface->container->resource.format_flags;
+    struct wined3d_device *device = surface->resource.device;
     struct wined3d_context *context;
     const struct wined3d_gl_info *gl_info;
     BYTE *base_memory;
@@ -2274,7 +2270,7 @@ HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_
     }
 
     if ((fmt_flags & WINED3DFMT_FLAG_BLOCKS) && box
-            && !wined3d_texture_check_block_align(texture, surface->texture_level, box))
+            && !wined3d_texture_check_block_align(surface->container, surface->texture_level, box))
     {
         WARN("Map box %s is misaligned for %ux%u blocks.\n",
                 debug_box(box), format->block_width, format->block_height);
@@ -2293,13 +2289,13 @@ HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_
      * the need to download the surface from OpenGL all the time. The surface
      * is still downloaded if the OpenGL texture is changed. Note that this
      * only really makes sense for managed textures.*/
-    if (!(texture->flags & WINED3D_TEXTURE_DYNAMIC_MAP)
+    if (!(surface->container->flags & WINED3D_TEXTURE_DYNAMIC_MAP)
             && surface->resource.map_binding == WINED3D_LOCATION_SYSMEM)
     {
         if (++surface->lockCount > MAXLOCKCOUNT)
         {
             TRACE("Surface is mapped regularly, not freeing the system memory copy any more.\n");
-            texture->flags |= WINED3D_TEXTURE_DYNAMIC_MAP;
+            surface->container->flags |= WINED3D_TEXTURE_DYNAMIC_MAP;
         }
     }
 
@@ -2334,7 +2330,7 @@ HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_
             break;
 
         case WINED3D_LOCATION_USER_MEMORY:
-            base_memory = texture->user_memory;
+            base_memory = surface->container->user_memory;
             break;
 
         case WINED3D_LOCATION_DIB:
@@ -2365,13 +2361,17 @@ HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_
     }
     else
     {
-        wined3d_texture_get_pitch(texture, surface->texture_level,
+        wined3d_texture_get_pitch(surface->container, surface->texture_level,
                 &map_desc->row_pitch, &map_desc->slice_pitch);
     }
 
     if (!box)
     {
         map_desc->data = base_memory;
+        surface->lockedRect.left = 0;
+        surface->lockedRect.top = 0;
+        surface->lockedRect.right = surface->resource.width;
+        surface->lockedRect.bottom = surface->resource.height;
     }
     else
     {
@@ -2389,19 +2389,13 @@ HRESULT wined3d_surface_map(struct wined3d_surface *surface, struct wined3d_map_
                     + (map_desc->row_pitch * box->top)
                     + (box->left * format->byte_count);
         }
+        surface->lockedRect.left = box->left;
+        surface->lockedRect.top = box->top;
+        surface->lockedRect.right = box->right;
+        surface->lockedRect.bottom = box->bottom;
     }
 
-    if (texture->swapchain && texture->swapchain->front_buffer == texture)
-    {
-        RECT *r = &texture->swapchain->front_buffer_update;
-
-        if (!box)
-            SetRect(r, 0, 0, texture->resource.width, texture->resource.height);
-        else
-            SetRect(r, box->left, box->top, box->right, box->bottom);
-        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
-    }
-
+    TRACE("Locked rect %s.\n", wine_dbgstr_rect(&surface->lockedRect));
     TRACE("Returning memory %p, pitch %u.\n", map_desc->data, map_desc->row_pitch);
 
     return WINED3D_OK;
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 4066c79..409ab36 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2522,6 +2522,8 @@ struct wined3d_surface
     GLenum texture_target;
     unsigned int texture_level;
     unsigned int texture_layer;
+
+    RECT                      lockedRect;
     int                       lockCount;
 
     /* For GetDC */
@@ -2934,7 +2936,6 @@ struct wined3d_swapchain
     BOOL render_to_fbo, reapply_mode;
     const struct wined3d_format *ds_format;
     struct wined3d_palette *palette;
-    RECT front_buffer_update;
 
     LONG prev_time, frames;   /* Performance tracking */
 
-- 
2.7.1

