From 59212bd36e71d8a997dd86efbf0f1cdd38952dc4 Mon Sep 17 00:00:00 2001
From: Amine Khaldi <amine.khaldi@reactos.org>
Date: Sat, 28 Feb 2015 09:22:59 +0100
Subject: include: Correct DDSCAPS2 and DDSURFACEDESC2 structures and their
 uses.

---
 dlls/ddraw/ddraw.c        |  4 ++--
 dlls/ddraw/device.c       |  2 +-
 dlls/ddraw/surface.c      | 24 ++++++++++++------------
 dlls/ddraw/tests/ddraw4.c | 16 ++++++++--------
 dlls/ddraw/tests/ddraw7.c | 18 +++++++++---------
 dlls/ddraw/utils.c        | 10 +++++-----
 dlls/ddrawex/ddraw.c      |  4 ++--
 dlls/dxdiagn/provider.c   |  4 ++--
 include/ddraw.h           | 10 ++++++++--
 9 files changed, 49 insertions(+), 43 deletions(-)

diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index fcbc3bf..02b2f6e 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -1438,7 +1438,7 @@ static HRESULT WINAPI ddraw7_GetCaps(IDirectDraw7 *iface, DDCAPS *DriverCaps, DD
     DDCAPS caps;
     WINED3DCAPS winecaps;
     HRESULT hr;
-    DDSCAPS2 ddscaps = {0, 0, 0, 0};
+    DDSCAPS2 ddscaps = {0, 0, 0, {0}};
 
     TRACE("iface %p, driver_caps %p, hel_caps %p.\n", iface, DriverCaps, HELCaps);
 
@@ -3010,7 +3010,7 @@ static BOOL ddraw_match_surface_desc(const DDSURFACEDESC2 *requested, const DDSU
     static const struct compare_info compare[] =
     {
         CMP(ALPHABITDEPTH, dwAlphaBitDepth),
-        CMP(BACKBUFFERCOUNT, dwBackBufferCount),
+        CMP(BACKBUFFERCOUNT, u5.dwBackBufferCount),
         CMP(CAPS, ddsCaps),
         CMP(CKDESTBLT, ddckCKDestBlt),
         CMP(CKDESTOVERLAY, u3 /* ddckCKDestOverlay */),
diff --git a/dlls/ddraw/device.c b/dlls/ddraw/device.c
index 5406fb9..f0dcf16 100644
--- a/dlls/ddraw/device.c
+++ b/dlls/ddraw/device.c
@@ -6747,7 +6747,7 @@ enum wined3d_depth_buffer_type d3d_device_update_depth_stencil(struct d3d_device
 {
     IDirectDrawSurface7 *depthStencil = NULL;
     IDirectDrawSurface7 *render_target;
-    static DDSCAPS2 depthcaps = { DDSCAPS_ZBUFFER, 0, 0, 0 };
+    static DDSCAPS2 depthcaps = { DDSCAPS_ZBUFFER, 0, 0, {0} };
     struct ddraw_surface *dsi;
 
     if (device->rt_iface && SUCCEEDED(IUnknown_QueryInterface(device->rt_iface,
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index a387d12..331d2bb 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -745,14 +745,14 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
         our_caps.dwCaps = Caps->dwCaps;
         our_caps.dwCaps2 = 0;
         our_caps.dwCaps3 = 0;
-        our_caps.dwCaps4 = 0;
+        our_caps.u1.dwCaps4 = 0;
     }
     else
     {
         our_caps = *Caps;
     }
 
-    TRACE("(%p): Looking for caps: %x,%x,%x,%x\n", This, our_caps.dwCaps, our_caps.dwCaps2, our_caps.dwCaps3, our_caps.dwCaps4); /* FIXME: Better debugging */
+    TRACE("(%p): Looking for caps: %x,%x,%x,%x\n", This, our_caps.dwCaps, our_caps.dwCaps2, our_caps.dwCaps3, our_caps.u1.dwCaps4); /* FIXME: Better debugging */
 
     for(i = 0; i < MAX_COMPLEX_ATTACHED; i++)
     {
@@ -763,7 +763,7 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
                 surf->surface_desc.ddsCaps.dwCaps,
                 surf->surface_desc.ddsCaps.dwCaps2,
                 surf->surface_desc.ddsCaps.dwCaps3,
-                surf->surface_desc.ddsCaps.dwCaps4);
+                surf->surface_desc.ddsCaps.u1.dwCaps4);
 
         if (((surf->surface_desc.ddsCaps.dwCaps & our_caps.dwCaps) == our_caps.dwCaps) &&
             ((surf->surface_desc.ddsCaps.dwCaps2 & our_caps.dwCaps2) == our_caps.dwCaps2)) {
@@ -793,7 +793,7 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
                 surf->surface_desc.ddsCaps.dwCaps,
                 surf->surface_desc.ddsCaps.dwCaps2,
                 surf->surface_desc.ddsCaps.dwCaps3,
-                surf->surface_desc.ddsCaps.dwCaps4);
+                surf->surface_desc.ddsCaps.u1.dwCaps4);
 
         if (((surf->surface_desc.ddsCaps.dwCaps & our_caps.dwCaps) == our_caps.dwCaps) &&
             ((surf->surface_desc.ddsCaps.dwCaps2 & our_caps.dwCaps2) == our_caps.dwCaps2)) {
@@ -853,7 +853,7 @@ static HRESULT WINAPI ddraw_surface3_GetAttachedSurface(IDirectDrawSurface3 *ifa
     caps2.dwCaps  = caps->dwCaps;
     caps2.dwCaps2 = 0;
     caps2.dwCaps3 = 0;
-    caps2.dwCaps4 = 0;
+    caps2.u1.dwCaps4 = 0;
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
             &caps2, &attachment7);
@@ -884,7 +884,7 @@ static HRESULT WINAPI ddraw_surface2_GetAttachedSurface(IDirectDrawSurface2 *ifa
     caps2.dwCaps  = caps->dwCaps;
     caps2.dwCaps2 = 0;
     caps2.dwCaps3 = 0;
-    caps2.dwCaps4 = 0;
+    caps2.u1.dwCaps4 = 0;
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
             &caps2, &attachment7);
@@ -915,7 +915,7 @@ static HRESULT WINAPI ddraw_surface1_GetAttachedSurface(IDirectDrawSurface *ifac
     caps2.dwCaps  = caps->dwCaps;
     caps2.dwCaps2 = 0;
     caps2.dwCaps3 = 0;
-    caps2.dwCaps4 = 0;
+    caps2.u1.dwCaps4 = 0;
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
             &caps2, &attachment7);
@@ -1214,7 +1214,7 @@ static HRESULT WINAPI ddraw_surface7_Flip(IDirectDrawSurface7 *iface, IDirectDra
     struct ddraw_surface *src_impl = unsafe_impl_from_IDirectDrawSurface7(src);
     struct wined3d_rendertarget_view *tmp_rtv, *src_rtv, *rtv;
     struct ddraw_texture *ddraw_texture, *prev_ddraw_texture;
-    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     struct wined3d_texture *texture;
     IDirectDrawSurface7 *current;
     struct wined3d_surface *tmp;
@@ -4985,7 +4985,7 @@ static HRESULT WINAPI d3d_texture1_GetHandle(IDirect3DTexture *iface,
 static struct ddraw_surface *get_sub_mimaplevel(struct ddraw_surface *surface)
 {
     /* Now go down the mipmap chain to the next surface */
-    static DDSCAPS2 mipmap_caps = { DDSCAPS_MIPMAP | DDSCAPS_TEXTURE, 0, 0, 0 };
+    static DDSCAPS2 mipmap_caps = { DDSCAPS_MIPMAP | DDSCAPS_TEXTURE, 0, 0, {0} };
     IDirectDrawSurface7 *next_level;
     HRESULT hr;
 
@@ -5652,7 +5652,7 @@ HRESULT ddraw_surface_create(struct ddraw *ddraw, const DDSURFACEDESC2 *surface_
                 return DDERR_INVALIDCAPS;
             }
 
-            if (!(desc->dwFlags & DDSD_BACKBUFFERCOUNT) || !desc->dwBackBufferCount)
+            if (!(desc->dwFlags & DDSD_BACKBUFFERCOUNT) || !desc->u5.dwBackBufferCount)
             {
                 WARN("Tried to create a flippable primary surface without any back buffers.\n");
                 HeapFree(GetProcessHeap(), 0, texture);
@@ -6079,7 +6079,7 @@ HRESULT ddraw_surface_create(struct ddraw *ddraw, const DDSURFACEDESC2 *surface_
 
     if (desc->dwFlags & DDSD_BACKBUFFERCOUNT)
     {
-        unsigned int count = desc->dwBackBufferCount;
+        unsigned int count = desc->u5.dwBackBufferCount;
         struct ddraw_surface *last = root;
 
         attach = &last->complex_array[0];
@@ -6101,7 +6101,7 @@ HRESULT ddraw_surface_create(struct ddraw *ddraw, const DDSURFACEDESC2 *surface_
                     | DDSCAPS_BACKBUFFER);
             if (!i)
                 desc->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
-            desc->dwBackBufferCount = 0;
+            desc->u5.dwBackBufferCount = 0;
 
             if (FAILED(hr = wined3d_texture_create(ddraw->wined3d_device, &wined3d_desc, 1,
                     WINED3D_SURFACE_PIN_SYSMEM, NULL, texture, &ddraw_texture_wined3d_parent_ops, &wined3d_texture)))
diff --git a/dlls/ddraw/tests/ddraw4.c b/dlls/ddraw/tests/ddraw4.c
index 16a644f..e5c808a 100644
--- a/dlls/ddraw/tests/ddraw4.c
+++ b/dlls/ddraw/tests/ddraw4.c
@@ -141,7 +141,7 @@ static void destroy_window_thread(struct create_window_thread_param *p)
 static IDirectDrawSurface4 *get_depth_stencil(IDirect3DDevice3 *device)
 {
     IDirectDrawSurface4 *rt, *ret;
-    DDSCAPS2 caps = {DDSCAPS_ZBUFFER, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_ZBUFFER, 0, 0, {0}};
     HRESULT hr;
 
     hr = IDirect3DDevice3_GetRenderTarget(device, &rt);
@@ -1921,7 +1921,7 @@ static void test_ck_default(void)
 static void test_ck_complex(void)
 {
     IDirectDrawSurface4 *surface, *mipmap, *tmp;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     IDirect3DDevice3 *device;
     DDCOLORKEY color_key;
@@ -5502,7 +5502,7 @@ static void test_flip(void)
 {
     const DWORD placement = DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY;
     IDirectDrawSurface4 *primary, *backbuffer1, *backbuffer2, *backbuffer3, *surface;
-    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     BOOL sysmem_primary;
     IDirectDraw4 *ddraw;
@@ -6122,7 +6122,7 @@ static void test_sysmem_overlay(void)
 
 static void test_primary_palette(void)
 {
-    DDSCAPS2 surface_caps = {DDSCAPS_FLIP, 0, 0, 0};
+    DDSCAPS2 surface_caps = {DDSCAPS_FLIP, 0, 0, {0}};
     IDirectDrawSurface4 *primary, *backbuffer;
     PALETTEENTRY palette_entries[256];
     IDirectDrawPalette *palette, *tmp;
@@ -6249,7 +6249,7 @@ static void test_surface_attachment(void)
 {
     IDirectDrawSurface4 *surface1, *surface2, *surface3, *surface4;
     IDirectDrawSurface *surface1v1, *surface2v1;
-    DDSCAPS2 caps = {DDSCAPS_TEXTURE, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_TEXTURE, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     IDirectDraw4 *ddraw;
     UINT surface_count;
@@ -6513,7 +6513,7 @@ static void test_private_data(void)
     DWORD size = sizeof(ptr);
     HRESULT hr;
     HWND window;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DWORD data[] = {1, 2, 3, 4};
     DDCAPS hal_caps;
     static const GUID ddraw_private_data_test_guid =
@@ -6958,7 +6958,7 @@ static void test_mipmap_lock(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDCAPS hal_caps;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
@@ -7020,7 +7020,7 @@ static void test_palette_complex(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDCAPS hal_caps;
     PALETTEENTRY palette_entries[256];
     unsigned int i;
diff --git a/dlls/ddraw/tests/ddraw7.c b/dlls/ddraw/tests/ddraw7.c
index 90ea739..c558385 100644
--- a/dlls/ddraw/tests/ddraw7.c
+++ b/dlls/ddraw/tests/ddraw7.c
@@ -155,7 +155,7 @@ static void destroy_window_thread(struct create_window_thread_param *p)
 static IDirectDrawSurface7 *get_depth_stencil(IDirect3DDevice7 *device)
 {
     IDirectDrawSurface7 *rt, *ret;
-    DDSCAPS2 caps = {DDSCAPS_ZBUFFER, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_ZBUFFER, 0, 0, {0}};
     HRESULT hr;
 
     hr = IDirect3DDevice7_GetRenderTarget(device, &rt);
@@ -1613,7 +1613,7 @@ static void test_ck_default(void)
 static void test_ck_complex(void)
 {
     IDirectDrawSurface7 *surface, *mipmap, *tmp;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     IDirect3DDevice7 *device;
     DDCOLORKEY color_key;
@@ -5343,7 +5343,7 @@ static void test_flip(void)
 {
     const DWORD placement = DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY;
     IDirectDrawSurface7 *primary, *backbuffer1, *backbuffer2, *backbuffer3, *surface;
-    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     BOOL sysmem_primary;
     IDirectDraw7 *ddraw;
@@ -5962,7 +5962,7 @@ static void test_sysmem_overlay(void)
 
 static void test_primary_palette(void)
 {
-    DDSCAPS2 surface_caps = {DDSCAPS_FLIP, 0, 0, 0};
+    DDSCAPS2 surface_caps = {DDSCAPS_FLIP, 0, 0, {0}};
     IDirectDrawSurface7 *primary, *backbuffer;
     PALETTEENTRY palette_entries[256];
     IDirectDrawPalette *palette, *tmp;
@@ -6089,7 +6089,7 @@ static void test_surface_attachment(void)
 {
     IDirectDrawSurface7 *surface1, *surface2, *surface3, *surface4;
     IDirectDrawSurface *surface1v1, *surface2v1;
-    DDSCAPS2 caps = {DDSCAPS_TEXTURE, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_TEXTURE, 0, 0, {0}};
     DDSURFACEDESC2 surface_desc;
     IDirectDraw7 *ddraw;
     UINT surface_count;
@@ -6335,7 +6335,7 @@ static void test_private_data(void)
     DWORD size = sizeof(ptr);
     HRESULT hr;
     HWND window;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DWORD data[] = {1, 2, 3, 4};
     DDCAPS hal_caps;
     static const GUID ddraw_private_data_test_guid =
@@ -6780,7 +6780,7 @@ static void test_mipmap_lock(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDCAPS hal_caps;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
@@ -6842,7 +6842,7 @@ static void test_palette_complex(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDCAPS hal_caps;
     PALETTEENTRY palette_entries[256];
     unsigned int i;
@@ -7746,7 +7746,7 @@ static void test_resource_priority(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
-    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, 0};
+    DDSCAPS2 caps = {DDSCAPS_COMPLEX, 0, 0, {0}};
     DDCAPS hal_caps;
     DWORD needed_caps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY | DDSCAPS_MIPMAP;
     unsigned int i;
diff --git a/dlls/ddraw/utils.c b/dlls/ddraw/utils.c
index ebd355b..ad271bc 100644
--- a/dlls/ddraw/utils.c
+++ b/dlls/ddraw/utils.c
@@ -686,7 +686,7 @@ DDRAW_dump_DDSCAPS(const DDSCAPS *in)
     in_bis.dwCaps = in->dwCaps;
     in_bis.dwCaps2 = 0;
     in_bis.dwCaps3 = 0;
-    in_bis.dwCaps4 = 0;
+    in_bis.u1.dwCaps4 = 0;
 
     DDRAW_dump_DDSCAPS2(&in_bis);
 }
@@ -776,7 +776,7 @@ void DDRAW_dump_surface_desc(const DDSURFACEDESC2 *lpddsd)
         ME(DDSD_WIDTH, DDRAW_dump_DWORD, dwWidth),
         ME(DDSD_PITCH, DDRAW_dump_DWORD, u1 /* lPitch */),
         ME(DDSD_LINEARSIZE, DDRAW_dump_DWORD, u1 /* dwLinearSize */),
-        ME(DDSD_BACKBUFFERCOUNT, DDRAW_dump_DWORD, dwBackBufferCount),
+        ME(DDSD_BACKBUFFERCOUNT, DDRAW_dump_DWORD, u5.dwBackBufferCount),
         ME(DDSD_MIPMAPCOUNT, DDRAW_dump_DWORD, u2 /* dwMipMapCount */),
         ME(DDSD_ZBUFFERBITDEPTH, DDRAW_dump_DWORD, u2 /* dwZBufferBitDepth */), /* This is for 'old-style' D3D */
         ME(DDSD_REFRESHRATE, DDRAW_dump_DWORD, u2 /* dwRefreshRate */),
@@ -862,7 +862,7 @@ void DDRAW_Convert_DDSCAPS_1_To_2(const DDSCAPS* pIn, DDSCAPS2* pOut)
     pOut->dwCaps = pIn->dwCaps;
     pOut->dwCaps2 = 0;
     pOut->dwCaps3 = 0;
-    pOut->dwCaps4 = 0;
+    pOut->u1.dwCaps4 = 0;
 }
 
 void DDRAW_Convert_DDDEVICEIDENTIFIER_2_To_1(const DDDEVICEIDENTIFIER2* pIn, DDDEVICEIDENTIFIER* pOut)
@@ -1147,7 +1147,7 @@ void DDSD_to_DDSD2(const DDSURFACEDESC *in, DDSURFACEDESC2 *out)
     /* ddsCaps is read even without DDSD_CAPS set. See dsurface:no_ddsd_caps_test */
     out->ddsCaps.dwCaps = in->ddsCaps.dwCaps;
     if (in->dwFlags & DDSD_PITCH) out->u1.lPitch = in->u1.lPitch;
-    if (in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->dwBackBufferCount;
+    if (in->dwFlags & DDSD_BACKBUFFERCOUNT) out->u5.dwBackBufferCount = in->dwBackBufferCount;
     if (in->dwFlags & DDSD_ALPHABITDEPTH) out->dwAlphaBitDepth = in->dwAlphaBitDepth;
     /* DDraw(native, and wine) does not set the DDSD_LPSURFACE, so always copy */
     out->lpSurface = in->lpSurface;
@@ -1188,7 +1188,7 @@ void DDSD2_to_DDSD(const DDSURFACEDESC2 *in, DDSURFACEDESC *out)
     /* ddsCaps is read even without DDSD_CAPS set. See dsurface:no_ddsd_caps_test */
     out->ddsCaps.dwCaps = in->ddsCaps.dwCaps;
     if (in->dwFlags & DDSD_PITCH) out->u1.lPitch = in->u1.lPitch;
-    if (in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->dwBackBufferCount;
+    if (in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->u5.dwBackBufferCount;
     if (in->dwFlags & DDSD_ZBUFFERBITDEPTH) out->u2.dwZBufferBitDepth = in->u2.dwMipMapCount; /* same union */
     if (in->dwFlags & DDSD_ALPHABITDEPTH) out->dwAlphaBitDepth = in->dwAlphaBitDepth;
     /* DDraw(native, and wine) does not set the DDSD_LPSURFACE, so always copy */
diff --git a/dlls/ddrawex/ddraw.c b/dlls/ddrawex/ddraw.c
index b32f726..e2df885 100644
--- a/dlls/ddrawex/ddraw.c
+++ b/dlls/ddrawex/ddraw.c
@@ -390,7 +390,7 @@ void DDSD_to_DDSD2(const DDSURFACEDESC *in, DDSURFACEDESC2 *out)
     if(in->dwFlags & DDSD_PIXELFORMAT) out->u4.ddpfPixelFormat = in->ddpfPixelFormat;
     if(in->dwFlags & DDSD_CAPS) out->ddsCaps.dwCaps = in->ddsCaps.dwCaps;
     if(in->dwFlags & DDSD_PITCH) out->u1.lPitch = in->u1.lPitch;
-    if(in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->dwBackBufferCount;
+    if(in->dwFlags & DDSD_BACKBUFFERCOUNT) out->u5.dwBackBufferCount = in->dwBackBufferCount;
     if(in->dwFlags & DDSD_ZBUFFERBITDEPTH) out->u2.dwMipMapCount = in->u2.dwZBufferBitDepth; /* same union */
     if(in->dwFlags & DDSD_ALPHABITDEPTH) out->dwAlphaBitDepth = in->dwAlphaBitDepth;
     /* DDraw(native, and wine) does not set the DDSD_LPSURFACE, so always copy */
@@ -417,7 +417,7 @@ void DDSD2_to_DDSD(const DDSURFACEDESC2 *in, DDSURFACEDESC *out)
     if(in->dwFlags & DDSD_PIXELFORMAT) out->ddpfPixelFormat = in->u4.ddpfPixelFormat;
     if(in->dwFlags & DDSD_CAPS) out->ddsCaps.dwCaps = in->ddsCaps.dwCaps;
     if(in->dwFlags & DDSD_PITCH) out->u1.lPitch = in->u1.lPitch;
-    if(in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->dwBackBufferCount;
+    if(in->dwFlags & DDSD_BACKBUFFERCOUNT) out->dwBackBufferCount = in->u5.dwBackBufferCount;
     if(in->dwFlags & DDSD_ZBUFFERBITDEPTH) out->u2.dwZBufferBitDepth = in->u2.dwMipMapCount; /* same union */
     if(in->dwFlags & DDSD_ALPHABITDEPTH) out->dwAlphaBitDepth = in->dwAlphaBitDepth;
     /* DDraw(native, and wine) does not set the DDSD_LPSURFACE, so always copy */
diff --git a/dlls/dxdiagn/provider.c b/dlls/dxdiagn/provider.c
index 451270c..5831488 100644
--- a/dlls/dxdiagn/provider.c
+++ b/dlls/dxdiagn/provider.c
@@ -856,7 +856,7 @@ static BOOL get_texture_memory(GUID *adapter, DWORD *available_mem)
     if (SUCCEEDED(hr))
     {
         dd_caps.dwCaps = DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
-        dd_caps.dwCaps2 = dd_caps.dwCaps3 = dd_caps.dwCaps4 = 0;
+        dd_caps.dwCaps2 = dd_caps.dwCaps3 = dd_caps.u1.dwCaps4 = 0;
         hr = IDirectDraw7_GetAvailableVidMem(pDirectDraw, &dd_caps, available_mem, NULL);
         IDirectDraw7_Release(pDirectDraw);
         if (SUCCEEDED(hr))
@@ -1112,7 +1112,7 @@ static HRESULT fill_display_information_fallback(IDxDiagContainerImpl_Container
         return S_OK;
 
     dd_caps.dwCaps = DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
-    dd_caps.dwCaps2 = dd_caps.dwCaps3 = dd_caps.dwCaps4 = 0;
+    dd_caps.dwCaps2 = dd_caps.dwCaps3 = dd_caps.u1.dwCaps4 = 0;
     hr = IDirectDraw7_GetAvailableVidMem(pDirectDraw, &dd_caps, &tmp, NULL);
     if (SUCCEEDED(hr))
     {
diff --git a/include/ddraw.h b/include/ddraw.h
index 22be0eb..f94abe3 100644
--- a/include/ddraw.h
+++ b/include/ddraw.h
@@ -371,7 +371,10 @@ typedef struct _DDSCAPS2 {
 	DWORD	dwCaps;	/* capabilities of surface wanted */
 	DWORD   dwCaps2; /* additional capabilities */
 	DWORD   dwCaps3; /* reserved capabilities */
-	DWORD   dwCaps4; /* more reserved capabilities */
+	union {
+		DWORD dwCaps4; /* more reserved capabilities */
+		DWORD dwVolumeDepth;
+	} DUMMYUNIONNAME1;
 } DDSCAPS2,*LPDDSCAPS2;
 
 #define	DD_ROP_SPACE	(256/32)	/* space required to store ROP array */
@@ -1001,7 +1004,10 @@ typedef struct _DDSURFACEDESC2
 		LONG	lPitch;	      /*10: distance to start of next line (return value only)*/
 		DWORD   dwLinearSize; /*10: formless late-allocated optimized surface size */
 	} DUMMYUNIONNAME1;
-	DWORD	dwBackBufferCount;/* 14: number of back buffers requested*/
+	union {
+		DWORD	dwBackBufferCount;/* 14: number of back buffers requested*/
+		DWORD	dwDepth;
+	} DUMMYUNIONNAME5;
 	union {
 		DWORD	dwMipMapCount;/* 18:number of mip-map levels requested*/
 		DWORD	dwRefreshRate;/* 18:refresh rate (used when display mode is described)*/
-- 
2.3.0

