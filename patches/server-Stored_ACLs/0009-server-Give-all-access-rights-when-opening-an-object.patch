From 32c244368e3a3d5dd4fe642af6f5c6409bea7065 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 16 Oct 2016 02:01:16 +0200
Subject: server: Give all access rights when opening an object with
 MAXIMUM_ALLOWED.

---
 dlls/advapi32/tests/security.c | 29 +++++++++++++++++++++++++++++
 server/handle.c                |  1 +
 2 files changed, 30 insertions(+)

diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
index 3c6c0ab02be..f8aa49e04ed 100644
--- a/dlls/advapi32/tests/security.c
+++ b/dlls/advapi32/tests/security.c
@@ -6016,6 +6016,34 @@ static void test_process_access(void)
     CloseHandle(process);
 }
 
+static void test_maximum_allowed(void)
+{
+    char buffer_sd[SECURITY_DESCRIPTOR_MIN_LENGTH], buffer_acl[256];
+    SECURITY_DESCRIPTOR *sd = (SECURITY_DESCRIPTOR *)&buffer_sd;
+    SECURITY_ATTRIBUTES sa;
+    ACL *acl = (ACL *)&buffer_acl;
+    ACCESS_MASK mask;
+    HANDLE handle;
+    BOOL ret;
+
+    ret = InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
+    ok(ret, "InitializeSecurityDescriptor failed with %u\n", GetLastError());
+    ret = InitializeAcl(acl, 256, ACL_REVISION);
+    ok(ret, "InitializeAcl failed with %u\n", GetLastError());
+    ret = SetSecurityDescriptorDacl(sd, TRUE, acl, FALSE);
+    ok(ret, "SetSecurityDescriptorDacl failed with %u\n", GetLastError());
+
+    sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
+    sa.lpSecurityDescriptor = sd;
+    sa.bInheritHandle       = FALSE;
+
+    handle = CreateEventExA(&sa, NULL, 0, MAXIMUM_ALLOWED | 0x4);
+    ok(handle != NULL, "CreateEventExA failed with error %u\n", GetLastError());
+    mask = get_obj_access(handle);
+    ok(mask == EVENT_ALL_ACCESS, "Expected %x, got %x\n", EVENT_ALL_ACCESS, mask);
+    CloseHandle(handle);
+}
+
 static BOOL validate_impersonation_token(HANDLE token, DWORD *token_type)
 {
     DWORD ret, needed;
@@ -6094,6 +6122,7 @@ static void test_kernel_objects_security(void)
     test_filemap_security();
     test_thread_security();
     test_process_access();
+    test_maximum_allowed();
     /* FIXME: test other kernel object types */
 
     CloseHandle(process_token);
diff --git a/server/handle.c b/server/handle.c
index 37fba69eac3..4d8d03a494c 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -273,6 +273,7 @@ obj_handle_t alloc_handle_no_access_check( struct process *process, void *ptr, u
 {
     struct object *obj = ptr;
     access = obj->ops->map_access( obj, access ) & ~RESERVED_ALL;
+    if (access & MAXIMUM_ALLOWED) access = obj->ops->map_access( obj, GENERIC_ALL );
     return alloc_handle_entry( process, ptr, access, attr );
 }
 
-- 
2.11.0

