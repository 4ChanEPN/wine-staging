From e8c77ae1630f628cf2d43049399ca99b24514548 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Sat, 31 Oct 2015 14:31:55 +0800
Subject: oleaut32/tests: Add a bunch of new tests for typelib generation.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/oleaut32/tests/test_tlb.idl |  50 +++++++++
 dlls/oleaut32/tests/typelib.c    | 237 +++++++++++++++++++++++++++++++++++----
 2 files changed, 265 insertions(+), 22 deletions(-)

diff --git a/dlls/oleaut32/tests/test_tlb.idl b/dlls/oleaut32/tests/test_tlb.idl
index 8275c37..7ae5565 100644
--- a/dlls/oleaut32/tests/test_tlb.idl
+++ b/dlls/oleaut32/tests/test_tlb.idl
@@ -2,6 +2,7 @@
  * ITypeLib test IDL - we dump it and compare results in typelib.c
  *
  * Copyright 2007 Google (Mikolaj Zalewski)
+ * Copyright 2015 Dmitry Timoshkov
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -28,6 +29,34 @@ library Test
 {
 	importlib("stdole2.tlb");
 
+	interface child_iface;
+	interface parent_iface;
+
+	[uuid(b14b6bb5-904e-4ff9-b247-bd361f7aa001)]
+	interface parent_iface : IUnknown
+	{
+		HRESULT test1([out,retval] child_iface **);
+	}
+	[uuid(b14b6bb5-904e-4ff9-b247-bd361f7aa002)]
+	interface child_iface: parent_iface
+	{
+		HRESULT test2(void);
+	}
+
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753901),restricted]
+	struct _n { int n1; };
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753902),hidden]
+	typedef struct _n n;
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753903),version(1.2),helpcontext(3)]
+	typedef struct _n nn;
+
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753904),restricted]
+	struct _m { int m1; };
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753905),hidden,version(1.2)]
+	typedef struct _m m;
+	[uuid(016fe2ec-b2c8-45f8-b23b-39e53a753906),helpcontext(3)]
+	typedef struct _m mm;
+
 	[dual,uuid(b14b6bb5-904e-4ff9-b247-bd361f7aaedd)]
 	interface IDualIface : IDispatch
 	{
@@ -59,6 +88,9 @@ library Test
 		BSTR bstr;
 	};
 
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a75396a),restricted]
+	int t_INT;
+
 	typedef [public] enum _a { a1, a2 } a;
 	typedef [public] enum aa { aa1, aa2 } aa;
 	typedef enum _b { b1, b2 } b;
@@ -66,11 +98,29 @@ library Test
 	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a75396b)] enum _c { c1, c2 } c;
 	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a75396c)] enum cc { cc1, cc2 } cc;
 
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a75396d),restricted,hidden]
+	enum _d { d1, d2 } d;
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a75396e),restricted,hidden]
+	enum dd { dd1, dd2 } dd;
+
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a753970),restricted,hidden]
+	struct _e { int e1; } e;
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a753971),restricted,hidden]
+	struct ee { int ee1; } ee;
+
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a753972),restricted,hidden]
+	union _f { int f1; BSTR *f2; } f;
+	typedef [uuid(016fe2ec-b2c8-45f8-b23b-39e53a753973),restricted,hidden]
+	union ff { int ff1; BSTR *ff2; } ff;
+
 	[uuid(ec5dfcd6-eeb0-4cd6-b51e-8030e1dac00a)]
 	interface ITestIface : IDispatch
 	{
 		HRESULT test1(a value);
 		HRESULT test2(b value);
 		HRESULT test3(c value);
+		HRESULT test4(d value);
+		HRESULT test5(e value);
+		HRESULT test6(f value);
 	}
 }
diff --git a/dlls/oleaut32/tests/typelib.c b/dlls/oleaut32/tests/typelib.c
index 1d13b89..977d7a8 100644
--- a/dlls/oleaut32/tests/typelib.c
+++ b/dlls/oleaut32/tests/typelib.c
@@ -2,7 +2,7 @@
  * ITypeLib and ITypeInfo test
  *
  * Copyright 2004 Jacek Caban
- * Copyright 2006 Dmitry Timoshkov
+ * Copyright 2006,2015 Dmitry Timoshkov
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -3862,6 +3862,10 @@ static char *print_size(BSTR name, TYPEATTR *attr)
         sprintf(buf, "sizeof(struct %s)", dump_string(name));
         break;
 
+    case TKIND_UNION:
+        sprintf(buf, "sizeof(union %s)", dump_string(name));
+        break;
+
     case TKIND_ENUM:
     case TKIND_ALIAS:
         sprintf(buf, "4");
@@ -3971,9 +3975,10 @@ static void test_dump_typelib(const char *name)
     {
         TYPEATTR *attr;
         BSTR name;
+        DWORD help_ctx;
         int f = 0;
 
-        OLE_CHECK(ITypeLib_GetDocumentation(lib, i, &name, NULL, NULL, NULL));
+        OLE_CHECK(ITypeLib_GetDocumentation(lib, i, &name, NULL, &help_ctx, NULL));
         printf("{\n"
                "  \"%s\",\n", dump_string(name));
 
@@ -3983,10 +3988,11 @@ static void test_dump_typelib(const char *name)
         printf("  \"%s\",\n", wine_dbgstr_guid(&attr->guid));
 
         printf("  /*kind*/ %s, /*flags*/ %s, /*align*/ %d, /*size*/ %s,\n"
-               "  /*#vtbl*/ %d, /*#func*/ %d",
+               "  /*helpctx*/ 0x%04x, /*version*/ 0x%08x, /*#vtbl*/ %d, /*#func*/ %d",
             map_value(attr->typekind, tkind_map), dump_type_flags(attr->wTypeFlags),
-            attr->cbAlignment, print_size(name, attr), attr->cbSizeVft/sizeof(void*),
-            attr->cFuncs);
+            attr->cbAlignment, print_size(name, attr),
+            help_ctx, MAKELONG(attr->wMinorVerNum, attr->wMajorVerNum),
+            attr->cbSizeVft/sizeof(void*), attr->cFuncs);
 
         if (attr->cFuncs) printf(",\n  {\n");
         else printf("\n");
@@ -4072,6 +4078,8 @@ typedef struct _type_info
     WORD wTypeFlags;
     USHORT cbAlignment;
     USHORT cbSizeInstance;
+    USHORT help_ctx;
+    DWORD version;
     USHORT cbSizeVft;
     USHORT cFuncs;
     function_info funcs[20];
@@ -4080,10 +4088,88 @@ typedef struct _type_info
 static const type_info info[] = {
 /*** Autogenerated data. Do not edit, change the generator above instead. ***/
 {
+  "parent_iface",
+  "{b14b6bb5-904e-4ff9-b247-bd361f7aa001}",
+  /*kind*/ TKIND_INTERFACE, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(parent_iface*),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 4, /*#func*/ 1,
+  {
+    {
+      /*id*/ 0x60010000, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
+      /*#param*/ 1, /*#opt*/ 0, /*vtbl*/ 3, /*#scodes*/ 0, /*flags*/ 0,
+      {VT_HRESULT, -1, PARAMFLAG_NONE}, /* ret */
+      { /* params */
+        {VT_PTR, -1, PARAMFLAG_FOUT|PARAMFLAG_FRETVAL},
+        {-1, 0, 0}
+      },
+      { /* names */
+        "test1",
+        "__MIDL__parent_iface0000",
+        NULL,
+      },
+    },
+  }
+},
+{
+  "child_iface",
+  "{b14b6bb5-904e-4ff9-b247-bd361f7aa002}",
+  /*kind*/ TKIND_INTERFACE, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(child_iface*),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 5, /*#func*/ 1,
+  {
+    {
+      /*id*/ 0x60020000, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
+      /*#param*/ 0, /*#opt*/ 0, /*vtbl*/ 4, /*#scodes*/ 0, /*flags*/ 0,
+      {VT_HRESULT, -1, PARAMFLAG_NONE}, /* ret */
+      { /* params */
+        {-1, 0, 0}
+      },
+      { /* names */
+        "test2",
+        NULL,
+      },
+    },
+  }
+},
+{
+  "_n",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753903}",
+  /*kind*/ TKIND_RECORD, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(struct _n),
+  /*helpctx*/ 0x0003, /*version*/ 0x00010002, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "n",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753902}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "nn",
+  "{00000000-0000-0000-0000-000000000000}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0003, /*version*/ 0x00010002, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "_m",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753906}",
+  /*kind*/ TKIND_RECORD, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(struct _m),
+  /*helpctx*/ 0x0003, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "m",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753905}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00010002, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "mm",
+  "{00000000-0000-0000-0000-000000000000}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0003, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
   "IDualIface",
   "{b14b6bb5-904e-4ff9-b247-bd361f7aaedd}",
   /*kind*/ TKIND_DISPATCH, /*flags*/ TYPEFLAG_FDISPATCHABLE|TYPEFLAG_FDUAL, /*align*/ 4, /*size*/ sizeof(IDualIface*),
-  /*#vtbl*/ 7, /*#func*/ 8,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 7, /*#func*/ 8,
   {
     {
       /*id*/ 0x60000000, /*func*/ FUNC_DISPATCH, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
@@ -4225,7 +4311,7 @@ static const type_info info[] = {
   "ISimpleIface",
   "{ec5dfcd6-eeb0-4cd6-b51e-8030e1dac009}",
   /*kind*/ TKIND_INTERFACE, /*flags*/ TYPEFLAG_FDISPATCHABLE, /*align*/ 4, /*size*/ sizeof(ISimpleIface*),
-  /*#vtbl*/ 8, /*#func*/ 1,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 8, /*#func*/ 1,
   {
     {
       /*id*/ 0x60020000, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
@@ -4245,67 +4331,127 @@ static const type_info info[] = {
   "test_struct",
   "{4029f190-ca4a-4611-aeb9-673983cb96dd}",
   /*kind*/ TKIND_RECORD, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(struct test_struct),
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "test_struct2",
   "{4029f190-ca4a-4611-aeb9-673983cb96de}",
   /*kind*/ TKIND_RECORD, /*flags*/ 0, /*align*/ 4, /*size*/ sizeof(struct test_struct2),
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "t_INT",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a75396a}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FRESTRICTED, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "a",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ALIAS, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "_a",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "aa",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "_b",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "bb",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "c",
   "{016fe2ec-b2c8-45f8-b23b-39e53a75396b}",
   /*kind*/ TKIND_ALIAS, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "_c",
   "{00000000-0000-0000-0000-000000000000}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "cc",
-  "{00000000-0000-0000-0000-000000000000}",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a75396c}",
   /*kind*/ TKIND_ENUM, /*flags*/ 0, /*align*/ 4, /*size*/ 4,
-  /*#vtbl*/ 0, /*#func*/ 0
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "d",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a75396d}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "_d",
+  "{00000000-0000-0000-0000-000000000000}",
+  /*kind*/ TKIND_ENUM, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "dd",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a75396e}",
+  /*kind*/ TKIND_ENUM, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "e",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753970}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "_e",
+  "{00000000-0000-0000-0000-000000000000}",
+  /*kind*/ TKIND_RECORD, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ sizeof(struct _e),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "ee",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753971}",
+  /*kind*/ TKIND_RECORD, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ sizeof(struct ee),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "f",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753972}",
+  /*kind*/ TKIND_ALIAS, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ 4,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "_f",
+  "{00000000-0000-0000-0000-000000000000}",
+  /*kind*/ TKIND_UNION, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ sizeof(union _f),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
+},
+{
+  "ff",
+  "{016fe2ec-b2c8-45f8-b23b-39e53a753973}",
+  /*kind*/ TKIND_UNION, /*flags*/ TYPEFLAG_FRESTRICTED|TYPEFLAG_FHIDDEN, /*align*/ 4, /*size*/ sizeof(union ff),
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 0, /*#func*/ 0
 },
 {
   "ITestIface",
   "{ec5dfcd6-eeb0-4cd6-b51e-8030e1dac00a}",
   /*kind*/ TKIND_INTERFACE, /*flags*/ TYPEFLAG_FDISPATCHABLE, /*align*/ 4, /*size*/ sizeof(ITestIface*),
-  /*#vtbl*/ 10, /*#func*/ 3,
+  /*helpctx*/ 0x0000, /*version*/ 0x00000000, /*#vtbl*/ 13, /*#func*/ 6,
   {
     {
       /*id*/ 0x60020000, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
@@ -4349,6 +4495,48 @@ static const type_info info[] = {
         NULL,
       },
     },
+    {
+      /*id*/ 0x60020003, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
+      /*#param*/ 1, /*#opt*/ 0, /*vtbl*/ 10, /*#scodes*/ 0, /*flags*/ 0,
+      {VT_HRESULT, -1, PARAMFLAG_NONE}, /* ret */
+      { /* params */
+        {VT_USERDEFINED, TKIND_ALIAS, PARAMFLAG_NONE},
+        {-1, 0, 0}
+      },
+      { /* names */
+        "test4",
+        "value",
+        NULL,
+      },
+    },
+    {
+      /*id*/ 0x60020004, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
+      /*#param*/ 1, /*#opt*/ 0, /*vtbl*/ 11, /*#scodes*/ 0, /*flags*/ 0,
+      {VT_HRESULT, -1, PARAMFLAG_NONE}, /* ret */
+      { /* params */
+        {VT_USERDEFINED, TKIND_ALIAS, PARAMFLAG_NONE},
+        {-1, 0, 0}
+      },
+      { /* names */
+        "test5",
+        "value",
+        NULL,
+      },
+    },
+    {
+      /*id*/ 0x60020005, /*func*/ FUNC_PUREVIRTUAL, /*inv*/ INVOKE_FUNC, /*call*/ CC_STDCALL,
+      /*#param*/ 1, /*#opt*/ 0, /*vtbl*/ 12, /*#scodes*/ 0, /*flags*/ 0,
+      {VT_HRESULT, -1, PARAMFLAG_NONE}, /* ret */
+      { /* params */
+        {VT_USERDEFINED, TKIND_ALIAS, PARAMFLAG_NONE},
+        {-1, 0, 0}
+      },
+      { /* names */
+        "test6",
+        "value",
+        NULL,
+      },
+    },
   }
 }
 };
@@ -4374,10 +4562,11 @@ static void test_dump_typelib(const char *name)
         ITypeInfo *typeinfo;
         TYPEATTR *typeattr;
         BSTR bstrIfName;
+        DWORD help_ctx;
 
         trace("Interface %s\n", ti->name);
         ole_check(ITypeLib_GetTypeInfo(typelib, iface, &typeinfo));
-        ole_check(ITypeLib_GetDocumentation(typelib, iface, &bstrIfName, NULL, NULL, NULL));
+        ole_check(ITypeLib_GetDocumentation(typelib, iface, &bstrIfName, NULL, &help_ctx, NULL));
         expect_wstr_acpval(bstrIfName, ti->name);
         SysFreeString(bstrIfName);
 
@@ -4385,7 +4574,7 @@ static void test_dump_typelib(const char *name)
         expect_int(typeattr->typekind, ti->type);
         expect_hex(typeattr->wTypeFlags, ti->wTypeFlags);
         /* FIXME: remove once widl is fixed */
-        if (typeattr->typekind == TKIND_ALIAS)
+        if (typeattr->typekind == TKIND_ALIAS && typeattr->cbAlignment != ti->cbAlignment)
         {
 todo_wine /* widl generates broken typelib and typeattr just reflects that */
         ok(typeattr->cbAlignment == ti->cbAlignment || broken(typeattr->cbAlignment == 1),
@@ -4399,6 +4588,8 @@ todo_wine /* widl generates broken typelib and typeattr just reflects that */
         expect_int(typeattr->cbAlignment, ti->cbAlignment);
         expect_int(typeattr->cbSizeInstance, ti->cbSizeInstance);
         }
+        expect_int(help_ctx, ti->help_ctx);
+        expect_int(MAKELONG(typeattr->wMinorVerNum, typeattr->wMajorVerNum), ti->version);
         expect_int(typeattr->cbSizeVft, ti->cbSizeVft * sizeof(void*));
         expect_int(typeattr->cFuncs, ti->cFuncs);
 
@@ -4445,7 +4636,9 @@ todo_wine /* widl generates broken typelib and typeattr just reflects that */
             ole_check(ITypeInfo_GetNames(typeinfo, desc->memid, namesTab, 256, &cNames));
             for (i = 0; i < cNames; i++)
             {
-                expect_wstr_acpval(namesTab[i], fn_info->names[i]);
+                /* automatically generated names differ between midl and widl */
+                if (strncmp(fn_info->names[i], "__MIDL__", 8) != 0)
+                    expect_wstr_acpval(namesTab[i], fn_info->names[i]);
                 SysFreeString(namesTab[i]);
             }
             expect_null(fn_info->names[cNames]);
-- 
2.6.1

