From 1a268f2380cc56623c1aed055dcd259c2fc3e53a Mon Sep 17 00:00:00 2001
From: Hugh McMaster <hugh.mcmaster@outlook.com>
Date: Thu, 17 Mar 2016 16:10:25 +1100
Subject: reg: Query all values and subkeys in a specified key (v3)

Displays all values and subkeys in a specified key. Recursion is supported.

Signed-off-by: Hugh McMaster <hugh.mcmaster@outlook.com>
---
 programs/reg/reg.c | 292 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 285 insertions(+), 7 deletions(-)

diff --git a/programs/reg/reg.c b/programs/reg/reg.c
index e56ddfe..334bb18 100644
--- a/programs/reg/reg.c
+++ b/programs/reg/reg.c
@@ -537,14 +537,292 @@ static int reg_delete(WCHAR *key_name, WCHAR *value_name, BOOL value_empty,
     return 0;
 }
 
-static int reg_query(WCHAR *key_name, WCHAR *value_name, BOOL value_empty,
-    BOOL subkey)
+static WCHAR *reg_data_to_wchar(DWORD type, const BYTE *src, DWORD size_bytes)
 {
+    WCHAR *buffer = NULL;
+    int i;
+
+    switch (type)
+    {
+        case REG_SZ:
+        case REG_EXPAND_SZ:
+            buffer = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+            strcpyW(buffer, (WCHAR *)src);
+            break;
+        case REG_NONE:
+        case REG_BINARY:
+        {
+            WCHAR *ptr;
+            WCHAR fmt[] = {'%','0','2','X',0};
+
+            buffer = HeapAlloc(GetProcessHeap(), 0, (size_bytes * 2 + 1) * sizeof(WCHAR));
+            ptr = buffer;
+            for (i = 0; i < size_bytes; i++)
+                ptr += sprintfW(ptr, fmt, src[i]);
+            break;
+        }
+        case REG_DWORD:
+     /* case REG_DWORD_LITTLE_ENDIAN: */
+        case REG_DWORD_BIG_ENDIAN:
+        {
+            const int zero_x_dword = 10;
+            WCHAR fmt[] = {'0','x','%','x',0};
+
+            buffer = HeapAlloc(GetProcessHeap(), 0, (zero_x_dword + 1) * sizeof(WCHAR));
+            sprintfW(buffer, fmt, *(DWORD *)src);
+            break;
+        }
+        case REG_MULTI_SZ:
+        {
+            const int two_wchars = 2 * sizeof(WCHAR);
+            DWORD tmp_size;
+            WCHAR *tmp;
+            int len, destindex;
+
+            if (size_bytes <= two_wchars)
+            {
+                buffer = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR));
+                *buffer = 0;
+                return buffer;
+            }
+
+            tmp_size = size_bytes - two_wchars; /* exclude both null terminators */
+            tmp = HeapAlloc(GetProcessHeap(), 0, tmp_size);
+            memcpy(tmp, (WCHAR *)src, tmp_size);
+            buffer = HeapAlloc(GetProcessHeap(), 0, tmp_size * 2);
+            len = tmp_size / sizeof(WCHAR);
+
+            for (i = 0, destindex = 0; i < len; i++, destindex++)
+            {
+                if (tmp[i])
+                    buffer[destindex] = tmp[i];
+                else
+                {
+                    buffer[destindex++] = '\\';
+                    buffer[destindex] = '0';
+                }
+            }
+            buffer[destindex] = 0;
+            HeapFree(GetProcessHeap(), 0, tmp);
+            break;
+        }
+    }
+    return buffer;
+}
+
+static const WCHAR *reg_type_to_wchar(DWORD type)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(type_rels); i++)
+    {
+        if (type == type_rels[i].type)
+            return type_rels[i].name;
+    }
+    return NULL;
+}
+
+static void output_value(const WCHAR *value_name, DWORD type, BYTE *data, DWORD data_size)
+{
+    WCHAR fmt[] = {' ',' ',' ',' ','%','1',0};
+    WCHAR *reg_data;
+    WCHAR newlineW[] = {'\n',0};
+
+    if (value_name && *value_name)
+        output_string(fmt, value_name);
+    else
+    {
+        WCHAR defval[32];
+        LoadStringW(GetModuleHandleW(NULL), STRING_DEFAULT_VALUE, defval, ARRAY_SIZE(defval));
+        output_string(fmt, defval);
+    }
+    output_string(fmt, reg_type_to_wchar(type));
+    reg_data = reg_data_to_wchar(type, data, data_size);
+    output_string(fmt, reg_data);
+    HeapFree(GetProcessHeap(), 0, reg_data);
+    output_string(newlineW);
+}
+
+static WCHAR *build_subkey_path(WCHAR *path, DWORD path_len, WCHAR *subkey_name, DWORD subkey_len)
+{
+    WCHAR *subkey_path;
+    WCHAR fmt[] = {'%','s','\\','%','s',0};
+
+    subkey_path = HeapAlloc(GetProcessHeap(), 0, (path_len + subkey_len + 2) * sizeof(WCHAR));
+    if (!subkey_path)
+    {
+        ERR("Failed to allocate memory for subkey_path\n");
+        return NULL;
+    }
+    sprintfW(subkey_path, fmt, path, subkey_name);
+    return subkey_path;
+}
+
+static int query_all(HKEY key, WCHAR *path, BOOL recurse)
+{
+    LONG rc;
+    DWORD num_subkeys, max_subkey_len, subkey_len;
+    DWORD num_values, max_value_len, value_len;
+    DWORD max_data_bytes, data_size;
+    DWORD type, path_len;
+    WCHAR *value_name, *subkey_name, *subkey_path;
+    WCHAR fmt[] = {'%','1','\n',0};
+    WCHAR fmt_path[] = {'%','1','\\','%','2','\n',0};
+    WCHAR newlineW[] = {'\n',0};
+    BYTE *data;
+    int i;
+    HKEY subkey;
+
+    rc = RegQueryInfoKeyW(key, NULL, NULL, NULL, &num_subkeys, &max_subkey_len, NULL,
+                          &num_values, &max_value_len, &max_data_bytes, NULL, NULL);
+    if (rc)
+    {
+        ERR("RegQueryInfoKey failed: %d\n", rc);
+        return 1;
+    }
+
+    max_value_len++;
+    value_name = HeapAlloc(GetProcessHeap(), 0, max_value_len * sizeof(WCHAR));
+    if (!value_name)
+    {
+        ERR("Failed to allocate memory for value_name\n");
+        return 1;
+    }
+
+    data = HeapAlloc(GetProcessHeap(), 0, max_data_bytes);
+    if (!data)
+    {
+        HeapFree(GetProcessHeap(), 0, value_name);
+        ERR("Failed to allocate memory for data\n");
+        return 1;
+    }
+
+    output_string(fmt, path);
+
+    for (i = 0; i < num_values; i++)
+    {
+        value_len = max_value_len;
+        data_size = max_data_bytes;
+        rc = RegEnumValueW(key, i, value_name, &value_len, NULL, &type, data, &data_size);
+        if (rc == ERROR_SUCCESS)
+            output_value(value_name, type, data, data_size);
+    }
+
+    HeapFree(GetProcessHeap(), 0, data);
+    HeapFree(GetProcessHeap(), 0, value_name);
+
+    if (num_values || recurse)
+        output_string(newlineW);
+
+    max_subkey_len++;
+    subkey_name = HeapAlloc(GetProcessHeap(), 0, max_subkey_len * sizeof(WCHAR));
+    if (!subkey_name)
+    {
+        ERR("Failed to allocate memory for subkey_name\n");
+        return 1;
+    }
+
+    path_len = strlenW(path);
+
+    for (i = 0; i < num_subkeys; i++)
+    {
+        subkey_len = max_subkey_len;
+        rc = RegEnumKeyExW(key, i, subkey_name, &subkey_len, NULL, NULL, NULL, NULL);
+        if (rc == ERROR_SUCCESS)
+        {
+            if (recurse)
+            {
+                subkey_path = build_subkey_path(path, path_len, subkey_name, subkey_len);
+                RegOpenKeyExW(key, subkey_name, 0, KEY_READ, &subkey);
+                query_all(subkey, subkey_path, recurse);
+                RegCloseKey(subkey);
+                HeapFree(GetProcessHeap(), 0, subkey_path);
+            }
+            else output_string(fmt_path, path, subkey_name);
+        }
+    }
+
+    if (num_subkeys && !recurse)
+        output_string(newlineW);
+
+    HeapFree(GetProcessHeap(), 0, subkey_name);
+    return 0;
+}
+
+static WCHAR *get_long_path(HKEY root, WCHAR *path)
+{
+    DWORD i, len;
+    WCHAR *long_path;
+    WCHAR fmt[] = {'%','s','\\','%','s',0};
+
+    for (i = 0; i < ARRAY_SIZE(root_rels); i++)
+    {
+        if (root == root_rels[i].key)
+            break;
+    }
+
+    len = strlenW(root_rels[i].long_name);
+
+    if (!path)
+    {
+        long_path = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR));
+        strcpyW(long_path, root_rels[i].long_name);
+        return long_path;
+    }
+
+    len += strlenW(path) + 1; /* add one for the backslash */
+    long_path = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR));
+    sprintfW(long_path, fmt, root_rels[i].long_name, path);
+    return long_path;
+}
+
+static int reg_query(WCHAR *key_name, WCHAR *value_name, BOOL value_empty, BOOL recurse)
+{
+    WCHAR *p, *path;
+    HKEY root, key;
     static const WCHAR stubW[] = {'S','T','U','B',' ','Q','U','E','R','Y',' ',
         '-',' ','%','1',' ','%','2',' ','%','3','!','d','!',' ','%','4','!','d','!','\n',0};
-    output_string(stubW, key_name, value_name, value_empty, subkey);
+    int ret;
+
+    if (!sane_path(key_name))
+        return 1;
+
+    if (value_name && value_empty)
+    {
+        output_message(STRING_INVALID_CMDLINE);
+        return 1;
+    }
+
+    root = path_get_rootkey(key_name);
+    if (!root)
+    {
+        output_message(STRING_INVALID_KEY);
+        return 1;
+    }
+
+    p = strchrW(key_name, '\\');
+    if (p) p++;
+
+    if (RegOpenKeyExW(root, p, 0, KEY_READ, &key) != ERROR_SUCCESS)
+    {
+        output_message(STRING_CANNOT_FIND);
+        return 1;
+    }
+
+    path = get_long_path(root, p);
+
+    if (value_name || value_empty)
+    {
+        output_string(stubW, key_name, value_name, value_empty, recurse);
+        return 1;
+    }
+
+    ret = query_all(key, path, recurse);
+
+    HeapFree(GetProcessHeap(), 0, path);
+    RegCloseKey(key);
 
-    return 1;
+    return ret;
 }
 
 int wmain(int argc, WCHAR *argvW[])
@@ -668,7 +946,7 @@ int wmain(int argc, WCHAR *argvW[])
     else if (!lstrcmpiW(argvW[1], queryW))
     {
         WCHAR *key_name, *value_name = NULL;
-        BOOL value_empty = FALSE, subkey = FALSE;
+        BOOL value_empty = FALSE, recurse = FALSE;
 
         if (argc < 3)
         {
@@ -696,9 +974,9 @@ int wmain(int argc, WCHAR *argvW[])
             else if (!lstrcmpiW(argvW[i], slashVEW))
                 value_empty = TRUE;
             else if (!lstrcmpiW(argvW[i], slashSW))
-                subkey = TRUE;
+                recurse = TRUE;
         }
-        return reg_query(key_name, value_name, value_empty, subkey);
+        return reg_query(key_name, value_name, value_empty, recurse);
     }
     else
     {
-- 
2.7.1

