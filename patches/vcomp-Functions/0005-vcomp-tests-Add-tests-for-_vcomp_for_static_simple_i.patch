From af8411c2c51708c2edbc620b3d775bf5a08144f9 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 11 Jul 2015 05:12:39 +0200
Subject: vcomp/tests: Add tests for _vcomp_for_static_simple_init.

---
 dlls/vcomp/tests/vcomp.c | 228 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 228 insertions(+)

diff --git a/dlls/vcomp/tests/vcomp.c b/dlls/vcomp/tests/vcomp.c
index 5c6a861..1971b6d 100644
--- a/dlls/vcomp/tests/vcomp.c
+++ b/dlls/vcomp/tests/vcomp.c
@@ -23,8 +23,15 @@
 static const int is_win64 = (sizeof(void *) > sizeof(int));
 
 static HMODULE hvcomp = 0;
+static void  (CDECL   *p_vcomp_barrier)(void);
+static void  (CDECL   *p_vcomp_for_static_end)(void);
+static void  (CDECL   *p_vcomp_for_static_simple_init)(unsigned int first, unsigned int last, int step,
+                                                       BOOL forward, unsigned int *begin, unsigned int *end);
 static void  (WINAPIV *p_vcomp_fork)(BOOL ifval, int nargs, void *wrapper, ...);
 static int   (CDECL   *pomp_get_max_threads)(void);
+static int   (CDECL   *pomp_get_num_threads)(void);
+static int   (CDECL   *pomp_get_thread_num)(void);
+static void  (CDECL   *pomp_set_num_threads)(int num_threads);
 
 #define VCOMP_GET_PROC(func) \
     do \
@@ -43,8 +50,14 @@ static BOOL init_vcomp(void)
         return FALSE;
     }
 
+    VCOMP_GET_PROC(_vcomp_barrier);
+    VCOMP_GET_PROC(_vcomp_for_static_end);
+    VCOMP_GET_PROC(_vcomp_for_static_simple_init);
     VCOMP_GET_PROC(_vcomp_fork);
     VCOMP_GET_PROC(omp_get_max_threads);
+    VCOMP_GET_PROC(omp_get_num_threads);
+    VCOMP_GET_PROC(omp_get_thread_num);
+    VCOMP_GET_PROC(omp_set_num_threads);
 
     return TRUE;
 }
@@ -111,12 +124,227 @@ static void test_vcomp_fork(void)
     }
 }
 
+static void CDECL _test_vcomp_for_static_simple_init(void)
+{
+    static const struct
+    {
+        unsigned int first;
+        unsigned int last;
+        int step;
+        BOOL forward;
+    }
+    tests[] =
+    {
+        /* loop forward, step 1 */
+        { 0, 0, 1, TRUE },
+        { 0, 1, 1, TRUE },
+        { 0, 2, 1, TRUE },
+        { 0, 3, 1, TRUE },
+        { 0, 0x10000000, 1, TRUE },
+        { 0, 0x20000000, 1, TRUE },
+        { 0, 0x40000000, 1, TRUE },
+        { 0, 0x80000000, 1, TRUE },
+
+        /* loop forward, varying step */
+        { 0, 100, 1,   TRUE },
+        { 0, 100, 5,   TRUE },
+        { 0, 100, 10,  TRUE },
+        { 0, 100, 25,  TRUE },
+        { 0, 100, 50,  TRUE },
+        { 0, 100, 75,  TRUE },
+        { 0, 100, 100, TRUE },
+        { 0, 100, 150, TRUE },
+
+        /* empty loop forward, varying step */
+        { 50, 50, 3,   TRUE },
+        { 50, 50, 2,   TRUE },
+        { 50, 50, 1,   TRUE },
+        { 50, 50, 0,   TRUE },
+        { 50, 50, -1,  TRUE },
+        { 50, 50, -2,  TRUE },
+        { 50, 50, -3,  TRUE },
+
+        /* loop backward, step 1 */
+        { 0, 0, 1, FALSE },
+        { 1, 0, 1, FALSE },
+        { 2, 0, 1, FALSE },
+        { 3, 0, 1, FALSE },
+        { 0x10000000, 0, 1, FALSE },
+        { 0x20000000, 0, 1, FALSE },
+        { 0x40000000, 0, 1, FALSE },
+        { 0x80000000, 0, 1, FALSE },
+
+        /* loop backward, varying step */
+        { 100, 0, 1,   FALSE },
+        { 100, 0, 5,   FALSE },
+        { 100, 0, 10,  FALSE },
+        { 100, 0, 25,  FALSE },
+        { 100, 0, 50,  FALSE },
+        { 100, 0, 75,  FALSE },
+        { 100, 0, 100, FALSE },
+        { 100, 0, 150, FALSE },
+
+        /* empty loop backward, varying step */
+        { 50, 50, 3,   FALSE },
+        { 50, 50, 2,   FALSE },
+        { 50, 50, 1,   FALSE },
+        { 50, 50, 0,   FALSE },
+        { 50, 50, -1,  FALSE },
+        { 50, 50, -2,  FALSE },
+        { 50, 50, -3,  FALSE },
+
+        /* test overflow in forward loop */
+        { 0, 0, 1, TRUE },
+        { 1, 0, 1, TRUE },
+        { 2, 0, 1, TRUE },
+        { 3, 0, 1, TRUE },
+        { 0x10000000, 0, 1, TRUE },
+        { 0x20000000, 0, 1, TRUE },
+        { 0x40000000, 0, 1, TRUE },
+        { 0x80000000, 0, 1, TRUE },
+
+        { 100, 0, 1,   TRUE },
+        { 100, 0, 5,   TRUE },
+        { 100, 0, 10,  TRUE },
+        { 100, 0, 25,  TRUE },
+        { 100, 0, 50,  TRUE },
+        { 100, 0, 75,  TRUE },
+        { 100, 0, 100, TRUE },
+        { 100, 0, 150, TRUE },
+
+        /* test overflow in backward loop */
+        { 0, 0, 1, FALSE },
+        { 0, 1, 1, FALSE },
+        { 0, 2, 1, FALSE },
+        { 0, 3, 1, FALSE },
+        { 0, 0x10000000, 1, FALSE },
+        { 0, 0x20000000, 1, FALSE },
+        { 0, 0x40000000, 1, FALSE },
+        { 0, 0x80000000, 1, FALSE },
+
+        { 0, 100, 1,   FALSE },
+        { 0, 100, 5,   FALSE },
+        { 0, 100, 10,  FALSE },
+        { 0, 100, 25,  FALSE },
+        { 0, 100, 50,  FALSE },
+        { 0, 100, 75,  FALSE },
+        { 0, 100, 100, FALSE },
+        { 0, 100, 150, FALSE },
+    };
+    unsigned int begin, end, expected_begin, expected_end;
+    int thread_num  = pomp_get_thread_num();
+    int num_threads = pomp_get_num_threads();
+    int i;
+
+    for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++)
+    {
+        unsigned int iterations, per_thread, remaining;
+        DWORD64 first = tests[i].first;
+        DWORD64 last  = tests[i].last;
+        int     step  = tests[i].step;
+
+        if (num_threads == 1)
+        {
+            expected_begin = first;
+            expected_end   = last;
+            goto done;
+        }
+
+        if (tests[i].forward)
+        {
+            if (tests[i].step <= 0)
+            {
+                expected_begin = 0;
+                expected_end   = -1;
+                goto done;
+            }
+
+            if (last < first)
+                last += 0x100000000;
+
+            iterations = 1 + (last - first) / step;
+            per_thread = iterations / num_threads;
+            remaining  = iterations - per_thread * num_threads;
+
+            if (thread_num < remaining)
+                per_thread++;
+            else if (per_thread)
+                first += remaining * step;
+            else
+            {
+                expected_begin = first;
+                expected_end   = first - step;
+                goto done;
+            }
+
+            expected_begin = first + per_thread * thread_num * step;
+            expected_end   = expected_begin + (per_thread - 1) * step;
+        }
+        else
+        {
+            if (tests[i].step <= 0)
+            {
+                expected_begin = 0;
+                expected_end   = 1;
+                goto done;
+            }
+
+            if (first < last)
+                first += 0x100000000;
+
+            iterations = 1 + (first - last) / step;
+            per_thread = iterations / num_threads;
+            remaining  = iterations - per_thread * num_threads;
+
+            if (thread_num < remaining)
+                per_thread++;
+            else if (per_thread)
+                first -= remaining * step;
+            else
+            {
+                expected_begin = first;
+                expected_end   = first + step;
+                goto done;
+            }
+
+            expected_begin = first - per_thread * thread_num * step;
+            expected_end   = expected_begin - (per_thread - 1) * step;
+        }
+
+done:
+        begin = end = 0xdeadbeef;
+        p_vcomp_for_static_simple_init(tests[i].first, tests[i].last, tests[i].step,
+                                       tests[i].forward, &begin, &end);
+
+        ok(begin == expected_begin, "%d:%d/%d: expected begin = %u, got %u\n",
+           i, thread_num, num_threads, expected_begin, end);
+        ok(end == expected_end, "%d:%d/%d: expected end = %u, got %u\n",
+           i, thread_num, num_threads, expected_end, end);
+
+        p_vcomp_for_static_end();
+        p_vcomp_barrier();
+    }
+}
+
+static void test_vcomp_for_static_simple_init(void)
+{
+    int i;
+
+    for (i = 1; i <= 4; i++)
+    {
+        trace("Running tests with %d threads\n", i);
+        pomp_set_num_threads(i);
+        p_vcomp_fork(TRUE, 0, _test_vcomp_for_static_simple_init);
+    }
+}
+
 START_TEST(vcomp)
 {
     if (!init_vcomp())
         return;
 
     test_vcomp_fork();
+    test_vcomp_for_static_simple_init();
 
     FreeLibrary(hvcomp);
 }
-- 
2.4.5

