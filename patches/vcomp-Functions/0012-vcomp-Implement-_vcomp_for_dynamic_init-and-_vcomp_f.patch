From 145ddf41060e93e9f320d5d2e4347dd2c7b8a83f Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 11 Jul 2015 23:28:31 +0200
Subject: vcomp: Implement _vcomp_for_dynamic_init and _vcomp_for_dynamic_next
 and add tests.

---
 dlls/vcomp/main.c           | 93 +++++++++++++++++++++++++++++++++++++++++++++
 dlls/vcomp/tests/vcomp.c    | 53 ++++++++++++++++++++++++++
 dlls/vcomp/vcomp.spec       |  4 +-
 dlls/vcomp100/vcomp100.spec |  4 +-
 dlls/vcomp90/vcomp90.spec   |  4 +-
 5 files changed, 152 insertions(+), 6 deletions(-)

diff --git a/dlls/vcomp/main.c b/dlls/vcomp/main.c
index 31814d6..174ce06 100644
--- a/dlls/vcomp/main.c
+++ b/dlls/vcomp/main.c
@@ -61,6 +61,9 @@ struct vcomp_thread_data
 
     /* section */
     unsigned int            section;
+
+    /* dynamic */
+    unsigned int            dynamic;
 };
 
 struct vcomp_team_data
@@ -82,6 +85,15 @@ struct vcomp_team_data
     unsigned int            section;
     unsigned int            num_sections;
     unsigned int            section_index;
+
+    /* dynamic */
+    DWORD               dynamic;
+    DWORD               dynamic_forward;
+    DWORD               dynamic_first;
+    DWORD               dynamic_iterations;
+    int                 dynamic_step;
+    DWORD               dynamic_chunksize;
+    DWORD               dynamic_min_chunksize;
 };
 
 void CDECL _vcomp_fork_call_wrapper(void *wrapper, int nargs, __ms_va_list args);
@@ -498,6 +510,83 @@ int CDECL _vcomp_sections_next(void)
     return i;
 }
 
+void CDECL _vcomp_for_dynamic_init(int flags, int first, int last, int step, int chunksize)
+{
+    struct vcomp_thread_data *thread_data = vcomp_get_thread_data();
+    struct vcomp_team_data *team_data = thread_data->team;
+    unsigned int iterations;
+    BOOL forward = (flags & 0x40) != 0;
+
+    TRACE("(%d, %d, %d, %d, %d)\n", flags, first, last, step, chunksize);
+
+    EnterCriticalSection(&vcomp_section);
+    thread_data->dynamic++;
+    if ((int)(thread_data->dynamic - team_data->dynamic) > 0)
+    {
+        /* first thread in a new for_dynamic */
+
+        if (forward)
+        {
+            DWORD64 last64 = last;
+            if (last64 < first)
+                last64 += 0x100000000;
+            iterations = 1 + (last64 - first) / step;
+        }
+        else
+        {
+            DWORD first64 = first;
+            if (first64 < last)
+                first64 += 0x100000000;
+            iterations = 1 + (first64 - last) / step;
+        }
+
+        team_data->dynamic = thread_data->dynamic;
+        team_data->dynamic_forward    = forward;
+        team_data->dynamic_first      = first;
+        team_data->dynamic_iterations = iterations;
+        team_data->dynamic_step       = step;
+        team_data->dynamic_chunksize  = max(1, iterations / team_data->num_threads);
+        team_data->dynamic_min_chunksize = max(1, chunksize);
+    }
+    LeaveCriticalSection(&vcomp_section);
+}
+
+int CDECL _vcomp_for_dynamic_next(int *begin, int *end)
+{
+    struct vcomp_thread_data *thread_data = vcomp_get_thread_data();
+    struct vcomp_team_data *team_data = thread_data->team;
+    unsigned int iterations = 0;
+
+    TRACE("(%p, %p)\n", begin, end);
+
+    EnterCriticalSection(&vcomp_section);
+    if (thread_data->dynamic == team_data->dynamic &&
+        team_data->dynamic_iterations != 0)
+    {
+        iterations = min(team_data->dynamic_iterations, team_data->dynamic_chunksize);
+        team_data->dynamic_iterations -= iterations;
+
+        if (team_data->dynamic_forward)
+        {
+            *begin = team_data->dynamic_first;
+            *end   = team_data->dynamic_first + (iterations - 1) * team_data->dynamic_step;
+            team_data->dynamic_first += iterations * team_data->dynamic_step;
+        }
+        else
+        {
+            *begin = team_data->dynamic_first;
+            *end   = team_data->dynamic_first - (iterations - 1) * team_data->dynamic_step;
+            team_data->dynamic_first -= iterations * team_data->dynamic_step;
+        }
+
+        team_data->dynamic_chunksize =
+            max((team_data->dynamic_chunksize * 3 + 2)/4, team_data->dynamic_min_chunksize);
+    }
+    LeaveCriticalSection(&vcomp_section);
+
+    return (iterations != 0);
+}
+
 int CDECL omp_in_parallel(void)
 {
     TRACE("()\n");
@@ -572,11 +661,13 @@ void WINAPIV _vcomp_fork(BOOL ifval, int nargs, void *wrapper, ...)
     team_data.barrier           = 0;
     team_data.barrier_count     = 0;
     team_data.section           = 0;
+    team_data.dynamic           = 0;
 
     thread_data.team            = &team_data;
     thread_data.thread_num      = 0;
     thread_data.fork_threads    = 0;
     thread_data.section         = 1;
+    thread_data.dynamic         = 1;
     list_init(&thread_data.entry);
     InitializeConditionVariable(&thread_data.cond);
 
@@ -593,6 +684,7 @@ void WINAPIV _vcomp_fork(BOOL ifval, int nargs, void *wrapper, ...)
             data->thread_num    = team_data.num_threads++;
             data->fork_threads  = 0;
             data->section       = 1;
+            data->dynamic       = 1;
             list_remove(&data->entry);
             list_add_tail(&thread_data.entry, &data->entry);
             WakeAllConditionVariable(&data->cond);
@@ -612,6 +704,7 @@ void WINAPIV _vcomp_fork(BOOL ifval, int nargs, void *wrapper, ...)
             data->thread_num    = team_data.num_threads;
             data->fork_threads  = 0;
             data->section       = 1;
+            data->dynamic       = 1;
             InitializeConditionVariable(&data->cond);
 
             thread = CreateThread(NULL, 0, _vcomp_fork_worker, data, 0, NULL);
diff --git a/dlls/vcomp/tests/vcomp.c b/dlls/vcomp/tests/vcomp.c
index c962fe8..af04cc9 100644
--- a/dlls/vcomp/tests/vcomp.c
+++ b/dlls/vcomp/tests/vcomp.c
@@ -32,6 +32,8 @@ static BOOL   (WINAPI *pDeactivateActCtx)(DWORD, ULONG_PTR);
 static VOID   (WINAPI *pReleaseActCtx)(HANDLE);
 
 static void  (CDECL   *p_vcomp_barrier)(void);
+static void  (CDECL   *p_vcomp_for_dynamic_init)(int flags, int first, int last, int step, int chunksize);
+static int   (CDECL   *p_vcomp_for_dynamic_next)(int *begin, int *end);
 static void  (CDECL   *p_vcomp_for_static_end)(void);
 static void  (CDECL   *p_vcomp_for_static_init)(int first, int last, int step, int chunksize, unsigned int *loops,
                                                 int *begin, int *end, int *next, int *lastchunk);
@@ -175,6 +177,8 @@ static BOOL init_vcomp(void)
     }
 
     VCOMP_GET_PROC(_vcomp_barrier);
+    VCOMP_GET_PROC(_vcomp_for_dynamic_init);
+    VCOMP_GET_PROC(_vcomp_for_dynamic_next);
     VCOMP_GET_PROC(_vcomp_for_static_end);
     VCOMP_GET_PROC(_vcomp_for_static_init);
     VCOMP_GET_PROC(_vcomp_for_static_simple_init);
@@ -807,6 +811,54 @@ static void test_vcomp_sections_init(void)
     }
 }
 
+static void CDECL _test_vcomp_for_dynamic_init(LONG *a, LONG *b, LONG *c)
+{
+    int begin, end;
+
+    p_vcomp_for_dynamic_init(0x40, 1, 100000, 1, 30);
+    while (p_vcomp_for_dynamic_next(&begin, &end))
+    {
+        InterlockedExchangeAdd(a, end - begin + 1);
+        Sleep(50);
+    }
+
+    p_vcomp_for_dynamic_init(0, 1337, 1, 1, 50);
+    while (p_vcomp_for_dynamic_next(&begin, &end))
+    {
+        InterlockedExchangeAdd(b, begin - end + 1);
+        Sleep(50);
+    }
+
+    p_vcomp_for_dynamic_init(0x40, 1, 100000, 7, 30);
+    while (p_vcomp_for_dynamic_next(&begin, &end))
+    {
+        while (begin <= end)
+        {
+            InterlockedIncrement(c);
+            begin += 7;
+        }
+        Sleep(50);
+    }
+}
+
+static void test_vcomp_for_dynamic_init(void)
+{
+    LONG a, b, c;
+    int i;
+
+    for (i = 1; i <= 4; i++)
+    {
+        trace("Running tests with %d threads\n", i);
+        pomp_set_num_threads(i);
+
+        a = b = c = 0;
+        p_vcomp_fork(TRUE, 3, _test_vcomp_for_dynamic_init, &a, &b, &c);
+        ok(a == 100000, "expected a = 100000, got %d\n", a);
+        ok(b == 1337, "expected b = 1337, got %d\n", b);
+        ok(c == 14286, "expected c = 14286, got %d\n", c);
+    }
+}
+
 START_TEST(vcomp)
 {
     if (!init_vcomp())
@@ -818,6 +870,7 @@ START_TEST(vcomp)
     test_vcomp_for_static_simple_init();
     test_vcomp_for_static_init();
     test_vcomp_sections_init();
+    test_vcomp_for_dynamic_init();
 
     release_vcomp();
 }
diff --git a/dlls/vcomp/vcomp.spec b/dlls/vcomp/vcomp.spec
index 7083ce4..1b02a65 100644
--- a/dlls/vcomp/vcomp.spec
+++ b/dlls/vcomp/vcomp.spec
@@ -55,9 +55,9 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long)
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr)
 @ stub _vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
diff --git a/dlls/vcomp100/vcomp100.spec b/dlls/vcomp100/vcomp100.spec
index 56c7ae3..ab93ec2 100644
--- a/dlls/vcomp100/vcomp100.spec
+++ b/dlls/vcomp100/vcomp100.spec
@@ -55,9 +55,9 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
diff --git a/dlls/vcomp90/vcomp90.spec b/dlls/vcomp90/vcomp90.spec
index 56c7ae3..ab93ec2 100644
--- a/dlls/vcomp90/vcomp90.spec
+++ b/dlls/vcomp90/vcomp90.spec
@@ -55,9 +55,9 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
-- 
2.4.5

