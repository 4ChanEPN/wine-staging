From 9cea1ba140eb5d8ecd70eab4a68e309cd80fd454 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 11 Jul 2015 06:08:08 +0200
Subject: vcomp/tests: Add tests for _vcomp_for_static_init.

---
 dlls/vcomp/tests/vcomp.c | 199 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 199 insertions(+)

diff --git a/dlls/vcomp/tests/vcomp.c b/dlls/vcomp/tests/vcomp.c
index 1971b6d..96806fd 100644
--- a/dlls/vcomp/tests/vcomp.c
+++ b/dlls/vcomp/tests/vcomp.c
@@ -25,6 +25,8 @@ static const int is_win64 = (sizeof(void *) > sizeof(int));
 static HMODULE hvcomp = 0;
 static void  (CDECL   *p_vcomp_barrier)(void);
 static void  (CDECL   *p_vcomp_for_static_end)(void);
+static void  (CDECL   *p_vcomp_for_static_init)(int first, int last, int step, int chunksize, unsigned int *loops,
+                                                int *begin, int *end, int *next, int *lastchunk);
 static void  (CDECL   *p_vcomp_for_static_simple_init)(unsigned int first, unsigned int last, int step,
                                                        BOOL forward, unsigned int *begin, unsigned int *end);
 static void  (WINAPIV *p_vcomp_fork)(BOOL ifval, int nargs, void *wrapper, ...);
@@ -52,6 +54,7 @@ static BOOL init_vcomp(void)
 
     VCOMP_GET_PROC(_vcomp_barrier);
     VCOMP_GET_PROC(_vcomp_for_static_end);
+    VCOMP_GET_PROC(_vcomp_for_static_init);
     VCOMP_GET_PROC(_vcomp_for_static_simple_init);
     VCOMP_GET_PROC(_vcomp_fork);
     VCOMP_GET_PROC(omp_get_max_threads);
@@ -338,6 +341,201 @@ static void test_vcomp_for_static_simple_init(void)
     }
 }
 
+static void CDECL _test_vcomp_for_static_init(void)
+{
+    static const struct
+    {
+        int first;
+        int last;
+        int step;
+        int chunksize;
+    }
+    tests[] =
+    {
+        /* loop forward, step 1 */
+        { 0, 0, 1, 1 },
+        { 0, 1, 1, 1 },
+        { 0, 2, 1, 1 },
+        { 0, 3, 1, 1 },
+        { 0, 0x10000000, 1, 1 },
+        { 0, 0x20000000, 1, 1 },
+        { 0, 0x40000000, 1, 1 },
+        { 0, (int)0x80000000, 1, 1 },
+
+        /* loop forward, varying step */
+        {0, 100, 1,   1},
+        {0, 100, 5,   1},
+        {0, 100, 10,  1},
+        {0, 100, 25,  1},
+        {0, 100, 50,  1},
+        {0, 100, 75,  1},
+        {0, 100, 100, 1},
+        {0, 100, 150, 1},
+
+        /* empty loop forward, varying step */
+        { 50, 50, 3,   1 },
+        { 50, 50, 2,   1 },
+        { 50, 50, 1,   1 },
+        /*{ 50, 50, 0,   1 }, - generates a division by zero exception */
+        { 50, 50, -1,  1 },
+        { 50, 50, -2,  1 },
+        { 50, 50, -3,  1 },
+
+        /* loop backwards, step 1 */
+        { 0, 0, 1, 1 },
+        { 1, 0, 1, 1 },
+        { 2, 0, 1, 1 },
+        { 3, 0, 1, 1 },
+        { 0x10000000, 0, 1, 1 },
+        { 0x20000000, 0, 1, 1 },
+        { 0x40000000, 0, 1, 1 },
+        { (int)0x80000000, 0, 1, 1 },
+
+        /* loop backwards, varying step */
+        {100, 0, 1,   1},
+        {100, 0, 5,   1},
+        {100, 0, 10,  1},
+        {100, 0, 25,  1},
+        {100, 0, 50,  1},
+        {100, 0, 75,  1},
+        {100, 0, 100, 1},
+        {100, 0, 150, 1},
+
+        /* loop forward, varying chunksize */
+        {0, 100, 1, 1},
+        {0, 100, 1, 5},
+        {0, 100, 1, 10},
+        {0, 100, 1, 25},
+        {0, 100, 1, 50},
+        {0, 100, 1, 75},
+        {0, 100, 1, 100},
+        {0, 100, 1, 150},
+
+        {0, 100, 7, 1},
+        {0, 100, 7, 5},
+        {0, 100, 7, 10},
+        {0, 100, 7, 25},
+        {0, 100, 7, 50},
+        {0, 100, 7, 75},
+        {0, 100, 7, 100},
+        {0, 100, 7, 150},
+
+        /* loop backwards, varying chunksize */
+        {100, 0, 1, 1},
+        {100, 0, 1, 5},
+        {100, 0, 1, 10},
+        {100, 0, 1, 25},
+        {100, 0, 1, 50},
+        {100, 0, 1, 75},
+        {100, 0, 1, 100},
+        {100, 0, 1, 150},
+
+        {100, 0, 7, 1},
+        {100, 0, 7, 5},
+        {100, 0, 7, 10},
+        {100, 0, 7, 25},
+        {100, 0, 7, 50},
+        {100, 0, 7, 75},
+        {100, 0, 7, 100},
+        {100, 0, 7, 150},
+
+    };
+    int begin, end, expected_begin, expected_end;
+    unsigned int loops, expected_loops;
+    int lastchunk, expected_lastchunk;
+    int chunksize, expected_chunksize;
+    int thread_num  = pomp_get_thread_num();
+    int num_threads = pomp_get_num_threads();
+    int i;
+
+    for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++)
+    {
+        unsigned int iterations, num_chunks, per_thread, remaining;
+        int first = tests[i].first;
+        int last  = tests[i].last;
+        int step  = tests[i].step;
+        chunksize = tests[i].chunksize;
+
+        if (chunksize < 1)
+            chunksize = 1;
+
+        if (num_threads == 1 && chunksize > 1)
+        {
+            expected_loops = 1;
+            expected_begin = first;
+            expected_end   = last;
+            expected_chunksize = chunksize;
+            expected_lastchunk = first;
+        }
+        else if (last > first)
+        {
+            iterations = 1 + (last - first) / step;
+            num_chunks = (iterations + chunksize - 1) / chunksize;
+            per_thread = num_chunks / num_threads;
+            remaining  = num_chunks - per_thread * num_threads;
+
+            expected_loops = per_thread + (thread_num < remaining);
+            expected_begin = first + thread_num * chunksize * step;
+            expected_end   = expected_begin + (chunksize - 1) * step;
+            expected_chunksize = chunksize * num_threads * step;
+            expected_lastchunk = first + (num_chunks - 1) * chunksize * step;
+
+        }
+        else if (last < first)
+        {
+            iterations = 1 + (first - last) / step;
+            num_chunks = (iterations + chunksize - 1) / chunksize;
+            per_thread = num_chunks / num_threads;
+            remaining  = num_chunks - per_thread * num_threads;
+
+            expected_loops = per_thread + (thread_num < remaining);
+            expected_begin = first - thread_num * chunksize * step;
+            expected_end   = expected_begin - (chunksize - 1) * step;
+            expected_chunksize = - chunksize * num_threads * step;
+            expected_lastchunk = first - (num_chunks - 1) * chunksize * step;
+        }
+        else
+        {
+            expected_loops = (thread_num == 0);
+            expected_begin = first;
+            expected_end   = last;
+            expected_chunksize = 0;
+            expected_lastchunk = first;
+        }
+
+        loops = begin = end = chunksize = lastchunk = 0xdeadbeef;
+        p_vcomp_for_static_init(tests[i].first, tests[i].last, tests[i].step, tests[i].chunksize,
+                                &loops, &begin, &end, &chunksize, &lastchunk);
+
+        ok(loops == expected_loops, "%d:%d/%d: expected loops = %u, got %u\n",
+           i, thread_num, num_threads, expected_loops, loops);
+        ok(begin == expected_begin || broken(begin == 0xdeadbeef && first == last && thread_num > 0),
+           "%d:%d/%d: expected begin = %u, got %u\n", i, thread_num, num_threads, expected_begin, end);
+        ok(end == expected_end || broken(end == 0xdeadbeef && first == last && thread_num > 0),
+           "%d:%d/%d: expected end = %u, got %u\n", i, thread_num, num_threads, expected_end, end);
+        ok(chunksize == expected_chunksize || broken(chunksize == (int)0xdeadbeef && first == last) ||
+           broken(chunksize != expected_chunksize && num_threads == 1),
+           "%d:%d/%d: expected chunksize = %u, got %u\n", i, thread_num, num_threads, expected_chunksize, chunksize);
+        ok(lastchunk == expected_lastchunk || broken(lastchunk == 0xdeadbeef && first == last && thread_num > 0),
+           "%d:%d/%d: expected lastchunk = %u, got %u\n", i, thread_num, num_threads, expected_lastchunk, lastchunk);
+
+        p_vcomp_for_static_end();
+        p_vcomp_barrier();
+    }
+}
+
+static void test_vcomp_for_static_init(void)
+{
+    int i;
+
+    for (i = 1; i <= 4; i++)
+    {
+        trace("Running tests with %d threads\n", i);
+        pomp_set_num_threads(i);
+        p_vcomp_fork(TRUE, 0, _test_vcomp_for_static_init);
+    }
+}
+
 START_TEST(vcomp)
 {
     if (!init_vcomp())
@@ -345,6 +543,7 @@ START_TEST(vcomp)
 
     test_vcomp_fork();
     test_vcomp_for_static_simple_init();
+    test_vcomp_for_static_init();
 
     FreeLibrary(hvcomp);
 }
-- 
2.4.5

